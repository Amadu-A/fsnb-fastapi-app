{
  "meta": {
    "generated_at_utc": "2025-12-23T13:19:06Z",
    "root": "/home/main/PycharmProjects/fsnb-fastapi-app",
    "tool": "dump_project.py",
    "max_file_bytes": 500000,
    "total_files": 134
  },
  "context": {
    "project_description": "Краткое описание проекта, архитектура, стек, цели.",
    "static_instructions": [
      "Это команды для обсуждения, rewie, улучшения, оптимизации, модернизации и исправления кода для распознавания pdf-файлов с помощью парсинга и обучения YOLO модели и подготовке на основе этих данных отчетов в excel.",
      "Проанализируй весь код проекта, разберись, что и с чем связано.",
      "Каждый файл, который ты подготовишь, должен быть заполнен.",
      "каждый кусок кода , который ты покажешь должен быть строго указан к какому файлу он принадлежит.",
      "Имена переменных и функций — PEP8.",
      "Писать код с упором на низкое потребление памяти и работу с большими данными.",
      "Единый кастомный JSON-логгер через LoggerAdapter (время, уровень, имя функции, сообщение).",
      "Документировать функции и ключевые участки кода.",
      "Все изменения кода подписывай определенным файлом, в котором мы делаем изменения.",
      "Не приводи допущений, где я сам должен что-то понять и довести дело до конца.",
      "Объясни каждую строку кода.",
      "Предлагай улучшения таким образом, чтобы не порушить существующую логику, которая уже работает."
    ],
    "current_objectives": []
  },
  "structure_text": "./\n  .dockerignore\n  .env.examlpe\n  .gitignore\n  Dockerfile\n  Readme.md\n  __init__.py\n  alembic.ini\n  docker-compose.yml\n  dump_project.py\n  poetry.lock\n  project_dump.json\n  pyproject.toml\n  static/\n    static/js/\n      app.js\n      avatar-preview.js\n      fsnb_matcher.js\n    static/css/\n      style.css\n    static/uploads/\n      static/uploads/avatars/\n        static/uploads/avatars/user_1/\n    static/img/\n  FSNB-2022_28_08_25/\n    База ТГ.xml\n    ГЭСН.xml\n    ГЭСНм.xml\n    ГЭСНмр.xml\n    ГЭСНп.xml\n    ГЭСНр.xml\n    Ключи перехода ТГ.xml\n    ФСБЦ_Мат&Оборуд.xml\n    ФСБЦ_Маш.xml\n  src/\n    __init__.py\n    admin.py\n    app_logging.py\n    main.py\n    manage.py\n    src/crud/\n      __init__.py\n      feedback_candidate_repository.py\n      feedback_label_repository.py\n      feedback_row_repository.py\n      feedback_session_repository.py\n      item_repository.py\n      permission_repository.py\n      profile_repository.py\n      user_repository.py\n    src/core/\n      __init__.py\n      config.py\n      dependencies.py\n      email_tokens.py\n      security.py\n      src/core/models/\n        __init__.py\n        base.py\n        db_helper.py\n        permission.py\n        profile.py\n        user.py\n      src/core/utils/\n        __init__.py\n        case_converter.py\n      src/core/schemas/\n        __init__.py\n        permission.py\n        profile.py\n        user.py\n      src/core/mailing/\n        __init__.py\n        email.py\n      src/core/api/\n        __init__.py\n        src/core/api/api_v1/\n          __init__.py\n          auth.py\n          users.py\n      src/core/services/\n        __init__.py\n        auth_service.py\n      src/core/views/\n        __init__.py\n        admin.py\n        auth.py\n        web.py\n    src/fsnb_matcher/\n      __init__.py\n      src/fsnb_matcher/models/\n        __init__.py\n        item.py\n      src/fsnb_matcher/utils/\n        __init__.py\n      src/fsnb_matcher/schemas/\n        __init__.py\n        item.py\n      src/fsnb_matcher/api/\n        __init__.py\n        src/fsnb_matcher/api/api_v1/\n          __init__.py\n          deps.py\n          match.py\n      src/fsnb_matcher/services/\n        __init__.py\n        fsnb_xml_parser.py\n        index_qdrant.py\n        ingest.py\n        ingest_items.py\n        matcher_service.py\n        parser.py\n        qdr.py\n      src/fsnb_matcher/views/\n        __init__.py\n      src/fsnb_matcher/embeddings/\n        __init__.py\n        model_giga.py\n    src/templates/\n      src/templates/core/\n        _header.html\n        base.html\n        index.html\n        login.html\n        profile.html\n        register.html\n      src/templates/users/\n        list.html\n      src/templates/admin/\n        index.html\n        login.html\n        model_edit.html\n        model_list.html\n        perm_edit.html\n        profile_edit.html\n        user_edit.html\n        users.html\n      src/templates/fsnb_matcher/\n        widget.html\n      src/templates/train/\n        review_table.html\n        review_upload.html\n    src/train/\n      __init__.py\n      src/train/models/\n        __init__.py\n        enums.py\n        feedback_candidate.py\n        feedback_label.py\n        feedback_row.py\n        feedback_session.py\n        training_run.py\n        training_run_row.py\n      src/train/utils/\n        __init__.py\n        access.py\n      src/train/schemas/\n        __init__.py\n        common.py\n        feedback_candidate.py\n        feedback_label.py\n        feedback_row.py\n        feedback_session.py\n        training_run.py\n      src/train/api/\n        __init__.py\n        src/train/api/api_v1/\n          __init__.py\n          review.py\n      src/train/services/\n        __init__.py\n        feedback_persist_service.py\n        report_service.py\n        review_service.py\n      src/train/views/\n        __init__.py\n        review.py\n    src/scripts/\n      create_fsnb_pg.py\n      init_vector_db.py\n      superuser.py\n  alembic/\n    README\n    env.py\n    script.py.mako\n    alembic/versions/\n      2025_11_10_1130-c1e86fa06fba_create_users_table.py\n      2025_11_10_1138-cff667a73384_update_users_table.py\n      2025_12_09_1325-33aa3a368fa8_users_profile_permission.py\n      2025_12_09_1626-655d3e998655_make_username_nullable.py\n      2025_12_09_1632-e133393acc3f_expand_activation_key_to_255.py\n      2025_12_09_1702-e8c5f30d93ed_drop_uq_users_foo_bar.py\n      2025_12_10_1436-87f35af16311_cascade_deletes_trigger_profile_user.py\n      2025_12_16_1347-940ec7a6bbce_fsnb_matcher_add_items.py\n      2025_12_16_1359-e306c008d156_fsnb_matcher_create_items_table.py\n      2025_12_23_1510-5390851f3bfd_train_feedback_tables.py",
  "files": [
    {
      "path": "Dockerfile",
      "language": "docker",
      "size_bytes": 1146,
      "sha256": "1ca242c3da4a980e773d8ade1f32f065e30255238830067b19df7e0c2147a1ab",
      "content": "# path: Dockerfile\nFROM python:3.12-slim AS base\n\nENV PYTHONDONTWRITEBYTECODE=1 \\\n    PYTHONUNBUFFERED=1 \\\n    PIP_NO_CACHE_DIR=1 \\\n    POETRY_VERSION=1.8.3 \\\n    PYTHONPATH=/app/src \\\n    HF_HOME=/app/weights/hf-cache \\\n    TRANSFORMERS_CACHE=/app/weights/hf-cache \\\n    SENTENCE_TRANSFORMERS_HOME=/app/weights/hf-cache \\\n    PYTORCH_CUDA_ALLOC_CONF=expandable_segments:True\n\nRUN apt-get update && apt-get install -y --no-install-recommends \\\n    build-essential curl git ca-certificates locales \\\n && rm -rf /var/lib/apt/lists/*\n\nRUN pip install --no-cache-dir \"poetry==${POETRY_VERSION}\" && poetry --version\n\nWORKDIR /app\n\nCOPY pyproject.toml poetry.lock ./\nRUN poetry config virtualenvs.create false \\\n && poetry install --only main --no-interaction --no-ansi\n\nRUN pip install --no-cache-dir --index-url https://download.pytorch.org/whl/cu121 \\\n    torch torchvision torchaudio\n\n# ✅ Добавляем копирование статики (и папку uploads, если она уже есть)\nCOPY static ./static\nCOPY src ./src\n\nEXPOSE 8000\n\nCMD [\"poetry\", \"run\", \"uvicorn\", \"src.main:main_app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n"
    },
    {
      "path": "Readme.md",
      "language": "markdown",
      "size_bytes": 18363,
      "sha256": "77948307cdb1cc6536a0c7d2830821a404b75ca3cb46b898eb7e1a3dbae7ab83",
      "content": "\n# fsnb-fastapi — базовый каркас веб‑приложения на FastAPI\n\nЛёгкий, но «живой» стартовый проект: веб‑шаблоны (Jinja2), сессии и формы, JWT‑авторизация для API, пользователи/профили/права, загрузка аватара, а также простая админ‑панель с регистрацией моделей «как в Django». Стек — **FastAPI + SQLAlchemy (async) + Alembic + Jinja2 + OAuth2/JWT**.\n\n---\n\n## Содержание\n\n- [Возможности](#возможности)\n- [Архитектура и стек](#архитектура-и-стек)\n- [Структура проекта](#структура-проекта)\n- [Быстрый старт](#быстрый-старт)\n  - [Требования](#требования)\n  - [Переменные окружения](#переменные-окружения)\n  - [Инициализация БД](#инициализация-бд)\n  - [Запуск dev‑сервера](#запуск-dev-сервера)\n  - [Создание суперпользователя](#создание-суперпользователя)\n- [Веб‑интерфейс](#веб-интерфейс)\n  - [/ – главная](#--главная)\n  - [/login, /register – вход/регистрация](#login-register--входрегистрация)\n  - [/profile – профиль и аватар](#profile--профиль-и-аватар)\n  - [/admin – админ‑панель](#admin--админ-панель)\n- [API (OAuth2/JWT)](#api-oauth2jwt)\n  - [/api/v1/auth/token](#apiv1authtoken)\n  - [/api/v1/users](#apiv1users)\n- [Модели и права](#модели-и-права)\n- [Регистрация моделей в админке (аналог django admin.py)](#регистрация-моделей-в-админке-аналог-django-adminpy)\n- [Загрузка файлов и ограничения](#загрузка-файлов-и-ограничения)\n- [Расширение и доработка](#расширение-и-доработка)\n- [Подсказки и устранение проблем](#подсказки-и-устранение-проблем)\n\n---\n\n## Возможности\n\n- Пользователи с профилем и правами (**User ↔ Profile ↔ Permission**).\n- Авторизация:\n  - веб‑часть — через **сессии и формы**;\n  - API — через **OAuth2 Password** и **JWT**.\n- Профиль пользователя: редактирование полей + **загрузка/предпросмотр аватара** (кнопка «Удалить» и дефолтная картинка).\n- Ограничения на файл аватара: **только изображения**, **≤ 3 МБ**, **минимум 40×40 px**; при замене старый файл удаляется.\n- Простая **админ‑панель**:\n  - вход только для `is_superadmin` или `is_admin`;\n  - список зарегистрированных моделей, просмотр/редактирование полей с ограничениями read‑only;\n  - управление правами пользователей (админ не может менять флаги супер‑админа).\n- «Django‑like» **регистрация моделей** для админки в `base_app/admin.py` (аналог `admin.site.register()`).\n\n---\n\n## Архитектура и стек\n\n- **FastAPI** (асинхронный веб‑фреймворк).\n- **SQLAlchemy (async)** + **Alembic** (ORM и миграции).\n- **Jinja2** (шаблоны), **Starlette sessions** (сессии).\n- **Passlib (bcrypt_sha256)** для хеширования паролей.\n- **python-jose** для JWT.\n- **Poetry** для зависимостей (см. `pyproject.toml`).\n\nОтдельная настройка: `base_app/core/config.py` — Pydantic Settings с префиксом переменных окружения `APP_CONFIG__…`.\n\n---\n\n## Структура проекта\n\nГлавные узлы (примерно):\n\n```\nFastAPIbase/\n├─ src/\n│  ├─ main.py\n│  ├─ manage.py               # CLI (create_superuser и пр.)\n│  ├─ admin.py                # реестр моделей для админки\n│  ├─ logging.py\n│  ├─ core/\n│  │  ├─ views/\n│  │  │  ├─ web.py\n│  │  │  ├─ auth.py\n│  │  │  └─ admin.py          # (или admin_views.py)\n│  │  ├─ api/\n│  │  │  └─ api_v1/\n│  │  │     ├─ __init__.py    # сборка роутеров v1\n│  │  │     ├─ users.py\n│  │  │     └─ auth.py\n│  │  ├─ models/\n│  │  │  ├─ __init__.py\n│  │  │  ├─ base.py\n│  │  │  ├─ db_helper.py\n│  │  │  ├─ permission.py\n│  │  │  ├─ profile.py\n│  │  │  └─ user.py\n│  │  ├─ schemas/\n│  │  │  ├─ __init__.py\n│  │  │  ├─ permission.py\n│  │  │  ├─ profile.py\n│  │  │  └─ user.py\n│  │  ├─ services/\n│  │  │  ├─ __init__.py\n│  │  │  └─ auth_service.py\n│  │  ├─ mailing/\n│  │  │  ├─ __init__.py\n│  │  │  └─ mail.py\n│  │  ├─ utils/\n│  │  │  ├─ __init__.py\n│  │  │  └─ case_converter.py\n│  │  ├─ config.py\n│  │  ├─ email_tokens.py\n│  │  ├─ security.py\n│  │  └─ dependencies.py      # DI-провайдеры (возвращают crud)\n│  ├─ crud/\n│  │  ├─ user_repository.py\n│  │  ├─ profile_repository.py\n│  │  └─ permission_repository.py\n│  ├─ templates/\n│  │  ├─ core/{base,_header,login,register,profile,index}.html\n│  │  ├─ users/list.html\n│  │  └─ admin/{index,login,users,user_edit,profile_edit,perm_edit,model_list,model_edit}.html\n│  └─ scripts/\n│     └─ superuser.py\n├─ static/\n│  ├─ css/style.css\n│  ├─ js/{app.js,avatar-preview.js}\n│  ├─ img/\n│  └─ uploads/avatars/\n├─ alembic/\n│  ├─ env.py\n│  └─ versions/*.py\n├─ docker-compose.yml\n├─ poetry.lock\n├─ Readme.md\n├─ alembic.ini\n├─ .gitignore\n├─ .env\n├─ .env.example\n└─ pyproject.toml\n```\n\n---\n\n## Быстрый старт\n\n### Требования\n\n- Python 3.12+\n- PostgreSQL 14+ (или совместимый)\n- Poetry\n\n### Переменные окружения\n\nКонфиг читается через Pydantic Settings с префиксом `APP_CONFIG__` и разделителем `__` (см. `base_app/core/config.py`). Обязательное:\n\n```bash\nAPP_CONFIG__DB__URL=postgresql+asyncpg://user:password@localhost:5432/dbname\n```\n\nРекомендуется задать секреты:\n\n```bash\nAPP_CONFIG__AUTH__SECRET_KEY=change_me\nAPP_CONFIG__AUTH__EMAIL_VERIFY_SECRET=change_me_too\n```\n\n> В корне используйте корректный `.env` или `.env.example` (проверьте отсутствие опечаток в имени файла).\n\n\n## Start project services with Compose\n\nFrom the project root (where `docker-compose.yml` lives):\n\n```bash\n# Launch in background\ndocker compose up -d\n# See container status\ndocker compose ps\n# Stream logs (select services as needed)\ndocker compose logs -f postgres adminer mail\n```\n## Services & default addresses\n\nBelow are the **typical** defaults used in this project. If you changed ports or service names in `docker-compose.yml`, adjust accordingly.\n\n### PostgreSQL (DB)\n\n- **Internal service name (Compose network):** `postgres` (sometimes `db`)  \n- **Internal port:** `5432`  \n- **Published host port (example):** `5436`  \n- **Default credentials (match your app’s DSN):**\n  - **DB name:** `shop`\n  - **User:** `user`\n  - **Password:** `password`\n\n#### Connect from your host (psql / GUI):\n```bash\npsql \"postgresql://user:password@localhost:5436/shop\"\n```\n### Adminer (DB UI)\n\n- **URL (browser):** http://localhost:8091\n\nAt the login screen choose:\n\n| Field    | Value (inside Docker network)  | Alternative (through host port map) |\n|----------|--------------------------------|--------------------------------------|\n| System   | PostgreSQL                     | PostgreSQL                           |\n| Server   | `postgres`  *(or `db`)*        | `host.docker.internal:5436` *(Linux may use `172.17.0.1:5436`)* |\n| Username | `user`                         | `user`                               |\n| Password | `password`                     | `password`                           |\n| Database | `shop`                         | `shop`                               |\n\n> **Tip:** If Adminer can’t connect using `postgres` (or `db`), check the actual service name in `docker-compose.yml`.  \n> When using the **host port** variant, make sure Postgres is published on that port (e.g., `5436:5432`).\n\n\n### Инициализация БД\n\n```bash\npoetry install\npoetry run alembic upgrade head\n```\n\nМиграции находятся в `alembic/versions` и создают таблицы `users`, `profiles`, `permissions` с каскадными связями и триггером удаления.\n\n### Запуск dev‑сервера\n\n```bash\npoetry run python -m base_app.main\n# или:\n# poetry run uvicorn base_app.main:app --reload --port 8015\n```\n\nПараметры хоста/порта берутся из `base_app/core/config.py` (`run.host`, `run.port`).\n\n### Создание суперпользователя\n\nЕсть два пути:\n\n1) **CLI-обёртка**:\n\n```bash\npoetry run python -m base_app.manage --create_superuser\n```\n\nСкрипт интерактивно спросит `username`, `password`, `email` и выставит ключевые флаги прав (is_superadmin/is_admin и т. п.).\n\n2) **Прямая утилита**:\n\n```bash\npoetry run python -m base_app.scripts.superuser\n```\n\n---\n\n## Веб‑интерфейс\n\n### `/` — главная\n\nБазовая страница на Jinja2 (`templates/core/index.html`). Шапка из `_header.html` показывает «Профиль/Выйти» для авторизованных, «Вход/Регистрация» — для гостя.\n\n### `/login`, `/register` — вход/регистрация\n\nФормы находятся в `templates/core/{login,register}.html`, обработчики — `base_app/views/auth.py`. После входа создаётся сессионная авторизация для веб‑части.\n\n### `/profile` — профиль и аватар\n\n- Шаблон: `templates/core/profile.html`.\n- JS‑предпросмотр: `static/js/avatar-preview.js` (подключается через `base.html` с `defer`).\n- Серверная валидация:\n  - только **image/***;\n  - размер файла ≤ **3 МБ**;\n  - **минимум 40×40 px** (иначе будет alert/ошибка);\n  - при загрузке **старый аватар удаляется** (не копим мусор).\n- Хранение: `static/uploads/avatars/`; кнопка «Удалить аватар» — под мини‑превью справа от заголовка «Профиль».\n\nПоля профиля: `nickname`, `first_name`, `second_name`, `phone`, `email`, `tg_id`, `tg_nickname`, `session`, `verification` и др.\n\n### `/admin` — админ‑панель\n\n- Вход по `/admin/login` (CSRF в форме), хранится отдельная админ‑сессия.\n- Допускаются пользователи, у кого в связанной записи `Permission` стоит `is_superadmin=True` **или** `is_admin=True`.\n- Индекс показывает доступные модели (из реестра): `Users`, `Profiles`, `Permissions`.\n- Список/редактирование:\n  - списки: `templates/admin/users.html`, `model_list.html`;\n  - редактирование: `templates/admin/{user_edit,profile_edit,perm_edit,model_edit}.html`.\n- Логика прав:\n  - супер‑админ может менять всем всё;\n  - обычный админ **не может** изменять флаги супер‑админа;\n  - `is_superadmin` виден всем, но менять его может только супер‑админ.\n\n---\n\n## API (OAuth2/JWT)\n\n### `/api/v1/auth/token`\n\n`POST x-www-form-urlencoded` (OAuth2 Password: `username`, `password`) → `{\"access_token\": \"...\", \"token_type\": \"bearer\"}`. Реализация — `base_app/api/api_v1/auth.py`, JWT в `base_app/core/security.py`.\n\n> Убедитесь, что `tokenUrl` в зависимостях (`base_app/core/dependencies.py`) совпадает с фактическим префиксом роутера.\n\n### `/api/v1/users`\n\n- `GET` — список пользователей (`UserRead`), репозиторий: `base_app/crud/user_repository.py:get_all_users`.\n- `POST` — создать пользователя (`UserCreate` → User + Profile + базовый Permission).\n\n---\n\n## Модели и права\n\n- **User**: `email` (уникальный), `username` (опц.), `hashed_password`, `is_active`, `activation_key` (+служебные поля).\n- **Profile**: 1:1 к `User`; контактные/публичные поля + `verification`.\n- **Permission**: связь к `Profile` (практически 1:1), флаги:\n  - `is_superadmin`, `is_admin`, `is_staff`, `is_updater`, `is_reader`, `is_user`.\n\nВ БД настроены каскадные удаления, а также триггер, удаляющий `User` при удалении связанного `Profile`.\n\n---\n\n## Регистрация моделей в админке (аналог `django admin.py`)\n\nФайл `src/admin.py` содержит минимальный «реестр» моделей:\n\n```python\nfrom src.admin import admin_site\nfrom src.core.models.user import User\n\nadmin_site.register(\n    User,\n    slug=\"users\",\n    list_display=[\"id\", \"email\", \"username\", \"is_active\"],\n    form_fields=[\"email\", \"username\", \"is_active\", \"activation_key\"],\n    readonly_fields=[\"id\"],\n    search_fields=[\"email\", \"username\"],\n    can_create=False,\n    can_delete=False,\n)\n```\n\n- **`slug`** определяет часть URL (например, `/admin/m/users`).\n- **`list_display`** — колонки списка, **`form_fields`** — редактируемые поля, **`readonly_fields`** — только просмотр.\n- Аналогично регистрируются `Profile` и `Permission`.\n\n---\n\n## Загрузка файлов и ограничения\n\n- Каталог: `static/uploads/avatars/`.\n- Серверная валидация:\n  - MIME‑тип должен начинаться с `image/`;\n  - размер ≤ **3 МБ**;\n  - геометрия не меньше **40×40 px**.\n- При загрузке **предыдущий файл аватара удаляется**.\n- На фронте `static/js/avatar-preview.js` показывает превью, имя файла и валидирует ограничения **до** отправки формы; изменения применяются в UI сразу, но сохраняются только после нажатия «Сохранить».\n\n---\n\n\n\n\n## Расширение и доработка\n\n- Добавляйте модели в БД через Alembic, регистрируйте их в `base_app/admin.py` — они появятся в админ‑меню.\n- Политики прав можно расширять новыми флагами в `Permission` и проверками во вьюхах.\n- Веб‑часть масштабируется через новые шаблоны в `templates/` и статику в `static/`.\n- API — подключайте новые роутеры под `base_app/api/api_v1/`, включайте их в `__init__.py`.\n\n---\n\n## Подсказки и устранение проблем\n\n- **.env**: используйте `.env` или `.env.example` без опечаток.\n- **Маршруты/префиксы**: следите, чтобы `tokenUrl` и префиксы роутеров совпадали (во избежание «двойного префикса»).\n- **CSRF в админке**: логин/формы используют CSRF‑токен; при 400/403 проверьте скрытое поле и сессию.\n- **Права не сохраняются**: `is_superadmin` может менять только супер‑админ.\n- **Аватар/превью**: проверяйте подключение `static/js/avatar-preview.js` (через `defer`) и кеш браузера.\n\n\n# Сервис получения ВОР\n\nСоздать суперпользователя\n```\ndocker compose exec app bash -lc \"python -m src.manage --create_superuser\"\n```\nЗалить ФСНБ в Postgres\n```\ndocker compose exec app bash -lc \"python -m src.scripts.create_fsnb_pg\"\n```\nПроверить Postgres (таблицы + количество + примеры)\n```\ndocker compose exec pg bash -lc \"psql -U user -d shop -c '\\dt'\"\n\ndocker compose exec pg bash -lc \"psql -U user -d shop -c 'select count(*) from items;'\"\n\ndocker compose exec pg bash -lc \"psql -U user -d shop -c \\\"select type, count(*) from items group by type order by 2 desc;\\\"\"\n\ndocker compose exec pg bash -lc \"psql -U user -d shop -c \\\"select id, code, left(name,120) as name, unit, type from items order by id limit 5;\\\"\"\n```\nИндексация Qdrant\n```\ndocker compose exec app bash -lc \"python -m src.scripts.init_vector_db\"\n```\nПроверить Qdrant (с хоста)\n### список коллекций (на хосте qdrant проброшен как 6335)\n```\ncurl -s http://127.0.0.1:6335/collections | head\n```\n### count по коллекции (пример: fsnb_giga)\n```\ncurl -s -X POST \"http://127.0.0.1:6335/collections/fsnb_giga/points/count\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"exact\": true}' | head\n```\n"
    },
    {
      "path": "__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "alembic/env.py",
      "language": "python",
      "size_bytes": 2532,
      "sha256": "fda52c2147dd56f10a3d0cacdaefde5daf116d2ccf2661c619b84fb7f0610b9c",
      "content": "import asyncio\nfrom logging.config import fileConfig\n\nfrom sqlalchemy import pool\nfrom sqlalchemy.engine import Connection\nfrom sqlalchemy.ext.asyncio import async_engine_from_config\n\nfrom alembic import context\n\nfrom src.core.config import settings\nfrom src.core.models import Base\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = Base.metadata\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\nconfig.set_main_option(\"sqlalchemy.url\", str(settings.db.url))\n\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef do_run_migrations(connection: Connection) -> None:\n    context.configure(connection=connection, target_metadata=target_metadata)\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\nasync def run_async_migrations() -> None:\n    \"\"\"In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n\n    connectable = async_engine_from_config(\n        config.get_section(config.config_ini_section, {}),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    async with connectable.connect() as connection:\n        await connection.run_sync(do_run_migrations)\n\n    await connectable.dispose()\n\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\"\"\"\n\n    asyncio.run(run_async_migrations())\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"
    },
    {
      "path": "alembic/versions/2025_11_10_1130-c1e86fa06fba_create_users_table.py",
      "language": "python",
      "size_bytes": 1049,
      "sha256": "84ed820467e60ebbe596be951192a6672d3daa045d255bd286b8e8e877a59647",
      "content": "\"\"\"create users table\n\nRevision ID: c1e86fa06fba\nRevises:\nCreate Date: 2025-11-10 11:30:00.602050\n\n\"\"\"\n\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = \"c1e86fa06fba\"\ndown_revision: Union[str, Sequence[str], None] = None\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    \"\"\"Upgrade schema.\"\"\"\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table(\n        \"users\",\n        sa.Column(\"username\", sa.String(), nullable=False),\n        sa.Column(\"id\", sa.Integer(), nullable=False),\n        sa.PrimaryKeyConstraint(\"id\", name=op.f(\"pk_users\")),\n        sa.UniqueConstraint(\"username\", name=op.f(\"uq_users_username\")),\n    )\n    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    \"\"\"Downgrade schema.\"\"\"\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table(\"users\")\n    # ### end Alembic commands ###\n"
    },
    {
      "path": "alembic/versions/2025_11_10_1138-cff667a73384_update_users_table.py",
      "language": "python",
      "size_bytes": 1142,
      "sha256": "d5a1292949ab9d2ff6421a8830c604b7dadfc4c6378f8bd2c8d986a98136c960",
      "content": "\"\"\"update users table\n\nRevision ID: cff667a73384\nRevises: c1e86fa06fba\nCreate Date: 2025-11-10 11:38:35.346057\n\n\"\"\"\n\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = \"cff667a73384\"\ndown_revision: Union[str, Sequence[str], None] = \"c1e86fa06fba\"\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    \"\"\"Upgrade schema.\"\"\"\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.add_column(\"users\", sa.Column(\"foo\", sa.Integer(), nullable=False))\n    op.add_column(\"users\", sa.Column(\"bar\", sa.Integer(), nullable=False))\n    op.create_unique_constraint(\n        op.f(\"uq_users_foo_bar\"), \"users\", [\"foo\", \"bar\"]\n    )\n    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    \"\"\"Downgrade schema.\"\"\"\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_constraint(op.f(\"uq_users_foo_bar\"), \"users\", type_=\"unique\")\n    op.drop_column(\"users\", \"bar\")\n    op.drop_column(\"users\", \"foo\")\n    # ### end Alembic commands ###\n"
    },
    {
      "path": "alembic/versions/2025_12_09_1325-33aa3a368fa8_users_profile_permission.py",
      "language": "python",
      "size_bytes": 7449,
      "sha256": "2e854faff454db587f8552bf469ca57c932d2c62b879c1da1fc039b5deaa88e7",
      "content": "# /alembic/versions/2025_12_09_1325-33aa3a368fa8_users_profile_permission.py\nfrom __future__ import annotations\n\nimport sqlalchemy as sa\nfrom alembic import op\n\n# revision identifiers, used by Alembic.\nrevision = \"33aa3a368fa8\"\ndown_revision = \"cff667a73384\"\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade() -> None:\n    bind = op.get_bind()\n    insp = sa.inspect(bind)\n\n    def has_table(name: str) -> bool:\n        return insp.has_table(name)\n\n    def has_column(table: str, column: str) -> bool:\n        try:\n            return column in {c[\"name\"] for c in insp.get_columns(table)}\n        except Exception:\n            return False\n\n    # --- USERS ---\n    if not has_table(\"users\"):\n        # создаём таблицу users с актуальной структурой\n        op.create_table(\n            \"users\",\n            sa.Column(\"id\", sa.Integer(), primary_key=True, autoincrement=True),\n            sa.Column(\"email\", sa.String(length=255), nullable=False),\n            sa.Column(\"username\", sa.String(length=64), nullable=True),\n            sa.Column(\"hashed_password\", sa.String(length=255), nullable=True),\n            sa.Column(\"is_active\", sa.Boolean(), nullable=False, server_default=sa.true()),\n            sa.Column(\"activation_key\", sa.String(length=64), nullable=True),\n            sa.Column(\"activation_sent_at\", sa.DateTime(timezone=True), nullable=True),\n            sa.Column(\"foo\", sa.Integer(), nullable=False, server_default=\"0\"),\n            sa.Column(\"bar\", sa.Integer(), nullable=False, server_default=\"0\"),\n            sa.UniqueConstraint(\"email\", name=\"uq_users_email\"),\n            sa.UniqueConstraint(\"username\", name=\"uq_users_username\"),\n        )\n    else:\n        # добавляем недостающие колонки по одной\n        if not has_column(\"users\", \"email\"):\n            op.add_column(\"users\", sa.Column(\"email\", sa.String(length=255), nullable=True))\n            # бэкофилл email -> NOT NULL -> UNIQUE\n            bind.execute(\n                sa.text(\n                    \"\"\"\n                    UPDATE users\n                    SET email = COALESCE(\n                        email,\n                        CASE\n                            WHEN username IS NOT NULL AND username <> '' THEN username || '@local.invalid'\n                            ELSE 'user_' || id::text || '@local.invalid'\n                        END\n                    )\n                    \"\"\"\n                )\n            )\n            op.alter_column(\"users\", \"email\", existing_type=sa.String(length=255), nullable=False)\n            # создаём уникальный констрейнт, если его нет\n            uqs = insp.get_unique_constraints(\"users\")\n            if \"uq_users_email\" not in {uq[\"name\"] for uq in uqs}:\n                op.create_unique_constraint(\"uq_users_email\", \"users\", [\"email\"])\n\n        if not has_column(\"users\", \"username\"):\n            op.add_column(\"users\", sa.Column(\"username\", sa.String(length=64), nullable=True))\n            uqs = insp.get_unique_constraints(\"users\")\n            if \"uq_users_username\" not in {uq[\"name\"] for uq in uqs}:\n                op.create_unique_constraint(\"uq_users_username\", \"users\", [\"username\"])\n\n        if not has_column(\"users\", \"hashed_password\"):\n            op.add_column(\"users\", sa.Column(\"hashed_password\", sa.String(length=255), nullable=True))\n        if not has_column(\"users\", \"is_active\"):\n            op.add_column(\"users\", sa.Column(\"is_active\", sa.Boolean(), nullable=False, server_default=sa.true()))\n        if not has_column(\"users\", \"activation_key\"):\n            op.add_column(\"users\", sa.Column(\"activation_key\", sa.String(length=64), nullable=True))\n        if not has_column(\"users\", \"activation_sent_at\"):\n            op.add_column(\"users\", sa.Column(\"activation_sent_at\", sa.DateTime(timezone=True), nullable=True))\n        if not has_column(\"users\", \"foo\"):\n            op.add_column(\"users\", sa.Column(\"foo\", sa.Integer(), nullable=False, server_default=\"0\"))\n        if not has_column(\"users\", \"bar\"):\n            op.add_column(\"users\", sa.Column(\"bar\", sa.Integer(), nullable=False, server_default=\"0\"))\n\n    # --- PROFILES ---\n    if not has_table(\"profiles\"):\n        op.create_table(\n            \"profiles\",\n            sa.Column(\"id\", sa.Integer(), autoincrement=True, nullable=False),\n            sa.Column(\"nickname\", sa.String(length=64), nullable=True),\n            sa.Column(\"avatar\", sa.String(length=255), nullable=True),\n            sa.Column(\"first_name\", sa.String(length=48), nullable=True),\n            sa.Column(\"second_name\", sa.String(length=48), nullable=True),\n            sa.Column(\"phone\", sa.String(length=32), nullable=True),\n            sa.Column(\"email\", sa.String(length=255), nullable=True),\n            sa.Column(\"tg_id\", sa.BigInteger(), nullable=True),\n            sa.Column(\"tg_nickname\", sa.String(length=64), nullable=True),\n            sa.Column(\"verification\", sa.Boolean(), nullable=False, server_default=sa.false()),\n            sa.Column(\"session\", sa.String(length=255), nullable=True),\n            sa.Column(\"user_id\", sa.Integer(), nullable=False),\n            sa.ForeignKeyConstraint([\"user_id\"], [\"users.id\"]),\n            sa.PrimaryKeyConstraint(\"id\"),\n            sa.UniqueConstraint(\"user_id\", name=\"uq_profiles_user_id\"),\n        )\n\n    # --- PERMISSIONS ---\n    if not has_table(\"permissions\"):\n        op.create_table(\n            \"permissions\",\n            sa.Column(\"id\", sa.Integer(), autoincrement=True, nullable=False),\n            sa.Column(\"profile_id\", sa.Integer(), nullable=False),\n            sa.Column(\"is_superadmin\", sa.Boolean(), nullable=False, server_default=sa.false()),\n            sa.Column(\"is_admin\", sa.Boolean(), nullable=False, server_default=sa.false()),\n            sa.Column(\"is_staff\", sa.Boolean(), nullable=False, server_default=sa.false()),\n            sa.Column(\"is_updater\", sa.Boolean(), nullable=False, server_default=sa.false()),\n            sa.Column(\"is_reader\", sa.Boolean(), nullable=False, server_default=sa.false()),\n            sa.Column(\"is_user\", sa.Boolean(), nullable=False, server_default=sa.false()),\n            sa.ForeignKeyConstraint([\"profile_id\"], [\"profiles.id\"]),\n            sa.PrimaryKeyConstraint(\"id\"),\n        )\n\n\ndef downgrade() -> None:\n    bind = op.get_bind()\n    insp = sa.inspect(bind)\n\n    def has_table(name: str) -> bool:\n        return insp.has_table(name)\n\n    def has_uc(table: str, name: str) -> bool:\n        return name in {uc[\"name\"] for uc in insp.get_unique_constraints(table)}\n\n    # порядок важен: сначала зависимые\n    if has_table(\"permissions\"):\n        op.drop_table(\"permissions\")\n    if has_table(\"profiles\"):\n        op.drop_table(\"profiles\")\n\n    if has_table(\"users\"):\n        # мягкий откат: уберем констрейнты и колонки, которые добавляли\n        if has_uc(\"users\", \"uq_users_email\"):\n            op.drop_constraint(\"uq_users_email\", \"users\", type_=\"unique\")\n        if has_uc(\"users\", \"uq_users_username\"):\n            op.drop_constraint(\"uq_users_username\", \"users\", type_=\"unique\")\n\n        cols = {c[\"name\"] for c in insp.get_columns(\"users\")}\n        for col in (\"activation_sent_at\", \"activation_key\", \"is_active\", \"hashed_password\", \"email\", \"username\", \"foo\", \"bar\"):\n            if col in cols:\n                op.drop_column(\"users\", col)\n"
    },
    {
      "path": "alembic/versions/2025_12_09_1626-655d3e998655_make_username_nullable.py",
      "language": "python",
      "size_bytes": 1009,
      "sha256": "9ec8daa8515d176b8bc5ef9195b962f260ff09eee6387de7c0d32e9a1c9d1522",
      "content": "\"\"\"make username nullable\n\nRevision ID: 655d3e998655\nRevises: 33aa3a368fa8\nCreate Date: 2025-12-09 16:26:43.983839\n\n\"\"\"\n\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = \"655d3e998655\"\ndown_revision: Union[str, Sequence[str], None] = \"33aa3a368fa8\"\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    # Делаем username nullable=True\n    op.alter_column(\"users\", \"username\", existing_type=sa.String(length=64), nullable=True)\n\n\ndef downgrade() -> None:\n    # Откат осторожный: перед запретом NULL нужно заполнить пустые username\n    conn = op.get_bind()\n    conn.execute(sa.text(\"\"\"\n        UPDATE users\n        SET username = 'user_' || id::text\n        WHERE username IS NULL\n    \"\"\"))\n    op.alter_column(\"users\", \"username\", existing_type=sa.String(length=64), nullable=False)\n"
    },
    {
      "path": "alembic/versions/2025_12_09_1632-e133393acc3f_expand_activation_key_to_255.py",
      "language": "python",
      "size_bytes": 1208,
      "sha256": "efe87aa19126120c5bf6f67a7305b04aab03c96d3730579bb2a1cc267337b092",
      "content": "\"\"\"expand activation_key to 255\n\nRevision ID: e133393acc3f\nRevises: 655d3e998655\nCreate Date: 2025-12-09 16:32:43.704552\n\n\"\"\"\n\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = \"e133393acc3f\"\ndown_revision: Union[str, Sequence[str], None] = \"655d3e998655\"\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    # Было VARCHAR(64), делаем VARCHAR(255)\n    op.alter_column(\n        \"users\",\n        \"activation_key\",\n        existing_type=sa.String(length=64),\n        type_=sa.String(length=255),\n        existing_nullable=True,\n    )\n\n\ndef downgrade() -> None:\n    # ОСТОРОЖНО: при откате обрежем значения до 64 символов\n    conn = op.get_bind()\n    conn.execute(sa.text(\"\"\"\n        UPDATE users\n        SET activation_key = LEFT(activation_key, 64)\n        WHERE activation_key IS NOT NULL;\n    \"\"\"))\n    op.alter_column(\n        \"users\",\n        \"activation_key\",\n        existing_type=sa.String(length=255),\n        type_=sa.String(length=64),\n        existing_nullable=True,\n    )"
    },
    {
      "path": "alembic/versions/2025_12_09_1702-e8c5f30d93ed_drop_uq_users_foo_bar.py",
      "language": "python",
      "size_bytes": 786,
      "sha256": "33080c3add7ed7e239e7a5dca5c22a3565e5053e2c92959fdb4d6c965052ae2b",
      "content": "\"\"\"drop uq_users_foo_bar\n\nRevision ID: e8c5f30d93ed\nRevises: e133393acc3f\nCreate Date: 2025-12-09 17:02:20.420091\n\n\"\"\"\n\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = \"e8c5f30d93ed\"\ndown_revision: Union[str, Sequence[str], None] = \"e133393acc3f\"\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    # снимаем уникальность с (foo, bar)\n    op.drop_constraint(\"uq_users_foo_bar\", \"users\", type_=\"unique\")\n\n\ndef downgrade() -> None:\n    # возвращаем (если вдруг понадобится откат)\n    op.create_unique_constraint(\"uq_users_foo_bar\", \"users\", [\"foo\", \"bar\"])\n"
    },
    {
      "path": "alembic/versions/2025_12_10_1436-87f35af16311_cascade_deletes_trigger_profile_user.py",
      "language": "python",
      "size_bytes": 2741,
      "sha256": "83730473c7416a5256f39fde64c986effdd472344d9b7a3d871e98d258113ce9",
      "content": "\"\"\"cascade deletes + trigger profile->user\n\nRevision ID: 87f35af16311\nRevises: e8c5f30d93ed\nCreate Date: 2025-12-10 14:36:51.024796\n\n\"\"\"\n\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = \"87f35af16311\"\ndown_revision: Union[str, Sequence[str], None] = \"e8c5f30d93ed\"\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade():\n    # 1) Пересоздаем FK с ON DELETE CASCADE\n    op.drop_constraint(op.f(\"fk_profiles_user_id_users\"), \"profiles\", type_=\"foreignkey\")\n    op.create_foreign_key(\n        op.f(\"fk_profiles_user_id_users\"),\n        \"profiles\",\n        \"users\",\n        [\"user_id\"],\n        [\"id\"],\n        ondelete=\"CASCADE\",\n    )\n\n    op.drop_constraint(op.f(\"fk_permissions_profile_id_profiles\"), \"permissions\", type_=\"foreignkey\")\n    op.create_foreign_key(\n        op.f(\"fk_permissions_profile_id_profiles\"),\n        \"permissions\",\n        \"profiles\",\n        [\"profile_id\"],\n        [\"id\"],\n        ondelete=\"CASCADE\",\n    )\n\n    # 2) Функция триггера (одна команда — можно в одном op.execute)\n    op.execute(\n        \"\"\"\n        CREATE OR REPLACE FUNCTION delete_user_on_profile_delete()\n        RETURNS trigger AS $$\n        BEGIN\n            DELETE FROM users WHERE id = OLD.user_id;\n            RETURN OLD;\n        END;\n        $$ LANGUAGE plpgsql;\n        \"\"\"\n    )\n\n    # 3) Триггер — РАЗДЕЛЬНО (каждая команда в своем op.execute)\n    op.execute(\"DROP TRIGGER IF EXISTS trg_delete_user_on_profile_delete ON profiles;\")\n    op.execute(\n        \"\"\"\n        CREATE TRIGGER trg_delete_user_on_profile_delete\n        AFTER DELETE ON profiles\n        FOR EACH ROW\n        EXECUTE FUNCTION delete_user_on_profile_delete();\n        \"\"\"\n    )\n\n\ndef downgrade():\n    # Удаляем триггер и функцию\n    op.execute(\"DROP TRIGGER IF EXISTS trg_delete_user_on_profile_delete ON profiles;\")\n    op.execute(\"DROP FUNCTION IF EXISTS delete_user_on_profile_delete();\")\n\n    # Возвращаем FK без каскада\n    op.drop_constraint(op.f(\"fk_permissions_profile_id_profiles\"), \"permissions\", type_=\"foreignkey\")\n    op.create_foreign_key(\n        op.f(\"fk_permissions_profile_id_profiles\"),\n        \"permissions\",\n        \"profiles\",\n        [\"profile_id\"],\n        [\"id\"],\n        ondelete=None,\n    )\n\n    op.drop_constraint(op.f(\"fk_profiles_user_id_users\"), \"profiles\", type_=\"foreignkey\")\n    op.create_foreign_key(\n        op.f(\"fk_profiles_user_id_users\"),\n        \"profiles\",\n        \"users\",\n        [\"user_id\"],\n        [\"id\"],\n        ondelete=None,\n    )\n"
    },
    {
      "path": "alembic/versions/2025_12_16_1347-940ec7a6bbce_fsnb_matcher_add_items.py",
      "language": "python",
      "size_bytes": 1144,
      "sha256": "ac48b0f3b2064535c4b6f03f71bff87a78998b02e592dcaa9bcea06fb10c4f8f",
      "content": "\"\"\"fsnb_matcher: add items\n\nRevision ID: 940ec7a6bbce\nRevises: 87f35af16311\nCreate Date: 2025-12-16 13:47:56.185360\n\n\"\"\"\n\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = \"940ec7a6bbce\"\ndown_revision: Union[str, Sequence[str], None] = \"87f35af16311\"\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    \"\"\"Upgrade schema.\"\"\"\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_index(\n        op.f(\"ix_permissions_profile_id\"),\n        \"permissions\",\n        [\"profile_id\"],\n        unique=True,\n    )\n    op.create_index(\n        op.f(\"ix_profiles_user_id\"), \"profiles\", [\"user_id\"], unique=True\n    )\n    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    \"\"\"Downgrade schema.\"\"\"\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_index(op.f(\"ix_profiles_user_id\"), table_name=\"profiles\")\n    op.drop_index(op.f(\"ix_permissions_profile_id\"), table_name=\"permissions\")\n    # ### end Alembic commands ###\n"
    },
    {
      "path": "alembic/versions/2025_12_16_1359-e306c008d156_fsnb_matcher_create_items_table.py",
      "language": "python",
      "size_bytes": 1148,
      "sha256": "f7fdc8ad1b8910c5a91762046bb05f1297f2492ca4c5e228fe366100e7236c9b",
      "content": "\"\"\"fsnb_matcher: create items table\n\nRevision ID: e306c008d156\nRevises: 940ec7a6bbce\nCreate Date: 2025-12-16 13:59:24.374547\n\n\"\"\"\n\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = \"e306c008d156\"\ndown_revision: Union[str, Sequence[str], None] = \"940ec7a6bbce\"\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    op.create_table(\n        \"items\",\n        sa.Column(\"id\", sa.Integer(), primary_key=True, autoincrement=True),\n        sa.Column(\"code\", sa.Text(), nullable=True),\n        sa.Column(\"name\", sa.Text(), nullable=False),\n        sa.Column(\"unit\", sa.Text(), nullable=True),\n        sa.Column(\"type\", sa.Text(), nullable=False),\n        sa.UniqueConstraint(\"code\", name=\"uq_items_code\"),\n        sa.CheckConstraint(\"type IN ('work','resource')\", name=\"chk_items_type\"),\n    )\n    op.create_index(op.f(\"ix_items_name\"), \"items\", [\"name\"], unique=False)\n\n\ndef downgrade() -> None:\n    op.drop_index(op.f(\"ix_items_name\"), table_name=\"items\")\n    op.drop_table(\"items\")"
    },
    {
      "path": "alembic/versions/2025_12_23_1510-5390851f3bfd_train_feedback_tables.py",
      "language": "python",
      "size_bytes": 11706,
      "sha256": "dd57371b731ea1b97a601ce3cd2e0ab8b9bbb49595aceb251341f636f67efecf",
      "content": "\"\"\"train_feedback_tables\n\nRevision ID: 5390851f3bfd\nRevises: e306c008d156\nCreate Date: 2025-12-23 15:10:33.380230\n\n\"\"\"\n\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\nfrom sqlalchemy.dialects import postgresql\n\n# revision identifiers, used by Alembic.\nrevision: str = \"5390851f3bfd\"\ndown_revision: Union[str, Sequence[str], None] = \"e306c008d156\"\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    \"\"\"Upgrade schema.\"\"\"\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table(\n        \"feedback_sessions\",\n        sa.Column(\"id\", sa.BigInteger(), autoincrement=True, nullable=False),\n        sa.Column(\"source_name\", sa.Text(), nullable=True),\n        sa.Column(\"created_by\", sa.Text(), nullable=True),\n        sa.Column(\n            \"created_at\",\n            sa.DateTime(timezone=True),\n            server_default=sa.text(\"now()\"),\n            nullable=False,\n        ),\n        sa.Column(\"status\", sa.Text(), server_default=\"open\", nullable=False),\n        sa.PrimaryKeyConstraint(\"id\", name=op.f(\"pk_feedback_sessions\")),\n    )\n    op.create_table(\n        \"training_runs\",\n        sa.Column(\"id\", sa.BigInteger(), autoincrement=True, nullable=False),\n        sa.Column(\n            \"started_at\",\n            sa.DateTime(timezone=True),\n            server_default=sa.text(\"now()\"),\n            nullable=False,\n        ),\n        sa.Column(\"finished_at\", sa.DateTime(timezone=True), nullable=True),\n        sa.Column(\"mode\", sa.Text(), nullable=False),\n        sa.Column(\"base_model\", sa.Text(), nullable=False),\n        sa.Column(\n            \"data_spec\",\n            postgresql.JSONB(astext_type=sa.Text()),\n            nullable=False,\n        ),\n        sa.Column(\"artifacts_path\", sa.Text(), nullable=True),\n        sa.Column(\n            \"metrics\", postgresql.JSONB(astext_type=sa.Text()), nullable=True\n        ),\n        sa.Column(\n            \"status\", sa.Text(), server_default=\"running\", nullable=False\n        ),\n        sa.Column(\"log_path\", sa.Text(), nullable=True),\n        sa.Column(\"created_by\", sa.Text(), nullable=True),\n        sa.PrimaryKeyConstraint(\"id\", name=op.f(\"pk_training_runs\")),\n    )\n    op.create_index(\n        \"ix_training_runs_mode_started_at\",\n        \"training_runs\",\n        [\"mode\", \"started_at\"],\n        unique=False,\n    )\n    op.create_index(\n        op.f(\"ix_training_runs_started_at\"),\n        \"training_runs\",\n        [\"started_at\"],\n        unique=False,\n    )\n    op.create_index(\n        \"ix_training_runs_status\", \"training_runs\", [\"status\"], unique=False\n    )\n    op.create_table(\n        \"feedback_rows\",\n        sa.Column(\"id\", sa.BigInteger(), autoincrement=True, nullable=False),\n        sa.Column(\"session_id\", sa.BigInteger(), nullable=True),\n        sa.Column(\"caption\", sa.Text(), nullable=False),\n        sa.Column(\"units_in\", sa.Text(), nullable=True),\n        sa.Column(\"qty_in\", sa.Text(), nullable=True),\n        sa.Column(\n            \"norm_json\", postgresql.JSONB(astext_type=sa.Text()), nullable=True\n        ),\n        sa.Column(\"created_by\", sa.Text(), nullable=True),\n        sa.Column(\n            \"created_at\",\n            sa.DateTime(timezone=True),\n            server_default=sa.text(\"now()\"),\n            nullable=False,\n        ),\n        sa.Column(\n            \"is_trusted\", sa.Boolean(), server_default=\"false\", nullable=False\n        ),\n        sa.ForeignKeyConstraint(\n            [\"session_id\"],\n            [\"feedback_sessions.id\"],\n            name=op.f(\"fk_feedback_rows_session_id_feedback_sessions\"),\n            ondelete=\"CASCADE\",\n        ),\n        sa.PrimaryKeyConstraint(\"id\", name=op.f(\"pk_feedback_rows\")),\n    )\n    op.create_index(\n        op.f(\"ix_feedback_rows_created_at\"),\n        \"feedback_rows\",\n        [\"created_at\"],\n        unique=False,\n    )\n    op.create_index(\n        op.f(\"ix_feedback_rows_is_trusted\"),\n        \"feedback_rows\",\n        [\"is_trusted\"],\n        unique=False,\n    )\n    op.create_index(\n        \"ix_feedback_rows_session_created_at\",\n        \"feedback_rows\",\n        [\"session_id\", \"created_at\"],\n        unique=False,\n    )\n    op.create_index(\n        op.f(\"ix_feedback_rows_session_id\"),\n        \"feedback_rows\",\n        [\"session_id\"],\n        unique=False,\n    )\n    op.create_table(\n        \"feedback_candidates\",\n        sa.Column(\"id\", sa.BigInteger(), autoincrement=True, nullable=False),\n        sa.Column(\"row_id\", sa.BigInteger(), nullable=False),\n        sa.Column(\"item_id\", sa.Integer(), nullable=False),\n        sa.Column(\"model_name\", sa.Text(), nullable=False),\n        sa.Column(\"model_version\", sa.Text(), nullable=True),\n        sa.Column(\"score\", sa.Float(), nullable=True),\n        sa.Column(\"rank\", sa.Integer(), nullable=True),\n        sa.Column(\n            \"shown\", sa.Boolean(), server_default=\"true\", nullable=False\n        ),\n        sa.Column(\n            \"created_at\",\n            sa.DateTime(timezone=True),\n            server_default=sa.text(\"now()\"),\n            nullable=False,\n        ),\n        sa.ForeignKeyConstraint(\n            [\"item_id\"],\n            [\"items.id\"],\n            name=op.f(\"fk_feedback_candidates_item_id_items\"),\n            ondelete=\"RESTRICT\",\n        ),\n        sa.ForeignKeyConstraint(\n            [\"row_id\"],\n            [\"feedback_rows.id\"],\n            name=op.f(\"fk_feedback_candidates_row_id_feedback_rows\"),\n            ondelete=\"CASCADE\",\n        ),\n        sa.PrimaryKeyConstraint(\"id\", name=op.f(\"pk_feedback_candidates\")),\n        sa.UniqueConstraint(\n            \"row_id\",\n            \"item_id\",\n            \"model_name\",\n            name=\"uq_feedback_candidates_row_item_model\",\n        ),\n    )\n    op.create_index(\n        op.f(\"ix_feedback_candidates_item_id\"),\n        \"feedback_candidates\",\n        [\"item_id\"],\n        unique=False,\n    )\n    op.create_index(\n        op.f(\"ix_feedback_candidates_row_id\"),\n        \"feedback_candidates\",\n        [\"row_id\"],\n        unique=False,\n    )\n    op.create_index(\n        \"ix_feedback_candidates_row_rank\",\n        \"feedback_candidates\",\n        [\"row_id\", \"rank\"],\n        unique=False,\n    )\n    op.create_table(\n        \"feedback_labels\",\n        sa.Column(\"id\", sa.BigInteger(), autoincrement=True, nullable=False),\n        sa.Column(\"row_id\", sa.BigInteger(), nullable=False),\n        sa.Column(\"label\", sa.Text(), nullable=False),\n        sa.Column(\"selected_item_id\", sa.Integer(), nullable=True),\n        sa.Column(\n            \"negatives\",\n            postgresql.ARRAY(sa.Integer()),\n            server_default=\"{}\",\n            nullable=False,\n        ),\n        sa.Column(\"note\", sa.Text(), nullable=True),\n        sa.Column(\"created_by\", sa.Text(), nullable=True),\n        sa.Column(\n            \"created_at\",\n            sa.DateTime(timezone=True),\n            server_default=sa.text(\"now()\"),\n            nullable=False,\n        ),\n        sa.Column(\n            \"is_trusted\", sa.Boolean(), server_default=\"false\", nullable=False\n        ),\n        sa.ForeignKeyConstraint(\n            [\"row_id\"],\n            [\"feedback_rows.id\"],\n            name=op.f(\"fk_feedback_labels_row_id_feedback_rows\"),\n            ondelete=\"CASCADE\",\n        ),\n        sa.ForeignKeyConstraint(\n            [\"selected_item_id\"],\n            [\"items.id\"],\n            name=op.f(\"fk_feedback_labels_selected_item_id_items\"),\n            ondelete=\"SET NULL\",\n        ),\n        sa.PrimaryKeyConstraint(\"id\", name=op.f(\"pk_feedback_labels\")),\n    )\n    op.create_index(\n        op.f(\"ix_feedback_labels_created_at\"),\n        \"feedback_labels\",\n        [\"created_at\"],\n        unique=False,\n    )\n    op.create_index(\n        op.f(\"ix_feedback_labels_is_trusted\"),\n        \"feedback_labels\",\n        [\"is_trusted\"],\n        unique=False,\n    )\n    op.create_index(\n        \"ix_feedback_labels_label\", \"feedback_labels\", [\"label\"], unique=False\n    )\n    op.create_index(\n        \"ix_feedback_labels_row_created_at\",\n        \"feedback_labels\",\n        [\"row_id\", \"created_at\"],\n        unique=False,\n    )\n    op.create_index(\n        op.f(\"ix_feedback_labels_row_id\"),\n        \"feedback_labels\",\n        [\"row_id\"],\n        unique=False,\n    )\n    op.create_index(\n        op.f(\"ix_feedback_labels_selected_item_id\"),\n        \"feedback_labels\",\n        [\"selected_item_id\"],\n        unique=False,\n    )\n    op.create_table(\n        \"training_run_rows\",\n        sa.Column(\"run_id\", sa.BigInteger(), nullable=False),\n        sa.Column(\"row_id\", sa.BigInteger(), nullable=False),\n        sa.Column(\n            \"added_at\",\n            sa.DateTime(timezone=True),\n            server_default=sa.text(\"now()\"),\n            nullable=False,\n        ),\n\n        sa.ForeignKeyConstraint(\n            [\"row_id\"],\n            [\"feedback_rows.id\"],\n            name=op.f(\"fk_training_run_rows_row_id_feedback_rows\"),\n            ondelete=\"CASCADE\",\n        ),\n        sa.ForeignKeyConstraint(\n            [\"run_id\"],\n            [\"training_runs.id\"],\n            name=op.f(\"fk_training_run_rows_run_id_training_runs\"),\n            ondelete=\"CASCADE\",\n        ),\n        sa.PrimaryKeyConstraint(\n            \"run_id\", \"row_id\", name=op.f(\"pk_training_run_rows\")\n        ),\n    )\n    op.create_index(\n        \"ix_training_run_rows_row_id\",\n        \"training_run_rows\",\n        [\"row_id\"],\n        unique=False,\n    )\n    op.create_index(\n        \"ix_training_run_rows_run_id\",\n        \"training_run_rows\",\n        [\"run_id\"],\n        unique=False,\n    )\n\n    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    \"\"\"Downgrade schema.\"\"\"\n    # ### commands auto generated by Alembic - please adjust! ###\n\n    op.drop_index(\n        \"ix_training_run_rows_run_id\", table_name=\"training_run_rows\"\n    )\n    op.drop_index(\n        \"ix_training_run_rows_row_id\", table_name=\"training_run_rows\"\n    )\n    op.drop_table(\"training_run_rows\")\n    op.drop_index(\n        op.f(\"ix_feedback_labels_selected_item_id\"),\n        table_name=\"feedback_labels\",\n    )\n    op.drop_index(\n        op.f(\"ix_feedback_labels_row_id\"), table_name=\"feedback_labels\"\n    )\n    op.drop_index(\n        \"ix_feedback_labels_row_created_at\", table_name=\"feedback_labels\"\n    )\n    op.drop_index(\"ix_feedback_labels_label\", table_name=\"feedback_labels\")\n    op.drop_index(\n        op.f(\"ix_feedback_labels_is_trusted\"), table_name=\"feedback_labels\"\n    )\n    op.drop_index(\n        op.f(\"ix_feedback_labels_created_at\"), table_name=\"feedback_labels\"\n    )\n    op.drop_table(\"feedback_labels\")\n    op.drop_index(\n        \"ix_feedback_candidates_row_rank\", table_name=\"feedback_candidates\"\n    )\n    op.drop_index(\n        op.f(\"ix_feedback_candidates_row_id\"), table_name=\"feedback_candidates\"\n    )\n    op.drop_index(\n        op.f(\"ix_feedback_candidates_item_id\"),\n        table_name=\"feedback_candidates\",\n    )\n    op.drop_table(\"feedback_candidates\")\n    op.drop_index(\n        op.f(\"ix_feedback_rows_session_id\"), table_name=\"feedback_rows\"\n    )\n    op.drop_index(\n        \"ix_feedback_rows_session_created_at\", table_name=\"feedback_rows\"\n    )\n    op.drop_index(\n        op.f(\"ix_feedback_rows_is_trusted\"), table_name=\"feedback_rows\"\n    )\n    op.drop_index(\n        op.f(\"ix_feedback_rows_created_at\"), table_name=\"feedback_rows\"\n    )\n    op.drop_table(\"feedback_rows\")\n    op.drop_index(\"ix_training_runs_status\", table_name=\"training_runs\")\n    op.drop_index(\n        op.f(\"ix_training_runs_started_at\"), table_name=\"training_runs\"\n    )\n    op.drop_index(\n        \"ix_training_runs_mode_started_at\", table_name=\"training_runs\"\n    )\n    op.drop_table(\"training_runs\")\n    op.drop_table(\"feedback_sessions\")\n    # ### end Alembic commands ###\n"
    },
    {
      "path": "alembic.ini",
      "language": "ini",
      "size_bytes": 4797,
      "sha256": "08ebc0246133f9b8b256bda33e10fbe0a09eb68dbe435ad2887b0c9c8b9864ba",
      "content": "# A generic, single database configuration.\n\n[alembic]\n# path to migration scripts.\n# this is typically a path given in POSIX (e.g. forward slashes)\n# format, relative to the token %(here)s which refers to the location of this\n# ini file\nscript_location = %(here)s/alembic\n\n# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s\n# Uncomment the line below if you want the files to be prepended with date and time\n# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file\n# for all available tokens\nfile_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s\n\n# sys.path path, will be prepended to sys.path if present.\n# defaults to the current working directory.  for multiple paths, the path separator\n# is defined by \"path_separator\" below.\nprepend_sys_path = .\n\n# timezone to use when rendering the date within the migration file\n# as well as the filename.\n# If specified, requires the tzdata library which can be installed by adding\n# `alembic[tz]` to the pip requirements.\n# string value is passed to ZoneInfo()\n# leave blank for localtime\n# timezone =\n\n# max length of characters to apply to the \"slug\" field\n# truncate_slug_length = 40\n\n# set to 'true' to run the environment during\n# the 'revision' command, regardless of autogenerate\n# revision_environment = false\n\n# set to 'true' to allow .pyc and .pyo files without\n# a source .py file to be detected as revisions in the\n# versions/ directory\n# sourceless = false\n\n# version location specification; This defaults\n# to <script_location>/versions.  When using multiple version\n# directories, initial revisions must be specified with --version-path.\n# The path separator used here should be the separator specified by \"path_separator\"\n# below.\n# version_locations = %(here)s/bar:%(here)s/bat:%(here)s/alembic/versions\n\n# path_separator; This indicates what character is used to split lists of file\n# paths, including version_locations and prepend_sys_path within configparser\n# files such as alembic.ini.\n# The default rendered in new alembic.ini files is \"os\", which uses os.pathsep\n# to provide os-dependent path splitting.\n#\n# Note that in order to support legacy alembic.ini files, this default does NOT\n# take place if path_separator is not present in alembic.ini.  If this\n# option is omitted entirely, fallback logic is as follows:\n#\n# 1. Parsing of the version_locations option falls back to using the legacy\n#    \"version_path_separator\" key, which if absent then falls back to the legacy\n#    behavior of splitting on spaces and/or commas.\n# 2. Parsing of the prepend_sys_path option falls back to the legacy\n#    behavior of splitting on spaces, commas, or colons.\n#\n# Valid values for path_separator are:\n#\n# path_separator = :\n# path_separator = ;\n# path_separator = space\n# path_separator = newline\n#\n# Use os.pathsep. Default configuration used for new projects.\npath_separator = os\n\n\n# set to 'true' to search source files recursively\n# in each \"version_locations\" directory\n# new in Alembic version 1.10\n# recursive_version_locations = false\n\n# the output encoding used when revision files\n# are written from script.py.mako\n# output_encoding = utf-8\n\n# database URL.  This is consumed by the user-maintained env.py script only.\n# other means of configuring database URLs may be customized within the env.py\n# file.\nsqlalchemy.url = driver://user:pass@localhost/dbname\n\n\n[post_write_hooks]\n# post_write_hooks defines scripts or Python functions that are run\n# on newly generated revision scripts.  See the documentation for further\n# detail and examples\n\n# format using \"black\" - use the console_scripts runner, against the \"black\" entrypoint\nhooks = black\nblack.type = console_scripts\nblack.entrypoint = black\nblack.options = -l 79 REVISION_SCRIPT_FILENAME\n\n# lint with attempts to fix using \"ruff\" - use the module runner, against the \"ruff\" module\n# hooks = ruff\n# ruff.type = module\n# ruff.module = ruff\n# ruff.options = check --fix REVISION_SCRIPT_FILENAME\n\n# Alternatively, use the exec runner to execute a binary found on your PATH\n# hooks = ruff\n# ruff.type = exec\n# ruff.executable = ruff\n# ruff.options = check --fix REVISION_SCRIPT_FILENAME\n\n# Logging configuration.  This is also consumed by the user-maintained\n# env.py script only.\n[loggers]\nkeys = root,sqlalchemy,alembic\n\n[handlers]\nkeys = console\n\n[formatters]\nkeys = generic\n\n[logger_root]\nlevel = WARNING\nhandlers = console\nqualname =\n\n[logger_sqlalchemy]\nlevel = WARNING\nhandlers =\nqualname = sqlalchemy.engine\n\n[logger_alembic]\nlevel = INFO\nhandlers =\nqualname = alembic\n\n[handler_console]\nclass = StreamHandler\nargs = (sys.stderr,)\nlevel = NOTSET\nformatter = generic\n\n[formatter_generic]\nformat = %(levelname)-5.5s [%(name)s] %(message)s\ndatefmt = %H:%M:%S\n"
    },
    {
      "path": "docker-compose.yml",
      "language": "yaml",
      "size_bytes": 1916,
      "sha256": "b61c561942811638059dcba4d2a24fbd07fee9877d8ae14a5c45fa9bf567c54e",
      "content": "# path: docker-compose.yml\nservices:\n  pg:\n    image: postgres:16\n    environment:\n      POSTGRES_DB: shop\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n    ports:\n      - \"5436:5432\"\n    volumes:\n      - pgdata:/var/lib/postgresql/data\n\n  adminer:\n    image: adminer\n    ports:\n      - \"8091:8080\"\n    depends_on:\n      - pg\n\n  pgadmin:\n    image: dpage/pgadmin4\n    environment:\n      PGADMIN_DEFAULT_EMAIL: admin@admin.org\n      PGADMIN_DEFAULT_PASSWORD: admin\n      PGADMIN_CONFIG_SERVER_MODE: \"False\"\n    ports:\n      - \"5050:80\"\n    depends_on:\n      - pg\n\n  mailhog:\n    image: mailhog/mailhog\n    ports:\n      - \"8025:8025\"\n      - \"1025:1025\"\n\n  qdrant:\n    image: qdrant/qdrant:v1.12.1\n    ports:\n      - \"6335:6333\"   # REST на хосте\n      - \"6336:6334\"   # health/metrics на хосте\n    volumes:\n      - qdrant_data:/qdrant/storage\n\n  app:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    env_file:\n      - .env\n    environment:\n      # Внутри docker-сети ходим по именам сервисов, а не localhost\n      APP_CONFIG__DB__URL: postgresql+asyncpg://user:password@pg:5432/shop\n      APP_CONFIG__QDRANT__HOST: qdrant\n      APP_CONFIG__QDRANT__PORT: \"6333\"\n      # если в твоём конфиге почта берётся из APP_CONFIG__EMAIL__*, можешь не задавать\n      APP_CONFIG__FSNB__HF_EMBED_DEVICE: cuda\n    deploy:\n      resources:\n        reservations:\n          devices:\n            - driver: nvidia\n              count: 1\n              capabilities: [gpu]\n    depends_on:\n      - pg\n      - qdrant\n      - mailhog\n    ports:\n      - \"8015:8000\"\n    volumes:\n      # данные и веса монтируем, чтобы не тянуть в образ\n      - ./FSNB-2022_28_08_25:/app/FSNB-2022_28_08_25\n      - ./weights:/app/weights\n      - ./static:/app/static\n\nvolumes:\n  pgdata:\n  qdrant_data:\n"
    },
    {
      "path": "dump_project.py",
      "language": "python",
      "size_bytes": 13810,
      "sha256": "f4518421853576c6f93550cb2f651d23f2b05931892c9b46cf2df8de46e56449",
      "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\ndump_project.py — собирает код и структуру проекта в JSON для LLM.\n\nЗапуск:\n  python dump_project.py \\\n    --out project_dump.json \\\n    --max-bytes 800000 \\\n    --tree-depth 5\n\nПо умолчанию:\n  - сохраняет structure.txt (через `tree`, если доступен; иначе — питоновская обводка);\n  - игнорирует бинарные/медийные файлы и стандартные служебные директории;\n  - кладёт весь текстовый код в JSON с хэшами и размерами;\n  - добавляет поля context.static_instructions и context.current_objectives.\n\nСоветы:\n  - Для больших репозиториев увеличьте --max-bytes при необходимости.\n  - Если нужно включить доп. расширения — правьте TEXT_EXTENSIONS или передавайте --include-ext.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport argparse\nimport hashlib\nimport json\nimport os\nimport shutil\nimport subprocess\nimport sys\nfrom datetime import datetime\nfrom fnmatch import fnmatch\nfrom pathlib import Path\nfrom typing import Iterable, List, Dict, Any, Set\n\n# --- Настройки по умолчанию ---\n\nDEFAULT_IGNORE_GLOBS: List[str] = [\n    # из запроса\n    \"__pycache__\",\n    \"*.sample\",\n    \"*.txt\",  # можно убрать, если нужны README/тексты\n    \"*.log\",\n    \"*.pdf\",\n    \"*.jpg\", \"*.jpeg\", \"*.svg\", \"*.png\",\n    \"*.pt\",\n    \"venv\", \".venv\", \"env\", \".env\", \"media\",\n    \"objects\",  #  \"dataset\",\n    \"__init__.pyc\",\n\n    # типичные служебные/тяжёлые каталоги\n    \".git\", \".idea\", \".vscode\", \".mypy_cache\", \".pytest_cache\",\n    \".ruff_cache\", \".cache\", \".tox\",\n    \"node_modules\", \"dist\", \"build\", \".next\", \".nuxt\", \".turbo\",\n    \"*.egg-info\", \"weights\",\n]\n\n# Каталоги, которые игнорируем только на верхнем уровне корня проекта\nROOT_ONLY_IGNORE_DIRS: Set[str] = {\"dataset\"}\n\n# Текстовые расширения, которые считаем безопасными для LLM\nTEXT_EXTENSIONS: Set[str] = {\n    # код\n    \".py\", \".pyi\", \".ipynb\",\n    \".js\", \".jsx\", \".ts\", \".tsx\",\n    \".html\", \".htm\", \".css\", \".scss\", \".sass\",\n    \".vue\", \".svelte\",\n    \".java\", \".kt\", \".kts\", \".swift\", \".go\", \".rs\",\n    \".c\", \".h\", \".cpp\", \".hpp\", \".cc\",\n    \".cs\", \".vb\",\n    \".php\", \".rb\", \".r\", \".m\", \".mm\", \".jl\", \".pl\", \".lua\",\n\n    # конфиги/данные\n    \".json\", \".jsonc\", \".yaml\", \".yml\", \".toml\", \".ini\", \".cfg\", \".conf\", \".env.example\",\n    \".sql\", \".graphql\",\n    \".sh\", \".bash\", \".zsh\", \".ps1\", \".bat\", \".cmd\", \"Dockerfile\", \".dockerfile\",\n    \".gitignore\", \".gitattributes\", \".editorconfig\",\n\n    # документация\n    \".md\", \".rst\", \".adoc\",\n}\n\n# Предельно допустимый размер текстового файла (байт) — чтобы не раздувать JSON\nDEFAULT_MAX_BYTES = 500_000\n\n\ndef parse_args() -> argparse.Namespace:\n    p = argparse.ArgumentParser(description=\"Собрать код и структуру проекта в JSON для LLM\")\n    p.add_argument(\"--root\", default=\".\", help=\"Корень проекта (по умолчанию текущая директория)\")\n    p.add_argument(\"--out\", default=\"project_dump.json\", help=\"Путь к JSON-выводу\")\n    p.add_argument(\"--max-bytes\", type=int, default=DEFAULT_MAX_BYTES, help=\"Макс. размер файла для включения\")\n    p.add_argument(\"--tree-depth\", type=int, default=5, help=\"Глубина для вывода структуры (tree)\")\n    p.add_argument(\"--no-structure\", action=\"store_true\", help=\"Не сохранять structure.txt\")\n    p.add_argument(\"--include-ext\", nargs=\"*\", default=None,\n                   help=\"Доп. расширения для включения (пример: .lock .txt)\")\n    p.add_argument(\"--extra-ignore\", nargs=\"*\", default=None,\n                   help=\"Доп. glob-шаблоны игнора (пример: secrets/* *.lock)\")\n    return p.parse_args()\n\n\ndef load_text(path: Path, max_bytes: int) -> str | None:\n    try:\n        if path.stat().st_size > max_bytes:\n            return None\n        # читаем как текст; невалидные байты заменяем\n        return path.read_text(encoding=\"utf-8\", errors=\"replace\")\n    except Exception:\n        return None\n\n\ndef sha256_text(s: str) -> str:\n    return hashlib.sha256(s.encode(\"utf-8\", errors=\"replace\")).hexdigest()\n\n\ndef is_ignored(path: Path, rel: str, ignore_globs: Iterable[str]) -> bool:\n    name = path.name\n    parts = Path(rel).parts\n    if parts and parts[0] in ROOT_ONLY_IGNORE_DIRS:\n        return True\n    for pattern in ignore_globs:\n        # Совпадение по имени файла/папки или по относительному пути\n        if fnmatch(name, pattern) or fnmatch(rel, pattern):\n            return True\n        # Для директорий допустим точное совпадение сегмента\n        # (например, 'venv' игнорирует любой каталог с таким именем)\n        # parts = Path(rel).parts\n        if pattern in parts:\n            return True\n    return False\n\n\ndef detect_language(ext: str, name: str) -> str:\n    # Очень грубая эвристика — достаточно для LLM-навигации\n    if name.lower() in {\"dockerfile\", \"compose.yaml\", \"compose.yml\"}:\n        return \"docker\"\n    MAP = {\n        \".py\": \"python\", \".js\": \"javascript\", \".ts\": \"typescript\", \".tsx\": \"typescriptreact\",\n        \".jsx\": \"javascriptreact\", \".html\": \"html\", \".css\": \"css\", \".scss\": \"scss\",\n        \".json\": \"json\", \".yaml\": \"yaml\", \".yml\": \"yaml\", \".toml\": \"toml\", \".ini\": \"ini\",\n        \".md\": \"markdown\", \".rst\": \"restructuredtext\", \".adoc\": \"asciidoc\",\n        \".sh\": \"bash\", \".bash\": \"bash\", \".zsh\": \"zsh\", \".ps1\": \"powershell\",\n        \".sql\": \"sql\", \".graphql\": \"graphql\", \".go\": \"go\", \".rs\": \"rust\",\n        \".c\": \"c\", \".h\": \"c\", \".cpp\": \"cpp\", \".hpp\": \"cpp\", \".cc\": \"cpp\",\n        \".java\": \"java\", \".kt\": \"kotlin\", \".kts\": \"kotlin\", \".swift\": \"swift\",\n        \".rb\": \"ruby\", \".php\": \"php\", \".cs\": \"csharp\", \".m\": \"objectivec\", \".mm\": \"objectivecpp\",\n        \".lua\": \"lua\", \".r\": \"r\", \".pl\": \"perl\", \".jl\": \"julia\",\n    }\n    return MAP.get(ext.lower(), ext.lower().lstrip(\".\") or \"text\")\n\n\ndef run_tree(root: Path, depth: int) -> str:\n    \"\"\"\n    Рендер структуры, уважающий DEFAULT_IGNORE_GLOBS и ROOT_ONLY_IGNORE_DIRS.\n    Специально НЕ используем внешнюю утилиту `tree`, чтобы корректно\n    игнорировать только корневые каталоги (например, dataset в корне, но не services/dataset).\n    \"\"\"\n    lines: List[str] = []\n    base = root.resolve()\n    max_depth = depth\n\n    for curr, dirs, files in os.walk(base):\n        rel = Path(curr).relative_to(base)\n        d = len(rel.parts)\n\n        # 1) На верхнем уровне — вырезаем только ROOT_ONLY_IGNORE_DIRS\n        if d == 0:\n            dirs[:] = [dn for dn in dirs if dn not in ROOT_ONLY_IGNORE_DIRS]\n\n        # 2) Вырезаем прочие игноры НА ВСЕХ уровнях (по нашим же правилам)\n        pruned_dirs: List[str] = []\n        for dn in dirs:\n            full = Path(curr) / dn\n            rel_dir = full.relative_to(base).as_posix()\n            if is_ignored(full, rel_dir, DEFAULT_IGNORE_GLOBS):\n                continue\n            pruned_dirs.append(dn)\n        dirs[:] = pruned_dirs\n\n        if d > max_depth:\n            dirs[:] = []\n            continue\n\n        indent = \"  \" * d\n        name = \".\" if rel == Path(\".\") else rel.as_posix()\n        lines.append(f\"{indent}{name}/\")\n\n        for f in sorted(files):\n            full = Path(curr) / f\n            rel_file = full.relative_to(base).as_posix()\n            if is_ignored(full, rel_file, DEFAULT_IGNORE_GLOBS):\n                continue\n            lines.append(f\"{indent}  {f}\")\n\n    return \"\\n\".join(lines)\n\n\ndef should_take_file(path: Path, include_ext: Set[str]) -> bool:\n    name = path.name\n    ext = path.suffix\n    if name.lower() == \"dockerfile\":\n        return True\n    return (ext in include_ext) or (ext in TEXT_EXTENSIONS)\n\n\ndef main() -> None:\n    args = parse_args()\n    root = Path(args.root).resolve()\n\n    ignore_globs = list(DEFAULT_IGNORE_GLOBS)\n    if args.extra_ignore:\n        ignore_globs.extend(args.extra_ignore)\n\n    include_ext: Set[str] = set()\n    if args.include_ext:\n        include_ext.update({e if e.startswith(\".\") else f\".{e}\" for e in args.include_ext})\n\n    files_out: List[Dict[str, Any]] = []\n\n    for path in sorted(root.rglob(\"*\")):\n        rel = path.relative_to(root).as_posix()\n\n        # игнор директорий целиком\n        if any(part.startswith(\".git\") for part in Path(rel).parts):\n            continue\n        if is_ignored(path, rel, ignore_globs):\n            if path.is_dir():\n                # пропускаем поддеревья через os.walk? rglob сам проглотит; этого достаточно\n                continue\n            else:\n                continue\n\n        if path.is_dir():\n            continue\n        if not path.is_file():\n            continue\n\n        if not should_take_file(path, include_ext):\n            continue\n\n        text = load_text(path, args.max_bytes)\n        if text is None:\n            continue\n\n        lang = detect_language(path.suffix, path.name)\n        entry = {\n            \"path\": rel,\n            \"language\": lang,\n            \"size_bytes\": len(text.encode(\"utf-8\", errors=\"replace\")),\n            \"sha256\": sha256_text(text),\n            \"content\": text,\n        }\n        files_out.append(entry)\n\n    # Структура проекта (текстом)\n    structure_text = None\n    if not args.no_structure:\n        structure_text = run_tree(root, args.tree_depth)\n        try:\n            Path(\"structure.txt\").write_text(structure_text or \"\", encoding=\"utf-8\")\n        except Exception:\n            pass\n\n    # Итоговый JSON для LLM\n    payload: Dict[str, Any] = {\n        \"meta\": {\n            \"generated_at_utc\": datetime.utcnow().isoformat(timespec=\"seconds\") + \"Z\",\n            \"root\": str(root),\n            \"tool\": \"dump_project.py\",\n            \"max_file_bytes\": args.max_bytes,\n            \"total_files\": len(files_out),\n        },\n        \"context\": {\n            # Заполните эти поля один раз и держите «статикой»\n            \"project_description\": \"Краткое описание проекта, архитектура, стек, цели.\",\n            \"static_instructions\": [\n                \"Это команды для обсуждения, rewie, улучшения, оптимизации, модернизации и исправления кода для распознавания pdf-файлов с помощью парсинга и обучения YOLO модели и подготовке на основе этих данных отчетов в excel.\",\n                \"Проанализируй весь код проекта, разберись, что и с чем связано.\",\n                \"Каждый файл, который ты подготовишь, должен быть заполнен.\",\n                \"каждый кусок кода , который ты покажешь должен быть строго указан к какому файлу он принадлежит.\",\n                \"Имена переменных и функций — PEP8.\",\n                \"Писать код с упором на низкое потребление памяти и работу с большими данными.\",\n                \"Единый кастомный JSON-логгер через LoggerAdapter (время, уровень, имя функции, сообщение).\",\n                \"Документировать функции и ключевые участки кода.\",\n                \"Все изменения кода подписывай определенным файлом, в котором мы делаем изменения.\",\n                \"Не приводи допущений, где я сам должен что-то понять и довести дело до конца.\",\n                \"Объясни каждую строку кода.\",\n                \"Предлагай улучшения таким образом, чтобы не порушить существующую логику, которая уже работает.\",\n\n            ],\n            # Это «динамика»: что нужно сделать прямо сейчас\n            \"current_objectives\": [\n                # Примеры:\n                # \"Исправить фильтрацию по периоду в /users/money\",\n                # \"Усилить OCR: заменить pytesseract на ONNXRuntime PP-OCRv3\"\n            ],\n        },\n        \"structure_text\": structure_text,\n        \"files\": files_out,\n    }\n\n    out_path = Path(args.out)\n    out_path.write_text(json.dumps(payload, ensure_ascii=False, indent=2), encoding=\"utf-8\")\n\n    print(f\"[OK] Saved JSON → {out_path} ({len(files_out)} files)\")\n    if structure_text and not args.no_structure:\n        print(f\"[OK] Saved structure → structure.txt\")\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "path": "pyproject.toml",
      "language": "toml",
      "size_bytes": 794,
      "sha256": "b2adc49361283c4f7d963a43b4922f9cd9ff10d3092e11a98910e7823837b267",
      "content": "[tool.poetry]\npackage-mode = false\n\n[tool.poetry.dependencies]\npython = \"^3.12\"\nfastapi = \"^0.121.0\"\nuvicorn = {extras = [\"standard\"], version = \"^0.38.0\"}\npydantic = {extras = [\"email\"], version = \"^2.12.4\"}\npydantic-settings = \"^2.11.0\"\nsqlalchemy = {extras = [\"asyncio\"], version = \"^2.0.44\"}\nasyncpg = \"^0.30.0\"\nalembic = \"^1.17.1\"\norjson = \"^3.11.4\"\njinja2 = \"^3.1.6\"\npasslib = {extras = [\"bcrypt\"], version = \"^1.7.4\"}\npython-jose = {extras = [\"cryptography\"], version = \"^3.5.0\"}\nitsdangerous = \"^2.2.0\"\npython-multipart = \"^0.0.20\"\nbcrypt = \"4.0.1\"\npillow = \"^12.0.0\"\nlxml = \"^6.0.2\"\nopenpyxl = \"^3.1.5\"\nqdrant-client = \"^1.16.2\"\nsentence-transformers = \"^5.2.0\"\ntransformers = \"^4.57.3\"\naccelerate = \"^1.12.0\"\neinops = \"^0.8.1\"\n\n[tool.poetry.group.dev.dependencies]\nblack = \"^25.9.0\"\n\n"
    },
    {
      "path": "src/__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "src/admin.py",
      "language": "python",
      "size_bytes": 3556,
      "sha256": "95cf8ff21c87df5cce232a05dc5faf419c9c1856dd730e6d3de7b30c13d51c08",
      "content": "# /src/admin.py\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass, field\nfrom typing import Any, Dict, List, Optional, Type\n\nfrom sqlalchemy.orm import DeclarativeMeta\n\nfrom src.core.models.user import User\nfrom src.core.models.profile import Profile\nfrom src.core.models.permission import Permission\n\n\n@dataclass\nclass ModelAdmin:\n    \"\"\"\n    Описание модели для админки.\n    \"\"\"\n    model: Type[DeclarativeMeta]\n    slug: str                                     # url-часть, например \"users\"\n    list_display: List[str] = field(default_factory=list)   # колонки в списке\n    form_fields: List[str] = field(default_factory=list)    # редактируемые поля\n    readonly_fields: List[str] = field(default_factory=list)\n    field_labels: Dict[str, str] = field(default_factory=dict)\n    search_fields: List[str] = field(default_factory=list)  # поля для поиска\n    can_create: bool = False\n    can_delete: bool = False\n\n\nclass AdminSite:\n    def __init__(self) -> None:\n        self._registry: Dict[str, ModelAdmin] = {}\n\n    def register(self, model: Type[DeclarativeMeta], /, **kwargs: Any) -> None:\n        slug = kwargs.get(\"slug\") or getattr(model, \"__tablename__\", model.__name__.lower())\n        if slug in self._registry:\n            raise RuntimeError(f\"Slug '{slug}' already registered\")\n        ma = ModelAdmin(model=model, slug=slug, **{k: v for k, v in kwargs.items() if k != \"slug\"})\n        self._registry[slug] = ma\n\n    def get(self, slug: str) -> Optional[ModelAdmin]:\n        return self._registry.get(slug)\n\n    def all(self) -> List[ModelAdmin]:\n        # упорядочим по slug для стабильности\n        return [self._registry[k] for k in sorted(self._registry.keys())]\n\n\nadmin_site = AdminSite()\n\n# --- Регистрация моделей ---\n\nadmin_site.register(\n    User,\n    slug=\"users\",\n    list_display=[\"id\", \"email\", \"username\", \"is_active\"],\n    form_fields=[\"email\", \"username\", \"is_active\", \"activation_key\"],\n    readonly_fields=[\"id\"],\n    field_labels={\"email\": \"E-mail\", \"username\": \"Логин\", \"is_active\": \"Активен\"},\n    search_fields=[\"email\", \"username\"],\n    can_create=False,\n    can_delete=False,\n)\n\nadmin_site.register(\n    Profile,\n    slug=\"profiles\",\n    list_display=[\"id\", \"user_id\", \"nickname\", \"email\", \"verification\"],\n    form_fields=[\"nickname\", \"avatar\", \"first_name\", \"second_name\", \"phone\", \"email\", \"tg_id\", \"tg_nickname\", \"verification\", \"session\"],\n    readonly_fields=[\"id\", \"user_id\", \"avatar\"],  # avatar меняем из профиля пользователя, здесь readonly\n    field_labels={\"verification\": \"Подтвержден\"},\n    search_fields=[\"nickname\", \"email\", \"tg_nickname\", \"phone\"],\n    can_create=False,\n    can_delete=False,\n)\n\nadmin_site.register(\n    Permission,\n    slug=\"permissions\",\n    list_display=[\"id\", \"profile_id\", \"is_superadmin\", \"is_admin\", \"is_staff\", \"is_updater\", \"is_reader\", \"is_user\"],\n    form_fields=[\"is_superadmin\", \"is_admin\", \"is_staff\", \"is_updater\", \"is_reader\", \"is_user\"],\n    readonly_fields=[\"id\", \"profile_id\"],\n    field_labels={\n        \"is_superadmin\": \"Суперпользователь\",\n        \"is_admin\": \"Администратор\",\n        \"is_staff\": \"Сотрудник\",\n        \"is_updater\": \"Обновляющий\",\n        \"is_reader\": \"Читатель\",\n        \"is_user\": \"Пользователь\",\n    },\n    search_fields=[],\n    can_create=False,\n    can_delete=False,\n)\n"
    },
    {
      "path": "src/app_logging.py",
      "language": "python",
      "size_bytes": 2416,
      "sha256": "2dc0267542df2f0a16ad07239e2daa0de47f28b8ea2a3302866739d937adc79d",
      "content": "\"\"\"\n# path: src/app_logging.py\n\nЕдиный JSON-логгер для проекта.\n\nВАЖНО:\n- Файл НЕ должен называться logging.py, иначе он перекрывает стандартный модуль `logging`\n  и ломает Poetry/uvicorn (они импортируют stdlib logging на старте).\n- Здесь реализован LoggerAdapter, который добавляет в JSON:\n  time, level, func, message (+ optional extra).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport logging\nimport os\nimport sys\nfrom datetime import datetime, timezone\nfrom typing import Any, Dict, Optional\n\n\nclass JsonFormatter(logging.Formatter):\n    \"\"\"Форматтер, превращающий LogRecord в JSON строку.\"\"\"\n\n    def format(self, record: logging.LogRecord) -> str:\n        payload: Dict[str, Any] = {\n            \"time\": datetime.now(timezone.utc).isoformat(timespec=\"seconds\"),\n            \"level\": record.levelname,\n            \"logger\": record.name,\n            \"func\": record.funcName,\n            \"message\": record.getMessage(),\n        }\n\n        extra: Optional[Dict[str, Any]] = getattr(record, \"extra\", None)\n        if isinstance(extra, dict) and extra:\n            payload.update(extra)\n\n        if record.exc_info:\n            payload[\"exc_info\"] = self.formatException(record.exc_info)\n\n        return json.dumps(payload, ensure_ascii=False)\n\n\nclass JsonLoggerAdapter(logging.LoggerAdapter):\n    \"\"\"LoggerAdapter, который безопасно прокидывает user extra в record.extra.\"\"\"\n\n    def process(self, msg: str, kwargs: Dict[str, Any]):\n        user_extra = kwargs.pop(\"extra\", None)\n        kwargs[\"extra\"] = {\"extra\": user_extra} if user_extra else {}\n        return msg, kwargs\n\n\ndef get_logger(name: str) -> JsonLoggerAdapter:\n    \"\"\"Создаёт/возвращает настроенный JSON-логгер (stdout, idempotent).\"\"\"\n    logger = logging.getLogger(name)\n    logger.propagate = False\n\n    if logger.handlers:\n        return JsonLoggerAdapter(logger, {})\n\n    level_str = os.getenv(\"LOG_LEVEL\", \"INFO\").upper()\n    level = getattr(logging, level_str, logging.INFO)\n    logger.setLevel(level)\n\n    handler = logging.StreamHandler(sys.stdout)\n    handler.setLevel(level)\n    handler.setFormatter(JsonFormatter())\n\n    logger.addHandler(handler)\n    return JsonLoggerAdapter(logger, {})\n"
    },
    {
      "path": "src/core/__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "src/core/api/__init__.py",
      "language": "python",
      "size_bytes": 237,
      "sha256": "d06a12fc49cb9678acf2e5f6839e19628b1ceb47dca1050a9e19b813729cd4fd",
      "content": "# src/core/api/__init__.py\nfrom fastapi import APIRouter\n\nfrom .api_v1 import router as router_api_v1\nfrom src.core.config import settings\n\nrouter = APIRouter(\n    prefix=settings.api.prefix\n)\nrouter.include_router(\n    router_api_v1,\n)\n"
    },
    {
      "path": "src/core/api/api_v1/__init__.py",
      "language": "python",
      "size_bytes": 912,
      "sha256": "d9e4f61c2ba738ac0ab94aa7498bac864c2ae04e8b58e761f948f5be6b80bf17",
      "content": "# /src/core/api/api_v1/__init__.py\nfrom fastapi import APIRouter\n\nfrom src.core.config import settings\nfrom .users import router as users_router\nfrom .auth import router as auth_router\nfrom src.fsnb_matcher.api.api_v1 import router as fsnb_router\nfrom src.train.api.api_v1 import router as train_router\n\n\nrouter = APIRouter(prefix=settings.api.v1.prefix)\n\n# /api/<v1>/users/...\nrouter.include_router(\n    users_router,\n    prefix=settings.api.v1.users,\n)\n\n# /api/<v1>/auth/...\nrouter.include_router(\n    auth_router,\n    prefix=settings.api.v1.auth,   # <- префикс берём из конфига\n)\n# если у fsnb_matcher уже есть свой prefix внутри — ок\nrouter.include_router(fsnb_router,  prefix=\"\",       tags=[\"fsnb-match\"])\n\n# train endpoints: /api/v1/review/... /api/v1/feedback/... /api/v1/export/... etc\nrouter.include_router(train_router, prefix=\"/train\", tags=[\"train\"])\n"
    },
    {
      "path": "src/core/api/api_v1/auth.py",
      "language": "python",
      "size_bytes": 1533,
      "sha256": "f12ac8e926d033fe5fca468dadc18baecede5c533a90b8e549318bcb016ee04a",
      "content": "# path: src/core/api/api_v1/auth.py\nfrom __future__ import annotations\n\nfrom typing import Annotated\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.app_logging import get_logger\nfrom src.core.dependencies import get_auth_service\nfrom src.core.models.db_helper import db_helper\nfrom src.core.services.auth_service import AuthService\n\n\nrouter = APIRouter(tags=[\"auth\"])\nlog = get_logger(\"api.auth\")\n\n\n@router.post(\"/token\")\nasync def auth_token(\n    form: Annotated[OAuth2PasswordRequestForm, Depends()],\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    service: Annotated[AuthService, Depends(get_auth_service)],\n):\n    \"\"\"\n    OAuth2 Password:\n    - Принимает form.username (email) и form.password (x-www-form-urlencoded)\n    - Возвращает {\"access_token\": \"...\", \"token_type\": \"bearer\"}\n    \"\"\"\n    try:\n        token = await service.authenticate(\n            session,\n            email=form.username.strip().lower(),\n            password=form.password,\n        )\n        return {\"access_token\": token, \"token_type\": \"bearer\"}\n    except ValueError:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid email or password\",\n        )\n    except Exception as e:\n        log.info({\"event\": \"auth_token_fail\", \"error\": str(e)})\n        raise HTTPException(status_code=500, detail=\"Auth failed\") from e\n"
    },
    {
      "path": "src/core/api/api_v1/users.py",
      "language": "python",
      "size_bytes": 2136,
      "sha256": "461ec218d62fb51b78fab58ef382534de92ae69498979a48eaa887f0a258df23",
      "content": "# path: src/core/api/api_v1/users.py\nfrom __future__ import annotations\n\nfrom typing import Annotated\n\nfrom fastapi import APIRouter, Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.core.dependencies import get_user_repository\nfrom src.core.models.db_helper import db_helper\nfrom src.core.schemas.user import UserCreate, UserRead\nfrom src.core.security import hash_password\nfrom src.crud.user_repository import IUserRepository\n\n\nrouter = APIRouter(tags=[\"Users\"])\n\n\n@router.get(\"\", response_model=list[UserRead])\nasync def get_users(\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    user_repo: Annotated[IUserRepository, Depends(get_user_repository)],\n):\n    \"\"\"\n    Список пользователей.\n\n    Важно:\n    - чтение из БД только через репозиторий;\n    - DI отдаёт интерфейс IUserRepository.\n    \"\"\"\n    users = await user_repo.list_users(session)\n    return list(users)\n\n\n@router.post(\"\", response_model=UserRead)\nasync def create_user(\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    user_repo: Annotated[IUserRepository, Depends(get_user_repository)],\n    user_create: UserCreate,\n):\n    \"\"\"\n    Создать пользователя.\n\n    Важно:\n    - репозиторий принимает hashed_password (хэширование — не DB-операция);\n    - DB-операции только через repo.\n    \"\"\"\n    email = user_create.email.strip().lower()\n    existing = await user_repo.get_by_email(session, email=email)\n    if existing:\n        # В реальном API можно вернуть 400/409, но ты просил “не ломать логику” —\n        # поэтому оставляем такой же смысл ошибки, как в старых функциях.\n        raise ValueError(\"email_already_exists\")\n\n    user = await user_repo.create_user_with_profile_and_permission(\n        session,\n        email=email,\n        hashed_password=hash_password(user_create.password),\n    )\n    await session.flush()\n    return user\n"
    },
    {
      "path": "src/core/config.py",
      "language": "python",
      "size_bytes": 2843,
      "sha256": "8af6b143195eae5bfe1171a209d52ce0777e87a5de503a161ab275dae0a0d845",
      "content": "# src/core/config.py\nfrom pydantic import BaseModel\nfrom pydantic import PostgresDsn\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\nfrom pathlib import Path\nfrom typing import Literal\n\n\nclass RunConfig(BaseModel):\n    host: str = \"0.0.0.0\"\n    port: int = 8015\n\n\nclass ApiV1Prefix(BaseModel):\n    prefix: str = \"/v1\"\n    users: str = \"/users\"\n    auth: str = \"/auth\"\n\n\nclass ApiPrefix(BaseModel):\n    prefix: str = \"/api\"\n    v1: ApiV1Prefix = ApiV1Prefix()\n\n\nclass DatabaseConfig(BaseModel):\n    url: PostgresDsn\n    echo: bool = False\n    echo_pool: bool = False\n    pool_size: int = 50\n    max_overflow: int = 10\n\n    naming_convention: dict[str, str] = {\n        \"ix\": \"ix_%(column_0_label)s\",\n        \"uq\": \"uq_%(table_name)s_%(column_0_N_name)s\",\n        \"ck\": \"ck_%(table_name)s_%(constraint_name)s\",\n        \"fk\": \"fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s\",\n        \"pk\": \"pk_%(table_name)s\",\n    }\n\nclass AuthConfig(BaseModel):\n    secret_key: str = \"CHANGE_ME\"                # общий секрет (JWT/CSRF/сессии)\n    algorithm: str = \"HS256\"\n    access_token_minutes: int = 60\n    email_verify_secret: str = \"CHANGE_ME_EMAIL\" # отдельный секрет для ссылок\n    verify_token_ttl_hours: int = 48\n\n\nclass EmailConfig(BaseModel):\n    smtp_host: str = \"localhost\"\n    smtp_port: int = 25\n    smtp_user: str = \"\"\n    smtp_password: str = \"\"\n    use_tls: bool = False\n    use_ssl: bool = False\n    from_email: str = \"noreply@example.com\"\n\n\nclass SiteConfig(BaseModel):\n    # если нужно строить абсолютные ссылки вне Request (опционально)\n    base_url: str = \"http://127.0.0.1:8000\"\n\n\nclass QdrantConfig(BaseModel):\n    host: str = \"localhost\"          # в docker-сети будет \"qdrant\"\n    port: int = 6333\n    timeout_s: int = 300\n\nclass FsnbConfig(BaseModel):\n    fsnb_dir: str = \"FSNB-2022_28_08_25\"\n    weights_dir: str = \"weights\"\n    model_giga_dir: str = \"weights/Giga-Embeddings-instruct\"\n    similarity_threshold: float = 0.70\n    embed_batch_size: int = 128\n\n    # Тонкие настройки/инференс\n    gpu_slots: int = 1\n    giga_query_bs: int = 2\n    giga_index_bs: int = 8\n    hf_embed_device: Literal[\"auto\", \"cuda\", \"cpu\"] = \"auto\"\n    hf_embed_fp16: bool = True\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_file=(\".env.example\", \".env\"),\n        case_sensitive=False,\n        env_nested_delimiter=\"__\",\n        env_prefix=\"APP_CONFIG__\",\n    )\n    run: RunConfig = RunConfig()\n    api: ApiPrefix = ApiPrefix()\n    db: DatabaseConfig\n\n    auth: AuthConfig = AuthConfig()\n    email: EmailConfig = EmailConfig()\n    site: SiteConfig = SiteConfig()\n\n    qdrant: QdrantConfig = QdrantConfig()\n    fsnb: FsnbConfig = FsnbConfig()\n\nsettings = Settings()\n"
    },
    {
      "path": "src/core/dependencies.py",
      "language": "python",
      "size_bytes": 1846,
      "sha256": "a3808ee0852a712f3102639e4101efb8e7f6ff9caf8f54bb851bea72d0520d00",
      "content": "# path: src/core/dependencies.py\nfrom __future__ import annotations\n\nfrom functools import lru_cache\nfrom typing import Any, Dict\n\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError\n\nfrom src.app_logging import get_logger\nfrom src.core.security import decode_token\nfrom src.core.services.auth_service import AuthService\nfrom src.crud.permission_repository import IPermissionRepository, PermissionRepository\nfrom src.crud.profile_repository import IProfileRepository, ProfileRepository\nfrom src.crud.user_repository import IUserRepository, UserRepository\n\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/api/v1/auth/token\")\nlog = get_logger(\"deps\")\n\n\ndef get_current_subject(token: str = Depends(oauth2_scheme)) -> Dict[str, Any]:\n    try:\n        payload = decode_token(token)\n        return payload\n    except JWTError as e:\n        log.info({\"event\": \"jwt_error\", \"error\": str(e)})\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid or expired token\",\n        ) from e\n\n\n@lru_cache(maxsize=1)\ndef _user_repo_singleton() -> UserRepository:\n    return UserRepository()\n\n\ndef get_user_repository() -> IUserRepository:\n    return _user_repo_singleton()\n\n\n@lru_cache(maxsize=1)\ndef _profile_repo_singleton() -> ProfileRepository:\n    return ProfileRepository()\n\n\ndef get_profile_repository() -> IProfileRepository:\n    return _profile_repo_singleton()\n\n\n@lru_cache(maxsize=1)\ndef _permission_repo_singleton() -> PermissionRepository:\n    return PermissionRepository()\n\n\ndef get_permission_repository() -> IPermissionRepository:\n    return _permission_repo_singleton()\n\n\ndef get_auth_service(\n    user_repo: IUserRepository = Depends(get_user_repository),\n) -> AuthService:\n    return AuthService(repo=user_repo)\n"
    },
    {
      "path": "src/core/email_tokens.py",
      "language": "python",
      "size_bytes": 612,
      "sha256": "b9b0b91724b5295996989bb458dae2ae2c77bb715e94466f912be98f35b589b7",
      "content": "# /src/core/email_tokens.py\nfrom __future__ import annotations\n\nfrom itsdangerous import URLSafeTimedSerializer, BadSignature, SignatureExpired\n\nfrom .config import settings\n\n\ndef _serializer() -> URLSafeTimedSerializer:\n    return URLSafeTimedSerializer(\n        secret_key=settings.auth.email_verify_secret,\n        salt=\"email-verify\",\n    )\n\n\ndef make_email_token(user_id: int) -> str:\n    return _serializer().dumps({\"uid\": user_id})\n\n\ndef read_email_token(token: str) -> dict:\n    max_age = settings.auth.verify_token_ttl_hours * 3600\n    data = _serializer().loads(token, max_age=max_age)\n    return data\n"
    },
    {
      "path": "src/core/mailing/__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "src/core/mailing/email.py",
      "language": "python",
      "size_bytes": 2011,
      "sha256": "500f201441fd959e8aef41fa76e0c0872bda9cfa50fc4d2873050c9f90389179",
      "content": "# /src/core/mailing/email.py\nfrom __future__ import annotations\n\nimport smtplib\nfrom email.mime.text import MIMEText\n\nfrom src.core.config import settings\nfrom src.app_logging import get_logger\n\nlog = get_logger(\"mail\")\n\n\ndef send_verification_email_sync(to_email: str, verify_link: str) -> bool:\n    \"\"\"\n    Простая синхронная отправка (SMTP). Для продакшена можно вынести в Celery.\n    \"\"\"\n    subject = \"Подтверждение регистрации\"\n    body = (\n        \"Для подтверждения e-mail пройдите по ссылке:\\n\\n\"\n        f\"{verify_link}\\n\\n\"\n        \"Если это были не вы — игнорируйте письмо.\"\n    )\n    msg = MIMEText(body, _charset=\"utf-8\")\n    msg[\"Subject\"] = subject\n    msg[\"From\"] = settings.email.from_email\n    msg[\"To\"] = to_email\n\n    try:\n        if settings.email.use_ssl:\n            with smtplib.SMTP_SSL(\n                settings.email.smtp_host,\n                settings.email.smtp_port,\n                timeout=5\n            ) as s:\n                if settings.email.smtp_user:\n                    s.login(settings.email.smtp_user, settings.email.smtp_password)\n                s.send_message(msg)\n        else:\n            with smtplib.SMTP(\n                settings.email.smtp_host,\n                settings.email.smtp_port,\n                timeout=5\n            ) as s:\n                # безопаснее явно послать EHLO перед STARTTLS\n                s.ehlo()\n                if settings.email.use_tls:\n                    s.starttls()\n                    s.ehlo()\n                if settings.email.smtp_user:\n                    s.login(settings.email.smtp_user, settings.email.smtp_password)\n                s.send_message(msg)\n\n        log.info({\"event\": \"email_sent\", \"to\": to_email})\n        return True\n    except Exception as e:\n        log.info({\"event\": \"email_fail\", \"to\": to_email, \"error\": str(e)})\n        return False\n\n"
    },
    {
      "path": "src/core/models/__init__.py",
      "language": "python",
      "size_bytes": 831,
      "sha256": "83f20a8bc08dcb023a4f596ab138e3213aa0171e9539f08eb3c2d72d5753709a",
      "content": "# src/core/models/__init__.py\n\n__all__ = (\n    \"db_helper\",\n    \"Base\",\n    \"User\",\n    \"Profile\",\n    \"Permission\",\n    # не обязательно, но можно:\n    \"Item\",\n    \"FeedbackSession\",\n    \"FeedbackRow\",\n    \"FeedbackCandidate\",\n    \"FeedbackLabelModel\",\n    \"TrainingRun\",\n    \"TrainingRunRow\",\n)\n\nfrom .db_helper import db_helper\nfrom .base import Base\nfrom .user import User\nfrom .profile import Profile\nfrom .permission import Permission\n\n# ВАЖНО: импортируем модели других модулей, чтобы Alembic autogenerate видел их в Base.metadata\nfrom src.fsnb_matcher.models import Item  # noqa: F401\n\nfrom src.train.models import (  # noqa: F401\n    FeedbackSession,\n    FeedbackRow,\n    FeedbackCandidate,\n    FeedbackLabelModel,\n    TrainingRun,\n    TrainingRunRow,\n)\n"
    },
    {
      "path": "src/core/models/base.py",
      "language": "python",
      "size_bytes": 553,
      "sha256": "36265b2d41b9bbb9e7536231b74e117a4eac95695ad842d063ec1470d1e47b4d",
      "content": "# src/core/models/base.py\nfrom sqlalchemy import MetaData\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, declared_attr, mapped_column\n\nfrom src.core.config import settings\nfrom src.core.utils import camel_case_to_snake_case\n\n\nclass Base(DeclarativeBase):\n    __abstract__ = True\n\n    metadata = MetaData(\n        naming_convention=settings.db.naming_convention,\n    )\n\n    @declared_attr.directive\n    def __tablename__(cls) -> str:\n        return f\"{camel_case_to_snake_case(cls.__name__)}s\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n"
    },
    {
      "path": "src/core/models/db_helper.py",
      "language": "python",
      "size_bytes": 1298,
      "sha256": "3ad7bd08c40c4e539ba3fd82d06d35cacbb17360a416abbe2f765bbc6eb20fc9",
      "content": "# src/core/models/db_helper.py\nfrom typing import AsyncGenerator\n\nfrom sqlalchemy.ext.asyncio import (\n    create_async_engine,\n    AsyncEngine,\n    async_sessionmaker,\n    AsyncSession,\n)\nfrom src.core.config import settings\n\nclass DatabaseHelper:\n    def __init__(\n        self,\n        url: str,\n        echo: bool = False,\n        echo_pool: bool = False,\n        pool_size: int = 5,\n        max_overflow: int = 10,\n    ):\n        self.engine: AsyncEngine = create_async_engine(\n            url=url,\n            echo=echo,\n            echo_pool=echo_pool,\n            pool_size=pool_size,\n            max_overflow=max_overflow,\n        )\n\n        self.session_factory: async_sessionmaker[AsyncSession] = async_sessionmaker(\n            bind=self.engine,\n            autoflush=False,\n            autocommit=False,\n            expire_on_commit=False,\n        )\n\n    async def dispose(self) -> None:\n        await self.engine.dispose()\n\n    async def session_getter(self) -> AsyncGenerator[AsyncSession, None]:\n        async with self.session_factory() as session:\n            yield session\n\n\ndb_helper = DatabaseHelper(\n    url=str(settings.db.url),\n    echo=settings.db.echo,\n    echo_pool=settings.db.echo_pool,\n    pool_size=settings.db.pool_size,\n    max_overflow=settings.db.max_overflow,\n)\n"
    },
    {
      "path": "src/core/models/permission.py",
      "language": "python",
      "size_bytes": 1914,
      "sha256": "653c9e83ed3c0a778328eb65be3866cd69294d7f83fd797ba972b89ab444aa0b",
      "content": "# /src/core/models/permission.py\nfrom __future__ import annotations\n\nfrom sqlalchemy import Boolean, ForeignKey\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nfrom .base import Base\n# Для тайпхинтов не импортируем Profile во время рантайма, чтобы не ловить цикл.\n# from typing import TYPE_CHECKING\n# if TYPE_CHECKING:\n#     from .profile import Profile\n\n\nclass Permission(Base):\n    \"\"\"\n    Набор флагов доступа для профиля.\n    Связь: 1:1 с Profile (через unique profile_id).\n    \"\"\"\n    __tablename__ = \"permissions\"\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)\n    profile_id: Mapped[int] = mapped_column(\n        ForeignKey(\"profiles.id\", ondelete=\"CASCADE\"),\n        nullable=False,\n        unique=True,   # 1:1 с профилем\n        index=True,\n    )\n\n    is_superadmin: Mapped[bool] = mapped_column(Boolean, default=False)\n    is_admin: Mapped[bool] = mapped_column(Boolean, default=False)\n    is_staff: Mapped[bool] = mapped_column(Boolean, default=False)\n    is_updater: Mapped[bool] = mapped_column(Boolean, default=False)\n    is_reader: Mapped[bool] = mapped_column(Boolean, default=False)\n    is_user: Mapped[bool] = mapped_column(Boolean, default=False)\n\n    # Имя поля в Profile — 'permission' (singular)\n    profile: Mapped[\"Profile\"] = relationship(\"Profile\", back_populates=\"permission\")\n\n    def verificate(self) -> None:\n        \"\"\"\n        Если профиль не верифицирован — сбрасываем все флаги прав.\n        \"\"\"\n        if not self.profile or not self.profile.verification:\n            self.is_superadmin = False\n            self.is_admin = False\n            self.is_staff = False\n            self.is_updater = False\n            self.is_reader = False\n            self.is_user = False\n"
    },
    {
      "path": "src/core/models/profile.py",
      "language": "python",
      "size_bytes": 2043,
      "sha256": "dfc2772b247615bed797213b5a563125b8975c85c735c77360585891806f1eb8",
      "content": "# /src/core/models/profile.py\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom sqlalchemy import BigInteger, Boolean, ForeignKey, String, UniqueConstraint, Integer\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nfrom .base import Base\n\n\nclass Profile(Base):\n    \"\"\"\n    Профиль пользователя (1:1 с users по user_id).\n    \"\"\"\n    __tablename__ = \"profiles\"\n    __table_args__ = (UniqueConstraint(\"user_id\", name=\"uq_profiles_user_id\"),)\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)\n\n    nickname: Mapped[Optional[str]] = mapped_column(String(64), default=None)\n    avatar: Mapped[Optional[str]] = mapped_column(String(255), default=None)\n    first_name: Mapped[Optional[str]] = mapped_column(String(48), default=None)\n    second_name: Mapped[Optional[str]] = mapped_column(String(48), default=None)\n    phone: Mapped[Optional[str]] = mapped_column(String(32), default=None)\n    email: Mapped[Optional[str]] = mapped_column(String(255), default=None)\n    tg_id: Mapped[Optional[int]] = mapped_column(BigInteger, default=None)\n    tg_nickname: Mapped[Optional[str]] = mapped_column(String(64), default=None)\n    verification: Mapped[bool] = mapped_column(Boolean, default=False)\n    session: Mapped[Optional[str]] = mapped_column(String(255), default=None)\n\n    user_id: Mapped[int] = mapped_column(\n        Integer,\n        ForeignKey(\"users.id\", ondelete=\"CASCADE\"),  # удалить профиль при удалении юзера\n        nullable=False,\n        unique=True,\n        index=True,\n    )\n\n    # 1:1 с User\n    user: Mapped[\"User\"] = relationship(\"User\", back_populates=\"profile\")\n\n    # 1:1 с Permission (singular). delete-orphan: удаляем права вместе с профилем.\n    permission: Mapped[Optional[\"Permission\"]] = relationship(\n        \"Permission\",\n        back_populates=\"profile\",\n        uselist=False,\n        cascade=\"all, delete-orphan\",\n        passive_deletes=True,\n        single_parent=True,\n    )\n"
    },
    {
      "path": "src/core/models/user.py",
      "language": "python",
      "size_bytes": 1634,
      "sha256": "e882a2c0f5d34beec7852efc06853c21df25f15fec22ba401b253672b76ff27d",
      "content": "# src/core/models/user.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom sqlalchemy import Boolean, DateTime, Integer, String, UniqueConstraint\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nfrom .base import Base\n\n\nclass User(Base):\n    \"\"\"\n    Базовая модель пользователя.\n    \"\"\"\n    __tablename__ = \"users\"\n\n    email: Mapped[str] = mapped_column(String(255), nullable=False, unique=True)\n    # username может быть NULL (мы регистрируем по email)\n    username: Mapped[Optional[str]] = mapped_column(String(64), nullable=True, unique=True)\n\n    hashed_password: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)\n    is_active: Mapped[bool] = mapped_column(Boolean, nullable=False, default=True, server_default=\"true\")\n\n    activation_key: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)\n    activation_sent_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)\n\n    foo: Mapped[int] = mapped_column(Integer, nullable=False, default=0, server_default=\"0\")\n    bar: Mapped[int] = mapped_column(Integer, nullable=False, default=0, server_default=\"0\")\n\n    # 1:1 с Profile\n    profile: Mapped[\"Profile\"] = relationship(\n        \"Profile\",\n        back_populates=\"user\",\n        uselist=False,\n        cascade=\"all, delete-orphan\",\n        passive_deletes=True,\n        single_parent=True,\n    )\n\n    __table_args__ = (\n        UniqueConstraint(\"email\", name=\"uq_users_email\"),\n        UniqueConstraint(\"username\", name=\"uq_users_username\"),\n    )\n"
    },
    {
      "path": "src/core/schemas/__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "src/core/schemas/permission.py",
      "language": "python",
      "size_bytes": 353,
      "sha256": "2b79fc2eb308477290e94f6c288f90ac5eb847eb92c85e639e5f0b908e1b39c5",
      "content": "# /src/core/schemas/permission.py\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass PermissionRead(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    id: int\n    profile_id: int\n    is_superadmin: bool\n    is_admin: bool\n    is_staff: bool\n    is_updater: bool\n    is_reader: bool\n    is_user: bool\n"
    },
    {
      "path": "src/core/schemas/profile.py",
      "language": "python",
      "size_bytes": 690,
      "sha256": "e15dba6b03a7b9f1801945bc003173b2e3e4f137c534e60cab0687a7075425e9",
      "content": "# /src/core/schemas/profile.py\nfrom __future__ import annotations\n\nfrom typing import Optional, List\n\nfrom pydantic import BaseModel, ConfigDict, EmailStr\n\nfrom .permission import PermissionRead\n\n\nclass ProfileRead(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    id: int\n    user_id: int\n    email: Optional[EmailStr] = None\n    nickname: Optional[str] = None\n    avatar: Optional[str] = None\n    first_name: Optional[str] = None\n    second_name: Optional[str] = None\n    phone: Optional[str] = None\n    tg_id: Optional[int] = None\n    tg_nickname: Optional[str] = None\n    verification: bool\n    session: Optional[str] = None\n    permissions: List[PermissionRead] = []\n"
    },
    {
      "path": "src/core/schemas/user.py",
      "language": "python",
      "size_bytes": 393,
      "sha256": "1e9356c4a909f30fad4fca032d922dad25df4998426a48d8f71bbd81416df726",
      "content": "# /src/core/schemas/user.py\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, ConfigDict, EmailStr\n\n\nclass UserBase(BaseModel):\n    username: str | None = None\n    foo: int = 0\n    bar: int = 0\n\n\nclass UserCreate(BaseModel):\n    email: EmailStr\n    password: str\n\n\nclass UserRead(UserBase):\n    model_config = ConfigDict(from_attributes=True)\n    id: int\n    email: EmailStr\n"
    },
    {
      "path": "src/core/security.py",
      "language": "python",
      "size_bytes": 1619,
      "sha256": "0ca6b03f7b90d7ba4fbdd40798d05e14cc48e7b3a09d51806564dbb0468ee4c8",
      "content": "# /src/core/security.py\nfrom __future__ import annotations\n\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Any, Dict, Optional\n\nfrom jose import jwt, JWTError\nfrom passlib.hash import bcrypt_sha256\n\nfrom src.core.config import settings\n\n\ndef hash_password(password: str) -> str:\n    \"\"\"Хэш пароля через bcrypt_sha256 (снимает лимит 72 байта у bcrypt).\"\"\"\n    return bcrypt_sha256.hash(password)\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    \"\"\"Проверка пароля.\"\"\"\n    if not hashed_password:\n        return False\n    return bcrypt_sha256.verify(plain_password, hashed_password)\n\n\ndef create_access_token(\n    *,\n    subject: int | str,\n    expires_minutes: Optional[int] = None,\n    extra: Optional[Dict[str, Any]] = None,\n) -> str:\n    \"\"\"Создаёт JWT (Bearer).\"\"\"\n    to_encode: Dict[str, Any] = {\"sub\": str(subject)}\n    if extra:\n        to_encode.update(extra)\n    expire = datetime.now(timezone.utc) + timedelta(\n        minutes=expires_minutes or settings.auth.access_token_minutes\n    )\n    to_encode[\"exp\"] = int(expire.timestamp())\n    return jwt.encode(to_encode, settings.auth.secret_key, algorithm=settings.auth.algorithm)\n\n\ndef decode_token(token: str) -> Dict[str, Any]:\n    \"\"\"\n    Декодирует и валидирует JWT. Бросает jose.JWTError при неверной подписи/просрочке.\n    \"\"\"\n    payload = jwt.decode(token, settings.auth.secret_key, algorithms=[settings.auth.algorithm])\n    # payload уже проверен по exp\n    return dict(payload)\n"
    },
    {
      "path": "src/core/services/__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "src/core/services/auth_service.py",
      "language": "python",
      "size_bytes": 5255,
      "sha256": "74a768a6ce499e23ae6e1d5d11541732f6f0f27dc90a06d8584aa16979491442",
      "content": "# path: src/core/services/auth_service.py\nfrom __future__ import annotations\n\nfrom datetime import datetime, timezone\nfrom typing import Optional\n\nfrom src.app_logging import get_logger\nfrom src.core.config import settings\nfrom src.core.security import (\n    create_access_token,\n    hash_password,\n    verify_password,\n)\nfrom src.crud.user_repository import IUserRepository, UserRepository\n\ntry:\n    from itsdangerous import URLSafeTimedSerializer, BadSignature, SignatureExpired\nexcept Exception:  # pragma: no cover\n    URLSafeTimedSerializer = None  # type: ignore\n\n\nlog = get_logger(\"service.auth\")\n\n\nclass AuthService:\n    \"\"\"\n    Сервис авторизации/регистрации.\n\n    Важно:\n    - Repo приходит через DI (или создаётся по умолчанию),\n      чтобы сервис не зависел от конкретной реализации.\n    - DB-операции выполняются через репозиторий.\n    \"\"\"\n\n    def __init__(self, repo: Optional[IUserRepository] = None) -> None:\n        self.repo: IUserRepository = repo or UserRepository()\n\n    # --- verify-токен для письма ---\n    def _get_serializer(self) -> URLSafeTimedSerializer:\n        if URLSafeTimedSerializer is None:\n            raise RuntimeError(\"itsdangerous is not installed\")\n        return URLSafeTimedSerializer(settings.auth.email_verify_secret)\n\n    def make_verify_token(self, *, uid: int, email: str) -> str:\n        s = self._get_serializer()\n        return s.dumps({\"uid\": uid, \"email\": email})\n\n    def read_verify_token(self, token: str) -> dict:\n        s = self._get_serializer()\n        max_age = settings.auth.verify_token_ttl_hours * 3600\n        try:\n            data = s.loads(token, max_age=max_age)\n            return dict(data)\n        except SignatureExpired as e:\n            raise ValueError(\"verify_link_expired\") from e\n        except BadSignature as e:\n            raise ValueError(\"verify_link_bad\") from e\n\n    # --- Регистрация ---\n    async def register_user(self, session, *, email: str, password: str) -> tuple[int, str]:\n        email_norm = email.strip().lower()\n\n        existing = await self.repo.get_by_email(session, email=email_norm)\n        if existing:\n            raise ValueError(\"email_already_exists\")\n\n        user = await self.repo.create_user_with_profile_and_permission(\n            session,\n            email=email_norm,\n            hashed_password=hash_password(password),\n        )\n\n        token = self.make_verify_token(uid=int(user.id), email=email_norm)\n\n        # ✅ не трогаем ORM-поля напрямую — только через repo\n        await self.repo.set_activation_token(\n            session,\n            user_id=int(user.id),\n            activation_key=token,\n            activation_sent_at=datetime.now(tz=timezone.utc),\n        )\n        await session.flush()\n\n        log.info({\"event\": \"register_success\", \"email\": email_norm, \"user_id\": int(user.id)})\n        return int(user.id), token\n\n    # --- Подтверждение e-mail ---\n    async def verify_email(self, session, token: str) -> int:\n        data = self.read_verify_token(token)\n        email = str(data.get(\"email\", \"\")).strip().lower()\n        uid = int(data.get(\"uid\", 0))\n\n        user = await self.repo.get_by_email(session, email=email)\n        if not user or int(user.id) != uid:\n            raise ValueError(\"verify_link_bad_user\")\n\n        # ✅ одним проходом (update Profile + update User)\n        await self.repo.mark_email_verified_and_clear_token(session, user_id=int(user.id))\n        await session.flush()\n\n        log.info({\"event\": \"verify_ok\", \"email\": email, \"uid\": uid})\n        return int(user.id)\n\n    # --- Аутентификация ---\n    async def authenticate(self, session, *, email: str, password: str) -> str:\n        email_norm = email.strip().lower()\n\n        user = await self.repo.get_by_email(session, email=email_norm)\n        if not user:\n            log.info({\"event\": \"auth_fail\", \"reason\": \"user_not_found\", \"email\": email_norm})\n            raise ValueError(\"bad_credentials\")\n\n        if not verify_password(password, user.hashed_password):\n            log.info({\"event\": \"auth_fail\", \"reason\": \"wrong_password\", \"email\": email_norm})\n            raise ValueError(\"bad_credentials\")\n\n        profile = await self.repo.get_profile_by_user_id(session, user_id=int(user.id))\n        email_verified = bool(profile and profile.verification)\n\n        if not email_verified:\n            log.info({\"event\": \"auth_warn_unverified\", \"email\": email_norm})\n\n        token = create_access_token(\n            subject=email_norm,\n            extra={\"uid\": int(user.id), \"email_verified\": email_verified},\n        )\n        log.info({\"event\": \"auth_ok\", \"email\": email_norm, \"uid\": int(user.id), \"email_verified\": email_verified})\n        return token\n\n    # --- для HTML-потока (авто-логин после регистрации) ---\n    def make_access_token(self, *, email: str, uid: int, email_verified: bool) -> str:\n        return create_access_token(\n            subject=email,\n            extra={\"uid\": uid, \"email_verified\": email_verified},\n        )\n"
    },
    {
      "path": "src/core/utils/__init__.py",
      "language": "python",
      "size_bytes": 171,
      "sha256": "ccd5bd538df37c287d57520f91402bfcd505fe6cfdac2624bbe0a4da18c54403",
      "content": "# path: src/core/utils/__init__.py\nfrom __future__ import annotations\n\nfrom .case_converter import camel_case_to_snake_case\n\n__all__ = (\n    \"camel_case_to_snake_case\",\n)\n"
    },
    {
      "path": "src/core/utils/case_converter.py",
      "language": "python",
      "size_bytes": 956,
      "sha256": "e8afbbb46723ee1fbc0a96c581919afc05422fdc5b32f1b73deee5cccddf9cbd",
      "content": "# /src/core/services/case_service.py\n\"\"\"\nTaken from\nhttps://github.com/mahenzon/ri-sdk-python-wrapper/blob/master/ri_sdk_codegen/utils/case_converter.py\n\"\"\"\n\n\ndef camel_case_to_snake_case(input_str: str) -> str:\n    \"\"\"\n    >>> camel_case_to_snake_case(\"SomeSDK\")\n    'some_sdk'\n    >>> camel_case_to_snake_case(\"RServoDrive\")\n    'r_servo_drive'\n    >>> camel_case_to_snake_case(\"SDKDemo\")\n    'sdk_demo'\n    \"\"\"\n    chars = []\n    for c_idx, char in enumerate(input_str):\n        if c_idx and char.isupper():\n            nxt_idx = c_idx + 1\n            # idea of the flag is to separate abbreviations\n            # as new words, show them in lower case\n            flag = nxt_idx >= len(input_str) or input_str[nxt_idx].isupper()\n            prev_char = input_str[c_idx - 1]\n            if prev_char.isupper() and flag:\n                pass\n            else:\n                chars.append(\"_\")\n        chars.append(char.lower())\n    return \"\".join(chars)\n"
    },
    {
      "path": "src/core/views/__init__.py",
      "language": "python",
      "size_bytes": 479,
      "sha256": "057eaa95d979db71bbacd982fafaf2b1c406cce987808c2da3a57d13ddc5f119",
      "content": "# /src/core/views/__init__.py\nfrom fastapi import APIRouter\nfrom .web import router as web_router\nfrom .auth import router as auth_router\nfrom .admin import router as admin_router\n\nfrom src.train.views.review import router as train_review_router\n\n# Единая точка подключения HTML-вьюх\nrouter = APIRouter()\nrouter.include_router(web_router)\nrouter.include_router(auth_router)\nrouter.include_router(admin_router)\nrouter.include_router(train_review_router)\n"
    },
    {
      "path": "src/core/views/admin.py",
      "language": "python",
      "size_bytes": 14509,
      "sha256": "4dda08e6b028a478bb8bea3fc85823b13ff241076012cc228c6e1f507d057eaa",
      "content": "# path: src/core/views/admin.py\nfrom __future__ import annotations\n\nimport secrets\nfrom pathlib import Path\nfrom typing import Annotated, Optional, Any, Dict\n\nfrom fastapi import APIRouter, Request, Depends, Form, status, HTTPException\nfrom fastapi.responses import RedirectResponse\nfrom fastapi.templating import Jinja2Templates\nfrom sqlalchemy import select, update, or_\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.inspection import inspect as sa_inspect\nfrom sqlalchemy.sql.schema import Column\n\nfrom src.app_logging import get_logger\nfrom src.core.dependencies import (\n    get_permission_repository,\n    get_profile_repository,\n    get_user_repository,\n)\nfrom src.core.models.db_helper import db_helper\nfrom src.core.models.user import User\nfrom src.core.models.profile import Profile\nfrom src.core.models.permission import Permission\nfrom src.core.security import verify_password\nfrom src.crud.permission_repository import IPermissionRepository\nfrom src.crud.profile_repository import IProfileRepository\nfrom src.crud.user_repository import IUserRepository\nfrom src.admin import admin_site\n\n\nrouter = APIRouter()\nlog = get_logger(\"views.admin\")\n\nTEMPLATES_DIR = Path(__file__).resolve().parents[2] / \"templates\"\ntemplates = Jinja2Templates(directory=str(TEMPLATES_DIR))\ntemplates.env.globals.update(attr=lambda o, n: getattr(o, n, None))\n\n\ndef _ensure_csrf(request: Request) -> str:\n    token = request.session.get(\"admin_csrf\")\n    if not token:\n        token = secrets.token_urlsafe(16)\n        request.session[\"admin_csrf\"] = token\n    return token\n\n\ndef _admin_identity(request: Request) -> Optional[int]:\n    return request.session.get(\"admin_user_id\")\n\n\nasync def _require_admin(\n    request: Request,\n    session: AsyncSession,\n    user_repo: IUserRepository,\n    profile_repo: IProfileRepository,\n    permission_repo: IPermissionRepository,\n) -> Optional[User]:\n    \"\"\"\n    Проверка доступа в админку.\n\n    Раньше тут были прямые запросы:\n      - session.get(User, id)\n      - select(Profile)\n      - select(Permission)\n    Теперь всё это делаем через DI-репозитории.\n    \"\"\"\n    admin_uid = _admin_identity(request)\n    if not admin_uid:\n        return None\n\n    u = await user_repo.get_by_id(session, user_id=int(admin_uid))\n    if not u:\n        return None\n\n    prof = await profile_repo.get_by_user_id(session, user_id=int(u.id))\n    if not prof:\n        return None\n\n    perm = await permission_repo.get_by_profile_id(session, profile_id=int(prof.id))\n    if not perm or not (perm.is_superadmin or perm.is_admin):\n        return None\n\n    return u\n\n\n# ------------- ЛОГИН/ЛОГАУТ -------------\n\n@router.get(\"/admin/login\", name=\"admin_login\")\nasync def admin_login_get(request: Request):\n    csrf = _ensure_csrf(request)\n    return templates.TemplateResponse(\"admin/login.html\", {\"request\": request, \"csrf\": csrf})\n\n\n@router.post(\"/admin/login\", name=\"admin_login_post\")\nasync def admin_login_post(\n    request: Request,\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    user_repo: Annotated[IUserRepository, Depends(get_user_repository)],\n    profile_repo: Annotated[IProfileRepository, Depends(get_profile_repository)],\n    permission_repo: Annotated[IPermissionRepository, Depends(get_permission_repository)],\n    username: Annotated[str, Form(...)],\n    password: Annotated[str, Form(...)],\n    csrf_token: Annotated[str, Form(...)],\n):\n    if csrf_token != request.session.get(\"admin_csrf\"):\n        return templates.TemplateResponse(\n            \"admin/login.html\",\n            {\"request\": request, \"csrf\": _ensure_csrf(request), \"alert\": {\"kind\": \"error\", \"text\": \"CSRF error\"}},\n            status_code=400,\n        )\n\n    username = (username or \"\").strip()\n\n    # ❗️Раньше тут был прямой SQL: select(User).where(User.username == username)\n    # ✅ Теперь берём через репозиторий:\n    user = await user_repo.get_by_username(session, username=username)\n\n    if not user or not verify_password(password or \"\", user.hashed_password or \"\"):\n        return templates.TemplateResponse(\n            \"admin/login.html\",\n            {\"request\": request, \"csrf\": _ensure_csrf(request), \"alert\": {\"kind\": \"error\", \"text\": \"Invalid creds\"}},\n            status_code=400,\n        )\n\n    # ❗️Раньше были прямые select(Profile)/select(Permission)\n    # ✅ Теперь всё через репозитории:\n    prof = await profile_repo.get_by_user_id(session, user_id=int(user.id))\n    perm = await permission_repo.get_by_profile_id(session, profile_id=int(prof.id)) if prof else None\n\n    if not perm or not (perm.is_superadmin or perm.is_admin):\n        return templates.TemplateResponse(\n            \"admin/login.html\",\n            {\"request\": request, \"csrf\": _ensure_csrf(request), \"alert\": {\"kind\": \"error\", \"text\": \"No admin rights\"}},\n            status_code=403,\n        )\n\n    request.session[\"admin_user_id\"] = user.id\n    log.info({\"event\": \"admin_login_ok\", \"user_id\": user.id, \"username\": username})\n    return RedirectResponse(url=\"/admin\", status_code=status.HTTP_303_SEE_OTHER)\n\n\n@router.post(\"/admin/logout\", name=\"admin_logout\")\nasync def admin_logout_post(request: Request):\n    request.session.pop(\"admin_user_id\", None)\n    return RedirectResponse(url=\"/admin/login\", status_code=status.HTTP_303_SEE_OTHER)\n\n\n# ------------- ИНДЕКС -------------\n\n@router.get(\"/admin\", name=\"admin_index\")\nasync def admin_index(\n    request: Request,\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    user_repo: Annotated[IUserRepository, Depends(get_user_repository)],\n    profile_repo: Annotated[IProfileRepository, Depends(get_profile_repository)],\n    permission_repo: Annotated[IPermissionRepository, Depends(get_permission_repository)],\n):\n    me = await _require_admin(request, session, user_repo, profile_repo, permission_repo)\n    if not me:\n        return RedirectResponse(url=\"/admin/login\", status_code=status.HTTP_303_SEE_OTHER)\n\n    models = [{\"slug\": m.slug, \"model_name\": m.model.__name__} for m in admin_site.all()]\n    return templates.TemplateResponse(\n        \"admin/index.html\",\n        {\"request\": request, \"me\": me, \"models\": models},\n    )\n\n\n# ------------- ГЕНЕРИК: СПИСОК -------------\n\n@router.get(\"/admin/m/{slug}\", name=\"admin_model_list\")\nasync def admin_model_list(\n    request: Request,\n    slug: str,\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    user_repo: Annotated[IUserRepository, Depends(get_user_repository)],\n    profile_repo: Annotated[IProfileRepository, Depends(get_profile_repository)],\n    permission_repo: Annotated[IPermissionRepository, Depends(get_permission_repository)],\n    q: str | None = None,\n):\n    me = await _require_admin(request, session, user_repo, profile_repo, permission_repo)\n    if not me:\n        return RedirectResponse(url=\"/admin/login\", status_code=status.HTTP_303_SEE_OTHER)\n\n    ma = admin_site.get(slug)\n    if not ma:\n        raise HTTPException(status_code=404, detail=\"Model not registered\")\n\n    Model = ma.model\n    stmt = select(Model)\n\n    if q and ma.search_fields:\n        clauses = []\n        for f in ma.search_fields:\n            col = getattr(Model, f, None)\n            if col is not None:\n                clauses.append(getattr(Model, f).ilike(f\"%{q}%\"))\n        if clauses:\n            stmt = stmt.where(or_(*clauses))\n\n    insp = sa_inspect(Model)\n    pk_cols = insp.primary_key\n    if pk_cols:\n        stmt = stmt.order_by(pk_cols[0])\n\n    # ⚠️ Универсальная админка по любым моделям:\n    # - Для моделей без репозитория это неизбежно (иначе нужен GenericRepository).\n    # - Для User/Profile/Permission мы уже убрали прямые запросы в местах авторизации/прав.\n    rows = (await session.execute(stmt)).scalars().all()\n\n    return templates.TemplateResponse(\n        \"admin/model_list.html\",\n        {\n            \"request\": request,\n            \"slug\": slug,\n            \"model_name\": Model.__name__,\n            \"list_display\": ma.list_display or [c.key for c in sa_inspect(Model).columns],\n            \"rows\": rows,\n            \"q\": q or \"\",\n        },\n    )\n\n\n# ------------- ГЕНЕРИК: ФОРМА РЕДАКТИРОВАНИЯ -------------\n\ndef _coerce_value(col: Column, raw: str | None) -> Any:\n    if raw is None:\n        return None\n    if raw.strip() == \"\":\n        return None\n\n    t = col.type.__class__.__name__.lower()\n    try:\n        if \"boolean\" in t:\n            return raw.lower() in (\"1\", \"true\", \"on\", \"yes\")\n        if \"integer\" in t or \"bigint\" in t or \"smallint\" in t:\n            return int(raw)\n        if \"float\" in t or \"numeric\" in t or \"decimal\" in t:\n            return float(raw)\n        return raw\n    except Exception:\n        return raw\n\n\n@router.get(\"/admin/m/{slug}/{obj_id}/edit\", name=\"admin_model_edit\")\nasync def admin_model_edit_get(\n    request: Request,\n    slug: str,\n    obj_id: int,\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    user_repo: Annotated[IUserRepository, Depends(get_user_repository)],\n    profile_repo: Annotated[IProfileRepository, Depends(get_profile_repository)],\n    permission_repo: Annotated[IPermissionRepository, Depends(get_permission_repository)],\n):\n    me = await _require_admin(request, session, user_repo, profile_repo, permission_repo)\n    if not me:\n        return RedirectResponse(url=\"/admin/login\", status_code=status.HTTP_303_SEE_OTHER)\n\n    ma = admin_site.get(slug)\n    if not ma:\n        raise HTTPException(status_code=404, detail=\"Model not registered\")\n\n    Model = ma.model\n\n    # ⚠️ Универсальная админка:\n    # для произвольной модели без репозитория используем session.get как исключение.\n    obj = await session.get(Model, obj_id)\n    if not obj:\n        return RedirectResponse(url=f\"/admin/m/{slug}\", status_code=status.HTTP_303_SEE_OTHER)\n\n    csrf = _ensure_csrf(request)\n\n    # Права на редактирование супер-флага (Permission.is_superadmin)\n    me_prof = await profile_repo.get_by_user_id(session, user_id=int(me.id))\n    me_perm = await permission_repo.get_by_profile_id(session, profile_id=int(me_prof.id)) if me_prof else None\n    can_edit_super_flag = bool(me_perm and getattr(me_perm, \"is_superadmin\", False))\n\n    return templates.TemplateResponse(\n        \"admin/model_edit.html\",\n        {\n            \"request\": request,\n            \"slug\": slug,\n            \"model_name\": Model.__name__,\n            \"obj\": obj,\n            \"fields\": ma.form_fields,\n            \"readonly_fields\": ma.readonly_fields,\n            \"labels\": ma.field_labels,\n            \"csrf\": csrf,\n            \"can_edit_super_flag\": can_edit_super_flag,\n        },\n    )\n\n\n@router.post(\"/admin/m/{slug}/{obj_id}/edit\", name=\"admin_model_edit_post\")\nasync def admin_model_edit_post(\n    request: Request,\n    slug: str,\n    obj_id: int,\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    user_repo: Annotated[IUserRepository, Depends(get_user_repository)],\n    profile_repo: Annotated[IProfileRepository, Depends(get_profile_repository)],\n    permission_repo: Annotated[IPermissionRepository, Depends(get_permission_repository)],\n    csrf_token: Annotated[str, Form(...)],\n):\n    me = await _require_admin(request, session, user_repo, profile_repo, permission_repo)\n    if not me:\n        return RedirectResponse(url=\"/admin/login\", status_code=status.HTTP_303_SEE_OTHER)\n    if csrf_token != request.session.get(\"admin_csrf\"):\n        return RedirectResponse(url=f\"/admin/m/{slug}/{obj_id}/edit\", status_code=status.HTTP_303_SEE_OTHER)\n\n    ma = admin_site.get(slug)\n    if not ma:\n        raise HTTPException(status_code=404, detail=\"Model not registered\")\n\n    Model = ma.model\n\n    # ⚠️ Универсальная админка: как исключение получаем объект напрямую,\n    # потому что для произвольных моделей репозитории могут отсутствовать.\n    obj = await session.get(Model, obj_id)\n    if not obj:\n        return RedirectResponse(url=f\"/admin/m/{slug}\", status_code=status.HTTP_303_SEE_OTHER)\n\n    insp = sa_inspect(Model)\n    columns: Dict[str, Column] = {c.key: c for c in insp.columns}\n    vals: Dict[str, Any] = {}\n\n    # ✅ form читаем один раз\n    form = await request.form()\n\n    # ✅ если profile_repo передан как Depends и не используется — просто \"потрогай\" переменную\n    # _ = profile_repo  # если надо убрать warning \"unused\" (никаких await!)\n\n    # Права на редактирование супер-флага\n    me_prof = (await session.execute(select(Profile).where(Profile.user_id == me.id))).scalar_one_or_none()\n    me_perm = None\n    if me_prof:\n        me_perm = (\n            await session.execute(select(Permission).where(Permission.profile_id == me_prof.id))).scalar_one_or_none()\n    actor_is_super = bool(me_perm and me_perm.is_superadmin)\n\n    for f in ma.form_fields:\n        if f not in columns:\n            continue\n        col = columns[f]\n        tname = col.type.__class__.__name__.lower()\n\n        if \"boolean\" in tname:\n            raw = form.get(f)\n            # ✅ checkbox: если поле пришло — True (не важно какое value)\n            vals[f] = raw is not None\n\n        else:\n            raw = form.get(f)\n            vals[f] = _coerce_value(col, raw)\n\n    # Если редактируем Permission — не давать менять is_superadmin, если актор не супер\n    if Model is Permission and not actor_is_super and \"is_superadmin\" in vals:\n        vals.pop(\"is_superadmin\", None)\n\n    # Никогда не пишем readonly\n    for ro in ma.readonly_fields:\n        vals.pop(ro, None)\n\n    if vals:\n        await session.execute(update(Model).where(insp.primary_key[0] == obj_id).values(**vals))\n        await session.commit()\n        log.info({\"event\": \"admin_model_update\", \"slug\": slug, \"obj_id\": obj_id, **vals})\n\n    return RedirectResponse(url=f\"/admin/m/{slug}/{obj_id}/edit\", status_code=status.HTTP_303_SEE_OTHER)\n"
    },
    {
      "path": "src/core/views/auth.py",
      "language": "python",
      "size_bytes": 12265,
      "sha256": "9dc93fc7a6b6edcc07863845b8711ec968695c6c16a2a9fa3f82708652455a00",
      "content": "# path: src/core/views/auth.py\nfrom __future__ import annotations\n\nimport secrets\nfrom pathlib import Path\nfrom typing import Annotated\n\nfrom fastapi import APIRouter, Request, Depends, Form, BackgroundTasks, status\nfrom fastapi.responses import RedirectResponse\nfrom fastapi.templating import Jinja2Templates\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.exc import IntegrityError\n\nfrom src.app_logging import get_logger\nfrom src.core.dependencies import get_auth_service, get_user_repository\nfrom src.core.mailing.email import send_verification_email_sync\nfrom src.core.models import db_helper\nfrom src.core.services.auth_service import AuthService\nfrom src.crud.user_repository import IUserRepository\n\nrouter = APIRouter()\nlog = get_logger(\"views.auth\")\n\nTEMPLATES_DIR = Path(__file__).resolve().parents[2] / \"templates\"\ntemplates = Jinja2Templates(directory=str(TEMPLATES_DIR))\n\n\ndef _ensure_csrf(request: Request) -> str:\n    token = request.session.get(\"csrf\")\n    if not token:\n        token = secrets.token_urlsafe(16)\n        request.session[\"csrf\"] = token\n    return token\n\n\ndef _new_captcha(request: Request) -> tuple[int, int, int]:\n    a = secrets.randbelow(9) + 1\n    b = secrets.randbelow(9) + 1\n    s = a + b\n    request.session[\"captcha_sum\"] = s\n    return a, b, s\n\n\n@router.get(\"/auth/login\", name=\"login_html\")\nasync def login_html(request: Request):\n    csrf = _ensure_csrf(request)\n    a, b, _ = _new_captcha(request)\n    log.info({\"event\": \"open_page\", \"path\": \"/auth/login\", \"method\": \"GET\"})\n    return templates.TemplateResponse(\"core/login.html\", {\"request\": request, \"csrf\": csrf, \"a\": a, \"b\": b})\n\n\n@router.post(\"/auth/login\", name=\"login_post_html\")\nasync def login_post_html(\n    request: Request,\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    service: Annotated[AuthService, Depends(get_auth_service)],\n    user_repo: Annotated[IUserRepository, Depends(get_user_repository)],\n    email: Annotated[str, Form(...)],\n    password: Annotated[str, Form(...)],\n    csrf_token: Annotated[str, Form(...)],\n    captcha: Annotated[int, Form(...)],\n):\n    if csrf_token != request.session.get(\"csrf\"):\n        log.info({\"event\": \"login_fail\", \"reason\": \"csrf\"})\n        csrf = _ensure_csrf(request)\n        a, b, _ = _new_captcha(request)\n        return templates.TemplateResponse(\n            \"core/login.html\",\n            {\"request\": request, \"csrf\": csrf, \"a\": a, \"b\": b, \"alert\": {\"kind\": \"error\", \"text\": \"CSRF error\"}},\n            status_code=400,\n        )\n\n    try:\n        if int(captcha) != int(request.session.get(\"captcha_sum\", -1)):\n            raise ValueError\n    except Exception:\n        log.info({\"event\": \"login_fail\", \"reason\": \"bad_captcha\"})\n        csrf = _ensure_csrf(request)\n        a, b, _ = _new_captcha(request)\n        return templates.TemplateResponse(\n            \"core/login.html\",\n            {\"request\": request, \"csrf\": csrf, \"a\": a, \"b\": b, \"alert\": {\"kind\": \"error\", \"text\": \"Капча неверна\"}},\n            status_code=400,\n        )\n\n    email_norm = email.strip().lower()\n\n    try:\n        await service.authenticate(session, email=email_norm, password=password)\n\n        user = await user_repo.get_by_email(session, email=email_norm)\n        if not user:\n            raise ValueError(\"user_not_found_after_auth\")\n\n        profile = await user_repo.get_profile_by_user_id(session, user_id=int(user.id))\n        email_verified = bool(profile and profile.verification)\n\n    except ValueError:\n        log.info({\"event\": \"login_fail\", \"reason\": \"bad_credentials_or_not_found\", \"email\": email_norm})\n        csrf = _ensure_csrf(request)\n        a, b, _ = _new_captcha(request)\n        return templates.TemplateResponse(\n            \"core/login.html\",\n            {\n                \"request\": request,\n                \"csrf\": csrf,\n                \"a\": a,\n                \"b\": b,\n                \"alert\": {\"kind\": \"error\", \"text\": \"Неверный e-mail или пароль\"},\n            },\n            status_code=400,\n        )\n\n    access_token = service.make_access_token(\n        email=user.email,\n        uid=int(user.id),\n        email_verified=email_verified,\n    )\n    request.session[\"access_token\"] = access_token\n    request.session[\"user_email\"] = user.email\n    request.session[\"user_id\"] = int(user.id)\n\n    log.info({\"event\": \"login_ok\", \"email\": user.email, \"email_verified\": email_verified})\n    return RedirectResponse(url=\"/\", status_code=status.HTTP_303_SEE_OTHER)\n\n\n@router.get(\"/auth/register\", name=\"register_html\")\nasync def register_html(request: Request):\n    csrf = _ensure_csrf(request)\n    a, b, _ = _new_captcha(request)\n    log.info({\"event\": \"open_page\", \"path\": \"/auth/register\", \"method\": \"GET\"})\n    return templates.TemplateResponse(\"core/register.html\", {\"request\": request, \"csrf\": csrf, \"a\": a, \"b\": b})\n\n\n@router.post(\"/auth/register\", name=\"register_post_html\")\nasync def register_post_html(\n    request: Request,\n    background: BackgroundTasks,\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    service: Annotated[AuthService, Depends(get_auth_service)],\n    email: Annotated[str, Form(...)],\n    password: Annotated[str, Form(...)],\n    password2: Annotated[str, Form(...)],\n    csrf_token: Annotated[str, Form(...)],\n    captcha: Annotated[int, Form(...)],\n):\n    if csrf_token != request.session.get(\"csrf\"):\n        log.info({\"event\": \"register_fail\", \"email\": email, \"reason\": \"csrf\"})\n        csrf = _ensure_csrf(request)\n        a, b, _ = _new_captcha(request)\n        return templates.TemplateResponse(\n            \"core/register.html\",\n            {\"request\": request, \"csrf\": csrf, \"a\": a, \"b\": b, \"alert\": {\"kind\": \"error\", \"text\": \"CSRF error\"}},\n            status_code=400,\n        )\n\n    try:\n        if int(captcha) != int(request.session.get(\"captcha_sum\", -1)):\n            raise ValueError\n    except Exception:\n        log.info({\"event\": \"register_fail\", \"email\": email, \"reason\": \"bad_captcha\"})\n        csrf = _ensure_csrf(request)\n        a, b, _ = _new_captcha(request)\n        return templates.TemplateResponse(\n            \"core/register.html\",\n            {\"request\": request, \"csrf\": csrf, \"a\": a, \"b\": b, \"alert\": {\"kind\": \"error\", \"text\": \"Капча неверна\"}},\n            status_code=400,\n        )\n\n    email_norm = email.strip().lower()\n    if len(password) < 8 or len(password) > 256 or password != password2:\n        log.info({\"event\": \"register_fail\", \"email\": email_norm, \"reason\": \"weak_or_mismatch_password\"})\n        csrf = _ensure_csrf(request)\n        a, b, _ = _new_captcha(request)\n        return templates.TemplateResponse(\n            \"core/register.html\",\n            {\n                \"request\": request,\n                \"csrf\": csrf,\n                \"a\": a,\n                \"b\": b,\n                \"alert\": {\"kind\": \"error\", \"text\": \"Пароль должен быть 8..256 символов и совпадать.\"},\n            },\n            status_code=400,\n        )\n\n    try:\n        user_id, verify_token = await service.register_user(session, email=email_norm, password=password)\n        await session.commit()\n\n        verify_link = str(request.url_for(\"verify_email\", token=verify_token))\n        log.info({\"event\": \"verify_link\", \"email\": email_norm, \"verify_link\": verify_link})\n\n        background.add_task(send_verification_email_sync, email_norm, verify_link)\n\n        access_token = service.make_access_token(email=email_norm, uid=int(user_id), email_verified=False)\n        request.session[\"access_token\"] = access_token\n        request.session[\"user_email\"] = email_norm\n        request.session[\"user_id\"] = int(user_id)\n\n        log.info({\"event\": \"register_success\", \"email\": email_norm, \"user_id\": int(user_id)})\n        return RedirectResponse(url=\"/\", status_code=status.HTTP_303_SEE_OTHER)\n\n    except ValueError as e:\n        if str(e) == \"email_already_exists\":\n            log.info({\"event\": \"register_fail\", \"email\": email_norm, \"reason\": \"precheck_exists\"})\n            csrf = _ensure_csrf(request)\n            a, b, _ = _new_captcha(request)\n            return templates.TemplateResponse(\n                \"core/register.html\",\n                {\n                    \"request\": request,\n                    \"csrf\": csrf,\n                    \"a\": a,\n                    \"b\": b,\n                    \"alert\": {\"kind\": \"error\", \"text\": \"Пользователь с таким e-mail уже существует\"},\n                },\n                status_code=400,\n            )\n\n        await session.rollback()\n        log.info({\"event\": \"register_fail\", \"email\": email_norm, \"error\": str(e)})\n        csrf = _ensure_csrf(request)\n        a, b, _ = _new_captcha(request)\n        return templates.TemplateResponse(\n            \"core/register.html\",\n            {\"request\": request, \"csrf\": csrf, \"a\": a, \"b\": b, \"alert\": {\"kind\": \"error\", \"text\": f\"Ошибка регистрации: {e}\"}},\n            status_code=400,\n        )\n\n    except IntegrityError as e:\n        await session.rollback()\n        cname = getattr(getattr(e, \"orig\", None), \"constraint_name\", None)\n        txt = str(getattr(e, \"orig\", e))\n        human = \"Нарушение целостности данных.\"\n        if \"not-null constraint\" in txt or \"NotNullViolation\" in txt:\n            human = \"Внутренняя ошибка схемы: одно из полей пустое. Обнови миграции (username теперь необязателен).\"\n        elif cname == \"uq_users_email\" or \"uq_users_email\" in txt:\n            human = \"Пользователь с таким e-mail уже зарегистрирован\"\n        elif cname == \"uq_users_username\" or \"uq_users_username\" in txt:\n            human = \"Такой username уже занят\"\n\n        log.info({\"event\": \"register_fail\", \"email\": email_norm, \"constraint\": cname, \"sql_error\": txt})\n        csrf = _ensure_csrf(request)\n        a, b, _ = _new_captcha(request)\n        return templates.TemplateResponse(\n            \"core/register.html\",\n            {\"request\": request, \"csrf\": csrf, \"a\": a, \"b\": b, \"alert\": {\"kind\": \"error\", \"text\": human}},\n            status_code=400,\n        )\n\n    except Exception as e:\n        await session.rollback()\n        log.info({\"event\": \"register_fail\", \"email\": email_norm, \"error\": str(e)})\n        csrf = _ensure_csrf(request)\n        a, b, _ = _new_captcha(request)\n        return templates.TemplateResponse(\n            \"core/register.html\",\n            {\"request\": request, \"csrf\": csrf, \"a\": a, \"b\": b, \"alert\": {\"kind\": \"error\", \"text\": \"Не удалось зарегистрировать пользователя\"}},\n            status_code=400,\n        )\n\n\n@router.get(\"/auth/verify/{token}\", name=\"verify_email\")\nasync def verify_email(\n    request: Request,\n    token: str,\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    service: Annotated[AuthService, Depends(get_auth_service)],\n):\n    try:\n        uid = await service.verify_email(session, token)\n        await session.commit()\n\n        if request.session.get(\"user_id\") == uid:\n            access_token = service.make_access_token(\n                email=request.session.get(\"user_email\", \"\"),\n                uid=int(uid),\n                email_verified=True,\n            )\n            request.session[\"access_token\"] = access_token\n\n        log.info({\"event\": \"verify_ok\", \"uid\": int(uid)})\n        alert = {\"kind\": \"success\", \"text\": \"E-mail подтвержден. Спасибо!\"}\n    except Exception as e:\n        await session.rollback()\n        log.info({\"event\": \"verify_fail\", \"error\": str(e)})\n        alert = {\"kind\": \"error\", \"text\": \"Ссылка недействительна или устарела.\"}\n\n    return templates.TemplateResponse(\"core/index.html\", {\"request\": request, \"alert\": alert})\n\n\n@router.post(\"/auth/logout\", name=\"logout_html\")\n@router.get(\"/auth/logout\")\nasync def logout_html(request: Request):\n    request.session.pop(\"access_token\", None)\n    request.session.pop(\"user_email\", None)\n    request.session.pop(\"user_id\", None)\n    log.info({\"event\": \"logout_ok\"})\n    return RedirectResponse(url=\"/\", status_code=status.HTTP_303_SEE_OTHER)\n"
    },
    {
      "path": "src/core/views/web.py",
      "language": "python",
      "size_bytes": 7891,
      "sha256": "ba65e28491eccf3f6bcc9db6a16ad434137e2eea38ddd895597c2183f718489c",
      "content": "# path: src/core/views/web.py\nfrom __future__ import annotations\n\nimport io\nfrom pathlib import Path\nfrom typing import Annotated, Optional\n\nfrom PIL import Image\nfrom fastapi import APIRouter, Request, Depends, UploadFile, File, Form, status\nfrom fastapi.responses import RedirectResponse\nfrom fastapi.templating import Jinja2Templates\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.app_logging import get_logger\nfrom src.core.dependencies import get_user_repository\nfrom src.core.models import db_helper\nfrom src.crud.user_repository import IUserRepository\n\nrouter = APIRouter()\nlog = get_logger(\"web\")\n\nPROJECT_DIR = Path(__file__).resolve().parents[3]   # /app\nSRC_DIR = PROJECT_DIR / \"src\"\n\nTEMPLATES_DIR = SRC_DIR / \"templates\"\ntemplates = Jinja2Templates(directory=str(TEMPLATES_DIR))\n\nSTATIC_DIR = PROJECT_DIR / \"static\"\nAVATAR_DIR = STATIC_DIR / \"uploads\" / \"avatars\"\nAVATAR_DIR.mkdir(parents=True, exist_ok=True)\n\nMAX_AVATAR_MB = 3\nMAX_AVATAR_BYTES = MAX_AVATAR_MB * 1024 * 1024\nALLOWED_IMAGE_EXTS = {\".jpg\", \".jpeg\", \".png\", \".gif\", \".webp\"}\nALLOWED_CONTENT_TYPES = {\"image/jpeg\", \"image/png\", \"image/gif\", \"image/webp\"}\n\n\n@router.get(\"/\", name=\"home\")\nasync def index_html(request: Request):\n    log.info({\"event\": \"open_page\", \"path\": \"/\", \"method\": \"GET\"})\n    return templates.TemplateResponse(\"core/index.html\", {\"request\": request})\n\n\n@router.get(\"/users/\", name=\"users_list_html\")\nasync def users_list_html(\n    request: Request,\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    user_repo: Annotated[IUserRepository, Depends(get_user_repository)],\n):\n    users = await user_repo.list_users(session)\n    log.info({\"event\": \"open_page\", \"path\": \"/users/\", \"method\": \"GET\", \"count\": len(users)})\n    return templates.TemplateResponse(\"users/list.html\", {\"request\": request, \"users\": users})\n\n\ndef _require_logged_in(request: Request) -> Optional[str]:\n    token = request.session.get(\"access_token\")\n    email = request.session.get(\"user_email\")\n    if not token or not email:\n        return None\n    return str(email)\n\n\n@router.get(\"/profile\", name=\"profile_html\")\nasync def profile_html(\n    request: Request,\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    user_repo: Annotated[IUserRepository, Depends(get_user_repository)],\n):\n    email = _require_logged_in(request)\n    if not email:\n        return RedirectResponse(url=\"/auth/login\", status_code=status.HTTP_303_SEE_OTHER)\n\n    user = await user_repo.get_by_email(session, email=email)\n    if not user:\n        return RedirectResponse(url=\"/auth/login\", status_code=status.HTTP_303_SEE_OTHER)\n\n    profile = await user_repo.get_profile_by_user_id(session, user_id=int(user.id))\n\n    return templates.TemplateResponse(\"core/profile.html\", {\"request\": request, \"user\": user, \"profile\": profile})\n\n\n@router.post(\"/profile\", name=\"profile_post_html\")\nasync def profile_post_html(\n    request: Request,\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    user_repo: Annotated[IUserRepository, Depends(get_user_repository)],\n    nickname: Annotated[str | None, Form()] = None,\n    first_name: Annotated[str | None, Form()] = None,\n    second_name: Annotated[str | None, Form()] = None,\n    phone: Annotated[str | None, Form()] = None,\n    email_field: Annotated[str | None, Form()] = None,\n    tg_id: Annotated[str | None, Form()] = None,\n    tg_nickname: Annotated[str | None, Form()] = None,\n    avatar: Annotated[UploadFile | None, File()] = None,\n):\n    def _clean_str(v: str | None) -> str | None:\n        if not v:\n            return None\n        v = v.strip()\n        return v or None\n\n    def _clean_tg_id(v: str | None) -> int | None:\n        if not v:\n            return None\n        digits = \"\".join(ch for ch in v if ch.isdigit())\n        return int(digits) if digits else None\n\n    email = _require_logged_in(request)\n    if not email:\n        return RedirectResponse(\"/auth/login\", status.HTTP_303_SEE_OTHER)\n\n    user = await user_repo.get_by_email(session, email=email)\n    if not user:\n        return RedirectResponse(\"/auth/login\", status.HTTP_303_SEE_OTHER)\n\n    profile = await user_repo.get_profile_by_user_id(session, user_id=int(user.id))\n    if not profile:\n        return RedirectResponse(\"/\", status.HTTP_303_SEE_OTHER)\n\n    updates: dict[str, object] = {\n        \"nickname\": _clean_str(nickname),\n        \"first_name\": _clean_str(first_name),\n        \"second_name\": _clean_str(second_name),\n        \"phone\": _clean_str(phone),\n        \"email\": _clean_str(email_field),\n        \"tg_id\": _clean_tg_id(tg_id),\n        \"tg_nickname\": _clean_str(tg_nickname),\n    }\n\n    if avatar and avatar.filename:\n        if avatar.content_type not in ALLOWED_CONTENT_TYPES:\n            return templates.TemplateResponse(\n                \"core/profile.html\",\n                {\"request\": request, \"user\": user, \"profile\": profile, \"alert\": {\"kind\": \"error\", \"text\": \"Разрешены только изображения\"}},\n            )\n\n        content = await avatar.read()\n        if len(content) > MAX_AVATAR_BYTES:\n            return templates.TemplateResponse(\n                \"core/profile.html\",\n                {\"request\": request, \"user\": user, \"profile\": profile, \"alert\": {\"kind\": \"error\", \"text\": \"Максимальный размер — 3 МБ\"}},\n            )\n\n        try:\n            img = Image.open(io.BytesIO(content))\n            img.load()\n            if img.width < 40 or img.height < 40:\n                raise ValueError\n        except Exception:\n            return templates.TemplateResponse(\n                \"core/profile.html\",\n                {\"request\": request, \"user\": user, \"profile\": profile, \"alert\": {\"kind\": \"error\", \"text\": \"Некорректное изображение\"}},\n            )\n\n        user_dir = AVATAR_DIR / f\"user_{int(user.id)}\"\n        user_dir.mkdir(parents=True, exist_ok=True)\n\n        ext = Path(avatar.filename).suffix.lower()\n        if ext not in ALLOWED_IMAGE_EXTS:\n            ext = \".jpg\"\n\n        filename = f\"user_{int(user.id)}{ext}\"\n        dst = user_dir / filename\n\n        for old in user_dir.glob(\"user_*.*\"):\n            old.unlink(missing_ok=True)\n\n        dst.write_bytes(content)\n        updates[\"avatar\"] = f\"uploads/avatars/user_{int(user.id)}/{filename}\"\n\n        log.info({\"event\": \"avatar_saved\", \"user_id\": int(user.id), \"path\": updates[\"avatar\"]})\n\n    await user_repo.update_profile(session=session, profile_id=int(profile.id), **updates)\n    await session.commit()\n\n    log.info({\"event\": \"profile_updated\", \"user_id\": int(user.id), \"fields\": list(updates.keys())})\n    return RedirectResponse(\"/profile\", status.HTTP_303_SEE_OTHER)\n\n\n@router.post(\"/profile/avatar/delete\", name=\"profile_avatar_delete\")\nasync def profile_avatar_delete(\n    request: Request,\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    user_repo: Annotated[IUserRepository, Depends(get_user_repository)],\n):\n    email = _require_logged_in(request)\n    if not email:\n        return RedirectResponse(\"/auth/login\", status.HTTP_303_SEE_OTHER)\n\n    user = await user_repo.get_by_email(session, email=email)\n    if not user:\n        return RedirectResponse(\"/auth/login\", status.HTTP_303_SEE_OTHER)\n\n    profile = await user_repo.get_profile_by_user_id(session, user_id=int(user.id))\n    if not profile:\n        return RedirectResponse(\"/\", status.HTTP_303_SEE_OTHER)\n\n    if profile.avatar:\n        path = (STATIC_DIR / str(profile.avatar)).resolve()\n\n        # ✅ защита от path traversal: удаляем только внутри STATIC_DIR\n        if STATIC_DIR.resolve() in path.parents and path.exists():\n            path.unlink()\n\n    await user_repo.update_profile(session=session, profile_id=int(profile.id), avatar=None)\n    await session.commit()\n\n    return RedirectResponse(\"/profile\", status.HTTP_303_SEE_OTHER)\n"
    },
    {
      "path": "src/crud/__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "src/crud/feedback_candidate_repository.py",
      "language": "python",
      "size_bytes": 1627,
      "sha256": "3f37090e1a311c27b4f6018ae51830740c0b09d5d33013ccf0cc2cd123179f05",
      "content": "# path: src/crud/feedback_candidate_repository.py\nfrom __future__ import annotations\n\nfrom typing import Any, Dict, Protocol, Sequence\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.train.models.feedback_candidate import FeedbackCandidate\n\n\nclass IFeedbackCandidateRepository(Protocol):\n    async def bulk_create_from_topk(\n        self,\n        session: AsyncSession,\n        *,\n        topk: list[list[dict[str, Any]]],\n        row_id_by_idx: dict[int, int],\n        model_name: str,\n    ) -> int: ...\n\n\nclass FeedbackCandidateRepository(IFeedbackCandidateRepository):\n    async def bulk_create_from_topk(\n        self,\n        session: AsyncSession,\n        *,\n        topk: list[list[dict[str, Any]]],\n        row_id_by_idx: dict[int, int],\n        model_name: str,\n    ) -> int:\n        objs: list[FeedbackCandidate] = []\n\n        for row_idx, cand_list in enumerate(topk):\n            row_id = row_id_by_idx.get(int(row_idx))\n            if not row_id:\n                continue\n\n            for cand in cand_list:\n                item_id = cand.get(\"id\")\n                if item_id is None:\n                    continue\n\n                objs.append(\n                    FeedbackCandidate(\n                        row_id=int(row_id),\n                        item_id=int(item_id),\n                        model=str(model_name),\n                        score=float(cand.get(\"score\", 0.0)),\n                        rank=int(cand.get(\"rank\", 0) or 0),\n                        shown=True,\n                    )\n                )\n\n        session.add_all(objs)\n        await session.flush()\n        return len(objs)\n"
    },
    {
      "path": "src/crud/feedback_label_repository.py",
      "language": "python",
      "size_bytes": 2395,
      "sha256": "d8241b41fcfd366242b2cb8df44b073040bd3dfb3c8ac6a548fb351bc208c36c",
      "content": "# path: src/crud/feedback_label_repository.py\nfrom __future__ import annotations\n\nfrom typing import Any, Protocol\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.train.models.feedback_label import FeedbackLabel\n\n\nclass IFeedbackLabelRepository(Protocol):\n    async def bulk_create_from_commit(\n        self,\n        session: AsyncSession,\n        *,\n        rows: list[dict[str, Any]],\n        row_id_by_idx: dict[int, int],\n        created_by: str,\n        is_trusted: bool,\n    ) -> int: ...\n\n\nclass FeedbackLabelRepository(IFeedbackLabelRepository):\n    async def bulk_create_from_commit(\n        self,\n        session: AsyncSession,\n        *,\n        rows: list[dict[str, Any]],\n        row_id_by_idx: dict[int, int],\n        created_by: str,\n        is_trusted: bool,\n    ) -> int:\n        \"\"\"\n        rows[] ожидает поля:\n          - row_idx\n          - label: gold|negative|skip|ambiguous|none_match\n          - selected_item_id\n          - negatives: [item_id, ...]\n          - note\n        \"\"\"\n        objs: list[FeedbackLabel] = []\n\n        for r in rows:\n            row_idx = int(r.get(\"row_idx\", 0))\n            row_id = row_id_by_idx.get(row_idx)\n            if not row_id:\n                continue\n\n            label = str(r.get(\"label\", \"\") or \"\").strip() or \"gold\"\n            selected_item_id = r.get(\"selected_item_id\")\n            negatives = r.get(\"negatives\", [])\n\n            if not isinstance(negatives, list):\n                negatives = []\n\n            # правило: если label=gold и selected_item_id пустой — это логическая ошибка,\n            # но мы не падаем: пусть будет ambiguous.\n            if label == \"gold\" and selected_item_id is None:\n                label = \"ambiguous\"\n\n            objs.append(\n                FeedbackLabel(\n                    row_id=int(row_id),\n                    selected_item=int(selected_item_id) if isinstance(selected_item_id, int) else None,\n                    label=label,\n                    negatives=[int(x) for x in negatives if isinstance(x, int)],\n                    note=str(r.get(\"note\")) if r.get(\"note\") else None,\n                    created_by=str(created_by),\n                    is_trusted=bool(is_trusted),\n                )\n            )\n\n        session.add_all(objs)\n        await session.flush()\n        return len(objs)\n"
    },
    {
      "path": "src/crud/feedback_row_repository.py",
      "language": "python",
      "size_bytes": 1190,
      "sha256": "316ced99292b97939fb9823952f1da990546bf9005266b6a8406bcc1bf5034d5",
      "content": "# path: src/crud/feedback_row_repository.py\nfrom __future__ import annotations\n\nfrom typing import Any, Protocol, Sequence\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.train.models.feedback_row import FeedbackRow\n\n\nclass IFeedbackRowRepository(Protocol):\n    async def bulk_create(\n        self,\n        session: AsyncSession,\n        session_id: int,\n        rows: list[dict[str, Any]],\n    ) -> Sequence[FeedbackRow]: ...\n\n\nclass FeedbackRowRepository(IFeedbackRowRepository):\n    async def bulk_create(\n        self,\n        session: AsyncSession,\n        session_id: int,\n        rows: list[dict[str, Any]],\n    ) -> Sequence[FeedbackRow]:\n        objs: list[FeedbackRow] = []\n        for r in rows:\n            objs.append(\n                FeedbackRow(\n                    session_id=int(session_id),\n                    row_idx=int(r.get(\"row_idx\", 0)),\n                    caption=str(r.get(\"caption\", \"\") or \"\"),\n                    units_in=r.get(\"units\"),\n                    qty_in=r.get(\"qty\"),\n                    norm_json=r.get(\"norm_json\", None),\n                )\n            )\n\n        session.add_all(objs)\n        await session.flush()\n        return objs\n"
    },
    {
      "path": "src/crud/feedback_session_repository.py",
      "language": "python",
      "size_bytes": 1402,
      "sha256": "3fbb48bfc50d0f3d4d096b3bb4c38601fe2aeabcc6b5350108df4781d93cf660",
      "content": "# path: src/crud/feedback_session_repository.py\nfrom __future__ import annotations\n\nfrom typing import Optional, Protocol\n\nfrom sqlalchemy import select, update\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.train.models.feedback_session import FeedbackSession\n\n\nclass IFeedbackSessionRepository(Protocol):\n    async def create(self, session: AsyncSession, source_name: str, created_by: str) -> FeedbackSession: ...\n    async def close(self, session: AsyncSession, session_id: int) -> None: ...\n    async def get(self, session: AsyncSession, session_id: int) -> Optional[FeedbackSession]: ...\n\n\nclass FeedbackSessionRepository(IFeedbackSessionRepository):\n    async def create(self, session: AsyncSession, source_name: str, created_by: str) -> FeedbackSession:\n        obj = FeedbackSession(source_name=source_name, created_by=created_by, status=\"open\")\n        session.add(obj)\n        await session.flush()\n        return obj\n\n    async def close(self, session: AsyncSession, session_id: int) -> None:\n        await session.execute(\n            update(FeedbackSession).where(FeedbackSession.id == int(session_id)).values(status=\"closed\")\n        )\n\n    async def get(self, session: AsyncSession, session_id: int) -> Optional[FeedbackSession]:\n        res = await session.execute(select(FeedbackSession).where(FeedbackSession.id == int(session_id)))\n        return res.scalar_one_or_none()\n"
    },
    {
      "path": "src/crud/item_repository.py",
      "language": "python",
      "size_bytes": 9077,
      "sha256": "586d2f32a559790f142c139a40a78bf22e32b974ec63f53d3d5145694d8a0572",
      "content": "# path: src/crud/item_repository.py\nfrom __future__ import annotations\n\nfrom typing import (\n    Any,\n    AsyncIterator,\n    Dict,\n    Iterable,\n    List,\n    Optional,\n    Protocol,\n    Sequence,\n    Tuple,\n)\n\nfrom sqlalchemy import delete, select, text, or_, case\nfrom sqlalchemy.dialects.postgresql import insert as pg_insert\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.fsnb_matcher.models.item import Item\n\n\nRowTuple = Tuple[str, str, Optional[str], str]  # (code, name, unit, type)\n\n\nclass IItemRepository(Protocol):\n    \"\"\"\n    Интерфейс репозитория items (DI-контракт).\n\n    Зачем:\n    - единый паттерн: Protocol + реализация;\n    - удобно мокать в тестах;\n    - удобно указывать тип в Depends.\n    \"\"\"\n\n    async def truncate(self, session: AsyncSession) -> None: ...\n    async def delete_all(self, session: AsyncSession) -> int: ...\n    async def count(self, session: AsyncSession) -> int: ...\n\n    async def iter_for_index(\n        self,\n        session: AsyncSession,\n        *,\n        yield_per: int = 2000,\n    ) -> AsyncIterator[Tuple[int, str, Optional[str], Optional[str], str]]: ...\n\n    async def bulk_upsert_dicts(\n        self,\n        session: AsyncSession,\n        rows: Sequence[Dict[str, Any]],\n    ) -> int: ...\n\n    async def bulk_insert_items(\n        self,\n        session: AsyncSession,\n        rows: Iterable[RowTuple],\n        chunk_size: int = 1000,\n    ) -> int: ...\n\n    async def fetch_all_item_ids_and_names(self, session: AsyncSession) -> List[Tuple[int, str]]: ...\n\n    async def fetch_item_name_unit_by_id(\n        self,\n        session: AsyncSession,\n        item_id: int,\n    ) -> Optional[Tuple[str, Optional[str]]]: ...\n\n    async def fetch_item_name_unit_code_by_id(\n        self,\n        session: AsyncSession,\n        item_id: int,\n    ) -> Optional[Tuple[str, Optional[str], Optional[str]]]: ...\n\n    async def fetch_item_codes(\n        self,\n        session: AsyncSession,\n        item_ids: Sequence[int],\n    ) -> Dict[int, Optional[str]]: ...\n\n    async def fetch_items_meta_by_ids(\n        self,\n        session: AsyncSession,\n        item_ids: Sequence[int],\n    ) -> Dict[int, Tuple[str, Optional[str], Optional[str]]]: ...\n\n    async def search_items(\n        self,\n        session: AsyncSession,\n        *,\n        query: str,\n        limit: int = 20,\n    ) -> List[Item]: ...\n\nclass ItemRepository(IItemRepository):\n    \"\"\"\n    Репозиторий для таблицы items.\n\n    Правило:\n    - SQL/DB вызовы живут только здесь (src/crud/).\n    \"\"\"\n\n    async def truncate(self, session: AsyncSession) -> None:\n        \"\"\"TRUNCATE + reset identity.\"\"\"\n        await session.execute(text(\"TRUNCATE TABLE items RESTART IDENTITY;\"))\n        await session.commit()\n\n    async def delete_all(self, session: AsyncSession) -> int:\n        \"\"\"DELETE всех строк (если TRUNCATE не подходит).\"\"\"\n        res = await session.execute(delete(Item))\n        await session.commit()\n        return int(res.rowcount or 0)\n\n    async def count(self, session: AsyncSession) -> int:\n        \"\"\"COUNT(*) по items.\"\"\"\n        res = await session.execute(text(\"SELECT COUNT(*) FROM items;\"))\n        return int(res.scalar_one())\n\n    async def iter_for_index(\n        self,\n        session: AsyncSession,\n        *,\n        yield_per: int = 2000,\n    ) -> AsyncIterator[Tuple[int, str, Optional[str], Optional[str], str]]:\n        \"\"\"Потоковая выгрузка (id, name, code, unit, type) для индексации.\"\"\"\n        stmt = (\n            select(Item.id, Item.name, Item.code, Item.unit, Item.type)\n            .order_by(Item.id)\n            .execution_options(yield_per=yield_per)\n        )\n\n        stream = await session.stream(stmt)\n        async for row in stream:\n            yield (\n                int(row[0]),\n                str(row[1]),\n                row[2] if row[2] is not None else None,\n                row[3] if row[3] is not None else None,\n                str(row[4]),\n            )\n\n    async def bulk_upsert_dicts(\n        self,\n        session: AsyncSession,\n        rows: Sequence[Dict[str, Any]],\n    ) -> int:\n        \"\"\"Bulk insert dicts с ON CONFLICT(code) DO NOTHING.\"\"\"\n        if not rows:\n            return 0\n\n        stmt = (\n            pg_insert(Item)\n            .values(list(rows))\n            .on_conflict_do_nothing(index_elements=[Item.code])\n        )\n        await session.execute(stmt)\n        await session.commit()\n        return len(rows)\n\n    async def bulk_insert_items(\n        self,\n        session: AsyncSession,\n        rows: Iterable[RowTuple],\n        chunk_size: int = 1000,\n    ) -> int:\n        \"\"\"Вставка кортежей (code,name,unit,type) чанками.\"\"\"\n        buf: List[RowTuple] = []\n        inserted = 0\n\n        for row in rows:\n            buf.append(row)\n            if len(buf) >= chunk_size:\n                inserted += await self._flush(session, buf)\n                buf.clear()\n\n        if buf:\n            inserted += await self._flush(session, buf)\n\n        return inserted\n\n    async def _flush(self, session: AsyncSession, rows: List[RowTuple]) -> int:\n        \"\"\"Запись одного чанка + commit.\"\"\"\n        stmt = (\n            pg_insert(Item)\n            .values([{\"code\": c, \"name\": n, \"unit\": u, \"type\": t} for (c, n, u, t) in rows])\n            .on_conflict_do_nothing(index_elements=[Item.code])\n        )\n        await session.execute(stmt)\n        await session.commit()\n        return len(rows)\n\n    async def fetch_all_item_ids_and_names(self, session: AsyncSession) -> List[Tuple[int, str]]:\n        \"\"\"Список (id, name) для индексации/матчинга.\"\"\"\n        res = await session.execute(select(Item.id, Item.name).order_by(Item.id))\n        return [(int(i), str(n)) for (i, n) in res.all()]\n\n    async def fetch_item_name_unit_by_id(\n        self,\n        session: AsyncSession,\n        item_id: int,\n    ) -> Optional[Tuple[str, Optional[str]]]:\n        \"\"\"(name, unit) по id.\"\"\"\n        res = await session.execute(select(Item.name, Item.unit).where(Item.id == int(item_id)))\n        row = res.first()\n        return (str(row[0]), row[1]) if row else None\n\n    async def fetch_item_name_unit_code_by_id(\n        self,\n        session: AsyncSession,\n        item_id: int,\n    ) -> Optional[Tuple[str, Optional[str], Optional[str]]]:\n        \"\"\"(name, unit, code) по id.\"\"\"\n        res = await session.execute(select(Item.name, Item.unit, Item.code).where(Item.id == int(item_id)))\n        row = res.first()\n        return (str(row[0]), row[1], row[2]) if row else None\n\n    async def fetch_item_codes(\n        self,\n        session: AsyncSession,\n        item_ids: Sequence[int],\n    ) -> Dict[int, Optional[str]]:\n        \"\"\"Мапа id->code.\"\"\"\n        if not item_ids:\n            return {}\n\n        ids = sorted({int(i) for i in item_ids if i is not None})\n        if not ids:\n            return {}\n\n        res = await session.execute(select(Item.id, Item.code).where(Item.id.in_(ids)))\n        return {int(i): (c if c is not None else None) for (i, c) in res.all()}\n\n    async def fetch_items_meta_by_ids(\n        self,\n        session: AsyncSession,\n        item_ids: Sequence[int],\n    ) -> Dict[int, Tuple[str, Optional[str], Optional[str]]]:\n        \"\"\"Батч: id -> (name, unit, code).\"\"\"\n        if not item_ids:\n            return {}\n\n        ids = sorted({int(i) for i in item_ids if i is not None})\n        if not ids:\n            return {}\n\n        res = await session.execute(\n            select(Item.id, Item.name, Item.unit, Item.code).where(Item.id.in_(ids))\n        )\n\n        out: Dict[int, Tuple[str, Optional[str], Optional[str]]] = {}\n        for item_id, name, unit, code in res.all():\n            out[int(item_id)] = (\n                str(name),\n                unit if unit is not None else None,\n                code if code is not None else None,\n            )\n        return out\n\n    async def search_items(\n            self,\n            session: AsyncSession,\n            *,\n            query: str,\n            limit: int = 20,\n    ) -> List[Item]:\n        \"\"\"\n        Быстрый поиск items для UI (dropdown/AJAX).\n\n        Ищем по:\n          - code ILIKE %q%\n          - name ILIKE %q%\n\n        Сортируем так, чтобы совпадения по code были выше,\n        а дальше — по code (стабильно).\n        \"\"\"\n        q = (query or \"\").strip()\n        if len(q) < 2:\n            return []\n\n        like = f\"%{q}%\"\n        stmt = (\n            select(Item)\n            .where(or_(Item.code.ilike(like), Item.name.ilike(like)))\n            .order_by(\n                case((Item.code.ilike(like), 0), else_=1),\n                Item.code.asc(),\n                Item.id.asc(),\n            )\n            .limit(int(limit))\n        )\n\n        res = await session.execute(stmt)\n        return list(res.scalars().all())"
    },
    {
      "path": "src/crud/permission_repository.py",
      "language": "python",
      "size_bytes": 3008,
      "sha256": "3668571ada600a30526f2eb188ce73eec7cf7738028d141926aba7d45e43ec1c",
      "content": "# path: src/crud/permission_repository.py\nfrom __future__ import annotations\n\nfrom typing import Optional, Protocol, Sequence\n\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.core.models.permission import Permission\nfrom src.core.models.profile import Profile\n\n\nclass IPermissionRepository(Protocol):\n    \"\"\"\n    DI-контракт для PermissionRepository.\n\n    Важно:\n    - Здесь только SQL к таблицам permission/profile.\n    - Админка будет использовать эти методы вместо прямых select().\n    \"\"\"\n\n    async def list_for_profile(self, session: AsyncSession, profile_id: int) -> Sequence[Permission]: ...\n\n    async def get_by_profile_id(self, session: AsyncSession, profile_id: int) -> Optional[Permission]: ...\n\n    async def get_for_user_id(self, session: AsyncSession, user_id: int) -> Optional[Permission]: ...\n\n    async def is_admin_user(self, session: AsyncSession, user_id: int) -> bool: ...\n\n    async def is_superadmin_user(self, session: AsyncSession, user_id: int) -> bool: ...\n\n\nclass PermissionRepository(IPermissionRepository):\n    \"\"\"\n    Реализация репозитория Permission.\n\n    Почему join через Profile:\n    - Permission привязан к Profile (profile_id)\n    - Profile привязан к User (user_id)\n    => можем получить Permission по user_id одним запросом.\n    \"\"\"\n\n    async def list_for_profile(self, session: AsyncSession, profile_id: int) -> Sequence[Permission]:\n        res = await session.execute(\n            select(Permission).where(Permission.profile_id == int(profile_id))\n        )\n        return list(res.scalars())\n\n    async def get_by_profile_id(self, session: AsyncSession, profile_id: int) -> Optional[Permission]:\n        res = await session.execute(\n            select(Permission).where(Permission.profile_id == int(profile_id))\n        )\n        return res.scalar_one_or_none()\n\n    async def get_for_user_id(self, session: AsyncSession, user_id: int) -> Optional[Permission]:\n        \"\"\"\n        Возвращает Permission для пользователя по user_id одним запросом:\n        Permission JOIN Profile ON Permission.profile_id = Profile.id WHERE Profile.user_id = :user_id\n        \"\"\"\n        stmt = (\n            select(Permission)\n            .join(Profile, Permission.profile_id == Profile.id)\n            .where(Profile.user_id == int(user_id))\n        )\n        res = await session.execute(stmt)\n        return res.scalar_one_or_none()\n\n    async def is_admin_user(self, session: AsyncSession, user_id: int) -> bool:\n        perm = await self.get_for_user_id(session, user_id)\n        return bool(perm and (perm.is_superadmin or perm.is_admin))\n\n    async def is_superadmin_user(self, session: AsyncSession, user_id: int) -> bool:\n        perm = await self.get_for_user_id(session, user_id)\n        return bool(perm and perm.is_superadmin)\n"
    },
    {
      "path": "src/crud/profile_repository.py",
      "language": "python",
      "size_bytes": 1467,
      "sha256": "86c0368cb372d6e60e3d827735984b3575687d33c90c8abc5f21c9a4cde1d09e",
      "content": "# /src/crud/profile_repository.py\nfrom __future__ import annotations\n\nfrom typing import Protocol, Optional, Sequence\n\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.core.models.profile import Profile\nfrom src.core.models.permission import Permission\n\n\nclass IProfileRepository(Protocol):\n    async def get_by_id(self, session: AsyncSession, profile_id: int) -> Optional[Profile]: ...\n    async def get_by_user_id(self, session: AsyncSession, user_id: int) -> Optional[Profile]: ...\n    async def create_with_defaults(self, session: AsyncSession, *, user_id: int, email: str) -> Profile: ...\n\n\nclass ProfileRepository(IProfileRepository):\n    async def get_by_id(self, session: AsyncSession, profile_id: int) -> Optional[Profile]:\n        res = await session.execute(select(Profile).where(Profile.id == profile_id))\n        return res.scalar_one_or_none()\n\n    async def get_by_user_id(self, session: AsyncSession, user_id: int) -> Optional[Profile]:\n        res = await session.execute(select(Profile).where(Profile.user_id == user_id))\n        return res.scalar_one_or_none()\n\n    async def create_with_defaults(self, session: AsyncSession, *, user_id: int, email: str) -> Profile:\n        profile = Profile(user_id=user_id, email=email, verification=False)\n        profile.permissions = [Permission(is_user=True)]  # базовый флаг\n        session.add(profile)\n        await session.flush()\n        return profile\n"
    },
    {
      "path": "src/crud/user_repository.py",
      "language": "python",
      "size_bytes": 8013,
      "sha256": "fa3e07506261ae3c678d1e10c63e47421a7701eca5981da82423aea7ff8ab2f1",
      "content": "# path: src/crud/user_repository.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Optional, Protocol, Sequence, Any\n\nfrom sqlalchemy import select, update\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.orm import selectinload\n\nfrom src.app_logging import get_logger\nfrom src.core.models import Permission, Profile, User\n\n\nlog = get_logger(\"repo.user\")\n\n\nclass IUserRepository(Protocol):\n    # --- Users ---\n    async def get_by_id(self, session: AsyncSession, *, user_id: int) -> Optional[User]: ...\n    async def get_by_email(self, session: AsyncSession, *, email: str) -> Optional[User]: ...\n    async def get_by_username(self, session: AsyncSession, *, username: str) -> Optional[User]: ...\n    async def get_by_email_with_related(self, session: AsyncSession, *, email: str) -> Optional[User]: ...\n\n    async def create_user_with_profile_and_permission(\n        self,\n        session: AsyncSession,\n        *,\n        email: str,\n        hashed_password: str,\n    ) -> User: ...\n\n    async def update_user_fields(self, session: AsyncSession, *, user_id: int, **fields: Any) -> None: ...\n\n    # --- Profiles ---\n    async def get_profile_by_user_id(self, session: AsyncSession, *, user_id: int) -> Optional[Profile]: ...\n    async def update_profile(self, session: AsyncSession, *, profile_id: int, **fields: Any) -> None: ...\n\n    # --- Permissions ---\n    async def get_permission_by_profile_id(self, session: AsyncSession, *, profile_id: int) -> Optional[Permission]: ...\n    async def create_permission(self, session: AsyncSession, *, profile_id: int, **flags: Any) -> Permission: ...\n    async def update_permission(self, session: AsyncSession, *, permission_id: int, **flags: Any) -> None: ...\n\n    # --- Auth-related updates ---\n    async def set_activation_token(\n        self,\n        session: AsyncSession,\n        *,\n        user_id: int,\n        activation_key: str,\n        activation_sent_at: datetime,\n    ) -> None: ...\n\n    async def mark_email_verified_and_clear_token(\n        self,\n        session: AsyncSession,\n        *,\n        user_id: int,\n    ) -> None: ...\n\n    # --- Lists ---\n    async def list_users(self, session: AsyncSession) -> Sequence[User]: ...\n\n\nclass UserRepository(IUserRepository):\n    \"\"\"\n    Репозиторий пользователей.\n\n    Правило проекта:\n    - Все обращения к Postgres/SQLAlchemy — только здесь (src/crud/).\n    \"\"\"\n\n    # --- Users ---\n\n    async def get_by_id(self, session: AsyncSession, *, user_id: int) -> Optional[User]:\n        \"\"\"\n        Получить пользователя по id.\n        Нужен для admin views (замена session.get(User, id)).\n        \"\"\"\n        res = await session.execute(select(User).where(User.id == int(user_id)))\n        return res.scalar_one_or_none()\n\n    async def get_by_email(self, session: AsyncSession, *, email: str) -> Optional[User]:\n        log.info({\"event\": \"get_by_email\", \"email\": email})\n        stmt = select(User).where(User.email == email)\n        return (await session.execute(stmt)).scalar_one_or_none()\n\n    async def get_by_username(self, session: AsyncSession, *, username: str) -> Optional[User]:\n        \"\"\"\n        Получить пользователя по username.\n        Нужно для admin/login.\n        \"\"\"\n        username = (username or \"\").strip()\n        if not username:\n            return None\n        res = await session.execute(select(User).where(User.username == username))\n        return res.scalar_one_or_none()\n\n    async def get_by_email_with_related(self, session: AsyncSession, *, email: str) -> Optional[User]:\n        log.info({\"event\": \"get_by_email_with_related\", \"email\": email})\n        stmt = (\n            select(User)\n            .where(User.email == email)\n            .options(selectinload(User.profile).selectinload(Profile.permissions))\n        )\n        return (await session.execute(stmt)).scalar_one_or_none()\n\n    async def create_user_with_profile_and_permission(\n        self,\n        session: AsyncSession,\n        *,\n        email: str,\n        hashed_password: str,\n    ) -> User:\n        log.info({\"event\": \"create_user_start\", \"email\": email})\n\n        user = User(email=email, hashed_password=hashed_password, is_active=True)\n        session.add(user)\n        await session.flush()\n\n        profile = Profile(user_id=user.id, email=email, verification=False)\n        session.add(profile)\n        await session.flush()\n\n        perm = Permission(\n            profile_id=profile.id,\n            is_superadmin=False,\n            is_admin=False,\n            is_staff=False,\n            is_updater=False,\n            is_reader=False,\n            is_user=True,\n        )\n        session.add(perm)\n        await session.flush()\n\n        log.info({\"event\": \"create_user_done\", \"user_id\": user.id})\n        return user\n\n    async def update_user_fields(self, session: AsyncSession, *, user_id: int, **fields: Any) -> None:\n        \"\"\"\n        Универсальное обновление полей User.\n        Нужен для admin edit User (замена update(User) из view).\n        \"\"\"\n        if not fields:\n            return\n        await session.execute(\n            update(User)\n            .where(User.id == int(user_id))\n            .values(**fields)\n        )\n\n    # --- Profiles ---\n\n    async def get_profile_by_user_id(self, session: AsyncSession, *, user_id: int) -> Optional[Profile]:\n        stmt = select(Profile).where(Profile.user_id == int(user_id))\n        return (await session.execute(stmt)).scalar_one_or_none()\n\n    async def update_profile(self, session: AsyncSession, *, profile_id: int, **fields: Any) -> None:\n        if not fields:\n            return\n        await session.execute(update(Profile).where(Profile.id == int(profile_id)).values(**fields))\n\n    # --- Permissions ---\n\n    async def get_permission_by_profile_id(\n        self, session: AsyncSession, *, profile_id: int\n    ) -> Optional[Permission]:\n        stmt = select(Permission).where(Permission.profile_id == int(profile_id))\n        return (await session.execute(stmt)).scalar_one_or_none()\n\n    async def create_permission(self, session: AsyncSession, *, profile_id: int, **flags: Any) -> Permission:\n        perm = Permission(profile_id=profile_id, **flags)\n        session.add(perm)\n        await session.flush()\n        log.info({\"event\": \"permission_create\", \"profile_id\": profile_id, \"flags\": list(flags.keys())})\n        return perm\n\n    async def update_permission(self, session: AsyncSession, *, permission_id: int, **flags: Any) -> None:\n        if not flags:\n            return\n        await session.execute(update(Permission).where(Permission.id == int(permission_id)).values(**flags))\n        log.info({\"event\": \"permission_update\", \"permission_id\": permission_id, \"flags\": list(flags.keys())})\n\n    # --- Auth-related updates ---\n\n    async def set_activation_token(\n        self,\n        session: AsyncSession,\n        *,\n        user_id: int,\n        activation_key: str,\n        activation_sent_at: datetime,\n    ) -> None:\n        await session.execute(\n            update(User)\n            .where(User.id == int(user_id))\n            .values(activation_key=activation_key, activation_sent_at=activation_sent_at)\n        )\n\n    async def mark_email_verified_and_clear_token(self, session: AsyncSession, *, user_id: int) -> None:\n        await session.execute(\n            update(Profile)\n            .where(Profile.user_id == int(user_id))\n            .values(verification=True)\n        )\n        await session.execute(\n            update(User)\n            .where(User.id == int(user_id))\n            .values(activation_key=None)\n        )\n\n    # --- Lists ---\n\n    async def list_users(self, session: AsyncSession) -> Sequence[User]:\n        log.info({\"event\": \"list_users\"})\n        res = await session.execute(select(User).order_by(User.id.desc()))\n        return list(res.scalars())\n"
    },
    {
      "path": "src/fsnb_matcher/__init__.py",
      "language": "python",
      "size_bytes": 66,
      "sha256": "fbf70d1845c74aad04dcd42384f88fc186bdff93366a8808278c994a759c1098",
      "content": "# src/fsnb_matcher/__init__.py\nfrom __future__ import annotations\n"
    },
    {
      "path": "src/fsnb_matcher/api/__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "src/fsnb_matcher/api/api_v1/__init__.py",
      "language": "python",
      "size_bytes": 244,
      "sha256": "18c52f714edf47530fbc0e1ce6d2fd7491901401f2824633a23cd639991f78e1",
      "content": "# src/fsnb_matcher/api/api_v1/__init__.py\nfrom __future__ import annotations\nfrom fastapi import APIRouter\nfrom .match import router as match_router\n\nrouter = APIRouter()\nrouter.include_router(match_router, prefix=\"/fsnb\", tags=[\"fsnb-match\"])\n"
    },
    {
      "path": "src/fsnb_matcher/api/api_v1/deps.py",
      "language": "python",
      "size_bytes": 785,
      "sha256": "2b4bad3136301cc7fc6a5bd7fae0e86a72224db8d9957e27a018ab8e92c0bd5f",
      "content": "# path: src/fsnb_matcher/api/api_v1/deps.py\nfrom __future__ import annotations\n\nfrom functools import lru_cache\n\nfrom src.crud.item_repository import IItemRepository, ItemRepository\n\n\n@lru_cache(maxsize=1)\ndef _repo_singleton() -> ItemRepository:\n    \"\"\"\n    Singleton репозитория.\n\n    Почему:\n    - репозиторий сам по себе статeless, держать один экземпляр безопасно;\n    - экономим лишние аллокации.\n    \"\"\"\n    return ItemRepository()\n\n\ndef get_item_repository() -> IItemRepository:\n    \"\"\"\n    FastAPI Depends-провайдер.\n\n    Возвращаем интерфейс (IItemRepository), чтобы соблюсти твой DI-паттерн.\n    \"\"\"\n    return _repo_singleton()\n"
    },
    {
      "path": "src/fsnb_matcher/api/api_v1/match.py",
      "language": "python",
      "size_bytes": 2136,
      "sha256": "df0c85fab623b9cb3a74e2c60e69788b8caf43932ec9dacbf3e8bd686d500e5e",
      "content": "# path: src/fsnb_matcher/api/api_v1/match.py\nfrom __future__ import annotations\n\nimport json\n\nfrom fastapi import APIRouter, Depends, File, HTTPException, Request, UploadFile\nfrom fastapi.responses import Response\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.core.models.db_helper import db_helper\nfrom src.crud.item_repository import IItemRepository\nfrom src.fsnb_matcher.api.api_v1.deps import get_item_repository\nfrom src.fsnb_matcher.services.matcher_service import build_match_xlsx\n\n\nrouter = APIRouter()\n\n\ndef _ensure_auth(request: Request) -> None:\n    \"\"\"\n    Проверяем, что пользователь залогинен.\n\n    Логика как была: используем session middleware, где кладутся access_token и user_email.\n    \"\"\"\n    if not (request.session.get(\"access_token\") and request.session.get(\"user_email\")):\n        raise HTTPException(status_code=401, detail=\"Auth required\")\n\n\n@router.post(\"/match\", name=\"fsnb_match_process\")\nasync def fsnb_match_process(\n    request: Request,\n    file: UploadFile = File(...),\n    session: AsyncSession = Depends(db_helper.session_getter),\n    item_repo: IItemRepository = Depends(get_item_repository),\n) -> Response:\n    \"\"\"\n    Принимаем JSON-файл и возвращаем xlsx.\n\n    DI-правило:\n    - session даёт db_helper через Depends\n    - item_repo даёт get_item_repository (интерфейс + реализация в crud)\n    - build_match_xlsx вызываем с session и repo\n    \"\"\"\n    _ensure_auth(request)\n\n    raw = await file.read()\n    try:\n        payload = json.loads(raw.decode(\"utf-8\"))\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=f\"Invalid JSON: {e}\")\n\n    try:\n        xlsx = await build_match_xlsx(session, item_repo, payload)\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n\n    return Response(\n        content=xlsx,\n        media_type=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n        headers={\"Content-Disposition\": 'attachment; filename=\"smeta.xlsx\"'},\n    )\n"
    },
    {
      "path": "src/fsnb_matcher/embeddings/__init__.py",
      "language": "python",
      "size_bytes": 100,
      "sha256": "3185ea0231460ed133cae7056e1aacce8acbb294180c935f09bc9072555c7416",
      "content": "# file: src/fsnb_matcher/embeddings/__init__.py\nfrom . import model_giga as GIGA\n\n__all__ = [\"GIGA\"]"
    },
    {
      "path": "src/fsnb_matcher/embeddings/model_giga.py",
      "language": "python",
      "size_bytes": 3517,
      "sha256": "c2b3e82e3271d8be84cdaecc6f69987363a41ba15f6d9aa03ca7e3976998b66a",
      "content": "from __future__ import annotations\n\nfrom functools import lru_cache\nfrom pathlib import Path\nfrom typing import List\nimport threading\n\nimport torch\nfrom sentence_transformers import SentenceTransformer\n\nfrom src.core.config import settings\n\nINSTRUCT_QUERY = \"Instruct: Given a database query, retrieve relevant FSNB entries\\nQuery: \"\n\n\ndef _fsnb_dir(path_str: str) -> Path:\n    # paths в конфиге у тебя строки — приводим к Path относительно /app\n    p = Path(path_str)\n    if p.is_absolute():\n        return p\n    return (Path(\"/app\") / p).resolve()\n\n\n@lru_cache()\ndef _gpu_sem() -> threading.Semaphore:\n    slots = int(getattr(settings.fsnb, \"gpu_slots\", 1) or 1)\n    return threading.Semaphore(max(1, slots))\n\n\ndef _device() -> str:\n    dev = getattr(settings.fsnb, \"hf_embed_device\", \"auto\")\n    if dev == \"auto\":\n        return \"cuda\" if torch.cuda.is_available() else \"cpu\"\n    return dev\n\n\ndef _use_fp16() -> bool:\n    return bool(getattr(settings.fsnb, \"hf_embed_fp16\", True))\n\n\ndef _dtype():\n    if _use_fp16() and _device().startswith(\"cuda\"):\n        return torch.float16\n    return torch.float32\n\n\n@lru_cache()\ndef get() -> SentenceTransformer:\n    model_dir = _fsnb_dir(settings.fsnb.model_giga_dir)\n    model_path = str(model_dir)\n\n    # ВАЖНО: trust_remote_code нужен для Giga\n    model = SentenceTransformer(\n        model_path,\n        device=_device(),\n        trust_remote_code=True,\n        model_kwargs={\"torch_dtype\": _dtype()},\n    )\n    model.eval()\n    return model\n\n\ndef dim() -> int:\n    return int(get().get_sentence_embedding_dimension())\n\n\ndef _encode_impl(texts: List[str], batch_size: int) -> List[List[float]]:\n    dev = _device()\n    if dev.startswith(\"cuda\"):\n        with torch.inference_mode(), torch.amp.autocast(\"cuda\", dtype=_dtype()):\n            embs = get().encode(\n                texts,\n                batch_size=batch_size,\n                convert_to_numpy=True,\n                normalize_embeddings=False,\n                show_progress_bar=False,\n            )\n            torch.cuda.synchronize()\n    else:\n        with torch.inference_mode():\n            embs = get().encode(\n                texts,\n                batch_size=batch_size,\n                convert_to_numpy=True,\n                normalize_embeddings=False,\n                show_progress_bar=False,\n            )\n    return embs.tolist()\n\n\ndef encode(texts: List[str], *, is_query: bool, batch_size: int | None = None) -> List[List[float]]:\n    if batch_size is None:\n        if is_query:\n            batch_size = int(getattr(settings.fsnb, \"giga_query_bs\", 2))\n        else:\n            batch_size = int(getattr(settings.fsnb, \"giga_index_bs\", getattr(settings.fsnb, \"embed_batch_size\", 128)))\n\n    if is_query:\n        texts = [INSTRUCT_QUERY + (t or \"\") for t in texts]\n\n    sem = _gpu_sem()\n    sem.acquire()\n    try:\n        return _encode_impl(texts, batch_size=batch_size)\n    finally:\n        sem.release()\n\n\ndef unload() -> None:\n    try:\n        get.cache_clear()\n    except Exception:\n        pass\n    if torch.cuda.is_available() and _device().startswith(\"cuda\"):\n        torch.cuda.empty_cache()\n\ndef embed_texts(texts: list[str], *, is_query: bool = False, batch_size: int | None = None) -> list[list[float]]:\n    \"\"\"\n    Backward-compatible alias.\n    Старый код ожидает embed_texts(), а новый модуль использует encode().\n    \"\"\"\n    return encode(texts, is_query=is_query, batch_size=batch_size)\n"
    },
    {
      "path": "src/fsnb_matcher/models/__init__.py",
      "language": "python",
      "size_bytes": 89,
      "sha256": "de82ba3d2b571924a931e25fb4cfa5ada34b146107cfe5ffe95781b394570989",
      "content": "# src/fsnb_matcher/models/__init__.py\n\n__all__ = (\n    \"Item\",\n)\n\nfrom .item import Item\n"
    },
    {
      "path": "src/fsnb_matcher/models/item.py",
      "language": "python",
      "size_bytes": 784,
      "sha256": "7b2c8c9ac052a5b6c638b0db739d6612599ab83b88f5f1e0d93b1440136857f6",
      "content": "# src/fsnb_matcher/models/item.py\nfrom __future__ import annotations\nfrom sqlalchemy import Column, Integer, Text, CheckConstraint, UniqueConstraint\nfrom src.core.models.base import Base  # общий Base\n\nclass Item(Base):\n    __tablename__ = \"items\"\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    code = Column(Text, unique=True, index=True)       # шифр ФСНБ\n    name = Column(Text, nullable=False, index=True)    # наименование\n    unit = Column(Text)                                # ед.изм.\n    type = Column(Text, nullable=False)                # 'work'|'resource'\n\n    __table_args__ = (\n        UniqueConstraint(\"code\", name=\"uq_items_code\"),\n        CheckConstraint(\"type IN ('work','resource')\", name=\"chk_items_type\"),\n    )\n"
    },
    {
      "path": "src/fsnb_matcher/schemas/__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "src/fsnb_matcher/schemas/item.py",
      "language": "python",
      "size_bytes": 211,
      "sha256": "0a9eb93929216e2b792e6203a6f83d0540adcfd655dabbcd0bde9230b3974b66",
      "content": "# src/fsnb_matcher/schemas/item.py\nfrom __future__ import annotations\nfrom pydantic import BaseModel\n\nclass ItemMeta(BaseModel):\n    id: int\n    code: str | None\n    name: str\n    unit: str | None\n    type: str\n"
    },
    {
      "path": "src/fsnb_matcher/services/__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "src/fsnb_matcher/services/fsnb_xml_parser.py",
      "language": "python",
      "size_bytes": 3928,
      "sha256": "e45be72104213c3571eb9a5b13ac58d0699ee1b16fce7f6a186d3948cbbdb649",
      "content": "from __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import Iterator, Optional, Tuple\n\nfrom lxml import etree\n\nRowTuple = Tuple[str, str, Optional[str], str]  # (code, name, unit, type)\n\n\ndef iter_items_from_fsnb_xml(fsnb_dir: str | Path) -> Iterator[RowTuple]:\n    \"\"\"\n    Потоковый парсер FSNB-2022 XML: отдаёт плоскую витрину items:\n      - work:  Work(Code, EndName, MeasureUnit) + BeginName из NameGroup\n      - resource: ResourceCatalog -> Resource(Code, Name, MeasureUnit)\n\n    fsnb_dir: директория с *.xml\n    \"\"\"\n    fsnb_dir = Path(fsnb_dir)\n    if not fsnb_dir.exists():\n        raise FileNotFoundError(f\"FSNB dir not found: {fsnb_dir}\")\n\n    xml_files = sorted([p for p in fsnb_dir.iterdir() if p.is_file() and p.suffix.lower() == \".xml\"])\n    if not xml_files:\n        raise FileNotFoundError(f\"No .xml files in: {fsnb_dir}\")\n\n    for xml_path in xml_files:\n        # Бывает много служебных файлов — просто пропускаем те, что не похожи\n        # на base / ResourceCatalog.\n        try:\n            # Считываем только корневой тег\n            for _, root in etree.iterparse(str(xml_path), events=(\"start\",), recover=True, huge_tree=True):\n                root_tag = root.tag\n                break\n            else:\n                continue\n        except Exception:\n            continue\n\n        if root_tag == \"base\":\n            yield from _iter_items_from_base(xml_path)\n        elif root_tag == \"ResourceCatalog\":\n            yield from _iter_items_from_resource_catalog(xml_path)\n        else:\n            continue\n\n\ndef _iter_items_from_base(xml_path: Path) -> Iterator[RowTuple]:\n    \"\"\"\n    base -> ... NameGroup(BeginName) -> Work(Code, EndName, MeasureUnit)\n    \"\"\"\n    begin_name_stack: list[Optional[str]] = []\n    in_name_group = 0\n\n    context = etree.iterparse(\n        str(xml_path),\n        events=(\"start\", \"end\"),\n        recover=True,\n        huge_tree=True,\n    )\n\n    for event, el in context:\n        tag = el.tag\n\n        if event == \"start\" and tag == \"NameGroup\":\n            in_name_group += 1\n            begin = (el.get(\"BeginName\") or \"\").strip() or None\n            begin_name_stack.append(begin)\n\n        elif event == \"end\" and tag == \"Work\":\n            code = (el.get(\"Code\") or \"\").strip()\n            end_name = (el.get(\"EndName\") or \"\").strip()\n            unit = (el.get(\"MeasureUnit\") or \"\").strip() or None\n\n            if code and end_name:\n                begin = begin_name_stack[-1] if begin_name_stack else None\n                full_name = f\"{begin} {end_name}\".strip() if begin else end_name\n                yield (code, full_name, unit, \"work\")\n\n            # освобождаем память\n            el.clear()\n            while el.getprevious() is not None:\n                del el.getparent()[0]\n\n        elif event == \"end\" and tag == \"NameGroup\":\n            if in_name_group > 0:\n                in_name_group -= 1\n            if begin_name_stack:\n                begin_name_stack.pop()\n            el.clear()\n            while el.getprevious() is not None:\n                del el.getparent()[0]\n\n\ndef _iter_items_from_resource_catalog(xml_path: Path) -> Iterator[RowTuple]:\n    \"\"\"\n    ResourceCatalog -> ... Section -> Resource(Code, Name, MeasureUnit)\n    \"\"\"\n    context = etree.iterparse(\n        str(xml_path),\n        events=(\"end\",),\n        recover=True,\n        huge_tree=True,\n    )\n\n    for _, el in context:\n        if el.tag != \"Resource\":\n            continue\n\n        code = (el.get(\"Code\") or \"\").strip()\n        name = (el.get(\"Name\") or \"\").strip()\n        unit = (el.get(\"MeasureUnit\") or \"\").strip() or None\n\n        if code and name:\n            yield (code, name, unit, \"resource\")\n\n        el.clear()\n        while el.getprevious() is not None:\n            del el.getparent()[0]\n"
    },
    {
      "path": "src/fsnb_matcher/services/index_qdrant.py",
      "language": "python",
      "size_bytes": 3850,
      "sha256": "0d9482d36f415c72ef8b49d6e3a89736c3f4fe59fb9d50b17cb54a32e5eed685",
      "content": "# path: src/fsnb_matcher/services/index_qdrant.py\nfrom __future__ import annotations\n\nimport asyncio\nfrom typing import List\n\nfrom qdrant_client.models import Distance, PointStruct, VectorParams\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.app_logging import get_logger\nfrom src.core.config import settings\nfrom src.core.models.db_helper import db_helper\nfrom src.crud.item_repository import IItemRepository, ItemRepository\nfrom src.fsnb_matcher.embeddings import model_giga\nfrom src.fsnb_matcher.services.qdr import get_qdrant_client\n\n\nlogger = get_logger(__name__)\n\n\ndef _get_collection_name() -> str:\n    \"\"\"\n    Единый источник имени коллекции.\n    Должно совпадать с matcher_service.\n    \"\"\"\n    name = getattr(settings.fsnb, \"qdrant_collection\", None)\n    if isinstance(name, str) and name.strip():\n        return name.strip()\n    return \"fsnb_giga\"\n\n\nasync def init_all_collections(\n    session: AsyncSession,\n    item_repo: IItemRepository,\n) -> int:\n    \"\"\"\n    Создаёт коллекцию в Qdrant и заливает туда эмбеддинги (Giga) для всех items из Postgres.\n    Возвращает количество залитых точек.\n\n    Важно:\n    - Postgres читаем потоково через item_repo.iter_for_index(), чтобы не держать всё в памяти.\n    - encode()/upsert() синхронные → выносим в asyncio.to_thread.\n    \"\"\"\n    client = get_qdrant_client()\n    collection_name = _get_collection_name()\n\n    dim = int(model_giga.dim())\n    batch_size = int(settings.fsnb.giga_index_bs)\n\n    client.recreate_collection(\n        collection_name=collection_name,\n        vectors_config=VectorParams(size=dim, distance=Distance.COSINE),\n    )\n    logger.info(\"qdrant_collection_recreated\", extra={\"collection\": collection_name, \"dim\": dim})\n\n    done = 0\n    ids_batch: List[int] = []\n    texts_batch: List[str] = []\n\n    async for item_id, name, _code, _unit, _type in item_repo.iter_for_index(session, yield_per=2000):\n        ids_batch.append(int(item_id))\n        texts_batch.append(str(name))\n\n        if len(ids_batch) < batch_size:\n            continue\n\n        vectors = await asyncio.to_thread(model_giga.encode, texts_batch, False, len(texts_batch))\n        if hasattr(vectors, \"tolist\"):\n            vectors = vectors.tolist()\n\n        points = [\n            PointStruct(id=int(pid), vector=vec, payload={\"name\": texts_batch[idx]})\n            for idx, (pid, vec) in enumerate(zip(ids_batch, vectors))\n        ]\n\n        await asyncio.to_thread(client.upsert, collection_name, points, False)\n        done += len(points)\n\n        if done % 1000 < batch_size:\n            logger.info(\"qdrant_upsert_progress\", extra={\"done\": done})\n\n        ids_batch.clear()\n        texts_batch.clear()\n\n    # добиваем хвост\n    if ids_batch:\n        vectors = await asyncio.to_thread(model_giga.encode, texts_batch, False, len(texts_batch))\n        if hasattr(vectors, \"tolist\"):\n            vectors = vectors.tolist()\n\n        points = [\n            PointStruct(id=int(pid), vector=vec, payload={\"name\": texts_batch[idx]})\n            for idx, (pid, vec) in enumerate(zip(ids_batch, vectors))\n        ]\n        await asyncio.to_thread(client.upsert, collection_name, points, False)\n        done += len(points)\n\n    logger.info(\"qdrant_upsert_done\", extra={\"collection\": collection_name, \"count\": done})\n    return done\n\n\nasync def init_all_collections_entrypoint() -> int:\n    \"\"\"\n    Точка входа для CLI.\n    Здесь допустимо создать session/repo (это обвязка).\n    \"\"\"\n    item_repo: IItemRepository = ItemRepository()\n\n    async with db_helper.session_factory() as session:\n        return await init_all_collections(session, item_repo)\n"
    },
    {
      "path": "src/fsnb_matcher/services/ingest.py",
      "language": "python",
      "size_bytes": 1115,
      "sha256": "349e3a62910072882c323e3e59a69c8acf00d50fab1b515cff242941627473d1",
      "content": "# path: src/fsnb_matcher/services/ingest.py\nfrom __future__ import annotations\n\nfrom pathlib import Path\n\nfrom src.core.config import settings\nfrom src.core.models.db_helper import db_helper\nfrom src.crud.item_repository import IItemRepository, ItemRepository\nfrom src.fsnb_matcher.services.fsnb_xml_parser import iter_items_from_fsnb_xml\n\n\nasync def ingest_to_postgres() -> int:\n    \"\"\"\n    Импорт ФСНБ в Postgres.\n\n    Правила, которые соблюдаем:\n    - настройки берём из src/core/config.py (settings.fsnb.fsnb_dir)\n    - сессию создаём через session_factory() (это НЕ FastAPI Depends-контекст)\n    - БД операции только через репозиторий (src/crud/)\n    \"\"\"\n    fsnb_dir = Path(settings.fsnb.fsnb_dir)\n    inserted_total = 0\n\n    item_repo: IItemRepository = ItemRepository()\n\n    async with db_helper.session_factory() as session:\n        rows = iter_items_from_fsnb_xml(fsnb_dir)\n        inserted_total = await item_repo.bulk_insert_items(session, rows, chunk_size=1000)\n\n    return inserted_total\n"
    },
    {
      "path": "src/fsnb_matcher/services/ingest_items.py",
      "language": "python",
      "size_bytes": 667,
      "sha256": "24fba285c4874f16fb3d97f9a8b73548677f61559d80ba03d7d9f201a711a1af",
      "content": "# path: src/fsnb_matcher/services/ingest_items.py\n\"\"\"\nCLI-утилита: парсит все XML-файлы ФСНБ и вставляет их в таблицу items.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nfrom src.app_logging import get_logger\nfrom src.fsnb_matcher.services.ingest import ingest_to_postgres\n\nlogger = get_logger(__name__)\n\n\nasync def main() -> None:\n    logger.info(\"🚀 [ingest_items] Начинаем загрузку ФСНБ XML...\")\n    count = await ingest_to_postgres()\n    logger.info(f\"✅ [ingest_items] Завершено. Добавлено {count} строк.\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n"
    },
    {
      "path": "src/fsnb_matcher/services/matcher_service.py",
      "language": "python",
      "size_bytes": 7089,
      "sha256": "3f152da510ca1de40899981bf47f3b51062ce95d9f3cbbf86d00a8648123ed34",
      "content": "# path: src/fsnb_matcher/services/matcher_service.py\n\"\"\"\nСервис сопоставления элементов из JSON с базой ФСНБ.\n\nDI-правило:\n- Этот файл НЕ создаёт AsyncSession сам и НЕ делает SQLAlchemy-запросов напрямую.\n- Вся работа с Postgres — через репозиторий из src/crud/.\n- AsyncSession и репозиторий приходят снаружи (через Depends или через CLI-обвязку).\n\nПроизводительность:\n- Embeddings и Qdrant client синхронные → используем asyncio.to_thread.\n- Метаданные из Postgres читаем батчем (без N+1).\n\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport io\nfrom typing import Any, Dict, List, Optional, Tuple\n\nfrom openpyxl import Workbook\nfrom qdrant_client.http import models as qmodels\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.app_logging import get_logger\nfrom src.core.config import settings\nfrom src.crud.item_repository import IItemRepository\nfrom src.fsnb_matcher.embeddings.model_giga import embed_texts\nfrom src.fsnb_matcher.services.qdr import get_qdrant_client\n\n\nlogger = get_logger(__name__)\n\nDEFAULT_COLLECTION_GIGA = \"fsnb_giga\"\n\n\ndef _safe_int(value: Any) -> Optional[int]:\n    \"\"\"Пытается привести value к int, иначе возвращает None.\"\"\"\n    try:\n        return int(value)\n    except (TypeError, ValueError):\n        return None\n\n\ndef _get_collection_name() -> str:\n    \"\"\"\n    Имя коллекции берём из settings.fsnb.qdrant_collection, если оно будет добавлено.\n    Пока оставляем fallback на DEFAULT_COLLECTION_GIGA.\n    \"\"\"\n    name = getattr(settings.fsnb, \"qdrant_collection\", None)\n    if isinstance(name, str) and name.strip():\n        return name.strip()\n    return DEFAULT_COLLECTION_GIGA\n\n\nasync def _embed_captions(captions: List[str]) -> List[List[float]]:\n    \"\"\"Эмбеддинги в отдельном потоке (не блокируем event loop).\"\"\"\n    return await asyncio.to_thread(embed_texts, captions)\n\n\nasync def _qdrant_search(\n    *,\n    collection_name: str,\n    vectors: list[list[float]],\n    top_k: int,\n) -> list[list[Any]]:\n    \"\"\"\n    Qdrant batch search для qdrant-client==1.16.2.\n    Возвращает список результатов (points) на каждый входной вектор.\n    \"\"\"\n    client = get_qdrant_client()\n    batch_size = 64\n\n    def _sync_query() -> list[list[Any]]:\n        all_results: list[list[Any]] = []\n\n        for start in range(0, len(vectors), batch_size):\n            chunk = vectors[start:start + batch_size]\n\n            requests: list[qmodels.QueryRequest] = [\n                qmodels.QueryRequest(\n                    query=vec,\n                    limit=int(top_k),\n                    with_payload=True,\n                    with_vector=False,\n                )\n                for vec in chunk\n            ]\n\n            responses: list[qmodels.QueryResponse] = client.query_batch_points(\n                collection_name=collection_name,\n                requests=requests,\n            )\n\n            all_results.extend([r.points or [] for r in responses])\n\n        return all_results\n\n    return await asyncio.to_thread(_sync_query)\n\n\nasync def match_items(\n    session: AsyncSession,\n    item_repo: IItemRepository,\n    json_items: List[Dict[str, Any]],\n    *,\n    top_k: int = 3,\n) -> List[Dict[str, Any]]:\n    \"\"\"\n    Сопоставляет элементы JSON с коллекцией Qdrant.\n\n    Вход:\n        [{\"Caption\": \"...\", \"Units\": \"...\", \"Quantity\": \"...\", ...}, ...]\n    Выход:\n        добавляет поля:\n        - \"FSNB Name\"\n        - \"FSNB code\"\n        - \"FSNB Units\"\n        - \"conf\"\n    \"\"\"\n    if not json_items:\n        return []\n\n    collection_name = _get_collection_name()\n    captions = [str(i.get(\"Caption\", \"\") or \"\") for i in json_items]\n\n    logger.info(\n        \"Starting match\",\n        extra={\"items\": len(json_items), \"top_k\": int(top_k), \"collection\": collection_name},\n    )\n\n    vectors = await _embed_captions(captions)\n    searches = await _qdrant_search(collection_name=collection_name, vectors=vectors, top_k=top_k)\n\n    # 1) Собираем лучшие item_id и scores по каждой строке\n    best_ids: List[Optional[int]] = []\n    best_scores: List[float] = []\n\n    for found in searches:\n        if not found:\n            best_ids.append(None)\n            best_scores.append(0.0)\n            continue\n\n        best = found[0]\n        best_scores.append(float(getattr(best, \"score\", 0.0)))\n        best_ids.append(_safe_int(getattr(best, \"id\", None)))\n\n    # 2) Батчем забираем метаданные из Postgres через репозиторий (без N+1)\n    ids_to_fetch = [i for i in best_ids if i is not None]\n    meta_map = await item_repo.fetch_items_meta_by_ids(session, ids_to_fetch)\n\n    # 3) Формируем результат\n    results: List[Dict[str, Any]] = []\n\n    for idx, src in enumerate(json_items):\n        item_id = best_ids[idx]\n        score = best_scores[idx]\n\n        if item_id is None or item_id not in meta_map:\n            results.append(\n                {\n                    **src,\n                    \"FSNB Name\": None,\n                    \"FSNB code\": None,\n                    \"FSNB Units\": None,\n                    \"conf\": score,\n                }\n            )\n            continue\n\n        name, unit, code = meta_map[item_id]\n        results.append(\n            {\n                **src,\n                \"FSNB Name\": name,\n                \"FSNB code\": code,\n                \"FSNB Units\": unit,\n                \"conf\": score,\n            }\n        )\n\n    logger.info(\"Match completed\", extra={\"rows\": len(results)})\n    return results\n\n\nasync def build_match_xlsx(\n    session: AsyncSession,\n    item_repo: IItemRepository,\n    payload: Dict[str, Any],\n    *,\n    top_k: int = 3,\n) -> bytes:\n    \"\"\"\n    Строит xlsx и возвращает bytes.\n\n    Важно:\n    - DI: session и item_repo передаются извне (роутером/скриптом).\n    \"\"\"\n    items = payload.get(\"items\", [])\n    if not isinstance(items, list):\n        items = []\n\n    matched = await match_items(session, item_repo, items, top_k=top_k)\n\n    wb = Workbook()\n    ws = wb.active\n    ws.title = \"GIGA\"\n\n    headers = [\n        \"Caption\",\n        \"FSNB Name\",\n        \"FSNB code\",\n        \"Units\",\n        \"FSNB Units\",\n        \"Quantity\",\n        \"conf\",\n    ]\n    ws.append(headers)\n\n    for row in matched:\n        ws.append(\n            [\n                row.get(\"Caption\", \"\"),\n                row.get(\"FSNB Name\"),\n                row.get(\"FSNB code\"),\n                row.get(\"Units\"),\n                row.get(\"FSNB Units\"),\n                row.get(\"Quantity\"),\n                row.get(\"conf\", 0.0),\n            ]\n        )\n\n    buf = io.BytesIO()\n    wb.save(buf)\n    return buf.getvalue()\n"
    },
    {
      "path": "src/fsnb_matcher/services/parser.py",
      "language": "python",
      "size_bytes": 2107,
      "sha256": "f9d4476843e712479c662549d603d42fcd47fae7c873674224bf9577ec0a3862",
      "content": "# src/fsnb_matcher/services/parser.py\nfrom __future__ import annotations\nfrom pathlib import Path\nfrom typing import Iterable\nfrom lxml import etree\n\ndef _list_xml(fsnb_dir: Path) -> list[Path]:\n    files: list[Path] = []\n    for p in fsnb_dir.iterdir():\n        if p.is_file() and p.suffix.lower() == \".xml\":\n            files.append(p)\n    return sorted(files)\n\ndef iter_items(fsnb_dir: Path) -> Iterable[tuple[str, str, str | None, str]]:\n    files = _list_xml(fsnb_dir)\n    print(f\"[INFO] FSNB dir: {fsnb_dir}\")\n    print(f\"[INFO] XML files found: {len(files)}\")\n    for p in files:\n        print(f\"  - {p.name}\")\n\n    for xml_path in files:\n        name_lc = xml_path.name.lower()\n        try:\n            root = etree.parse(str(xml_path)).getroot()\n        except Exception as e:\n            print(f\"[WARN] parse failed: {xml_path.name}: {e}\")\n            continue\n\n        if \"гэсн\" in name_lc:\n            count = 0\n            for el in root.xpath(\".//NameGroup\"):\n                begin = (el.get(\"BeginName\") or \"\").strip()\n                for w in el.xpath(\"./Work\"):\n                    code = (w.get(\"Code\") or \"\").strip()\n                    end = (w.get(\"EndName\") or \"\").strip()\n                    unit = (w.get(\"MeasureUnit\") or \"\").strip() or None\n                    if not code or not end:\n                        continue\n                    full = f\"{begin} {end}\".strip() if begin else end\n                    count += 1\n                    yield (code, full, unit, \"work\")\n            print(f\"[INFO] Parsed {count} works from {xml_path.name}\")\n\n        if \"фсбц\" in name_lc:\n            count = 0\n            for r in root.xpath(\".//Resource[@Code]\"):\n                code = (r.get(\"Code\") or \"\").strip()\n                title = (r.get(\"Name\") or r.get(\"EndName\") or \"\").strip()\n                unit = (r.get(\"MeasureUnit\") or \"\").strip() or None\n                if not code or not title:\n                    continue\n                count += 1\n                yield (code, title, unit, \"resource\")\n            print(f\"[INFO] Parsed {count} resources from {xml_path.name}\")\n"
    },
    {
      "path": "src/fsnb_matcher/services/qdr.py",
      "language": "python",
      "size_bytes": 1507,
      "sha256": "80737ab7229f423d9f8bd000d1508fbc59fcd41413bbe66052b0233ed4687bb5",
      "content": "# path: src/fsnb_matcher/services/qdr.py\n\"\"\"\nУтилиты для подключения и работы с Qdrant.\nИспользуется индексатором и matcher_service.\n\nDI/архитектура:\n- Клиент Qdrant создаём один раз (singleton), чтобы не плодить подключения.\n- Настройки берём из src/core/config.py -> settings.qdrant.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom functools import lru_cache\n\nfrom qdrant_client import QdrantClient\n\nfrom src.app_logging import get_logger\nfrom src.core.config import settings\n\n\nlogger = get_logger(__name__)\n\n\n@lru_cache(maxsize=1)\ndef get_qdrant_client() -> QdrantClient:\n    \"\"\"\n    Singleton QdrantClient.\n\n    Почему singleton:\n    - клиент создаётся тяжеловато (инициализация транспорта/проверки);\n    - matcher_service и индексатор вызывают его много раз;\n    - один экземпляр уменьшает накладные расходы и память.\n    \"\"\"\n    host = settings.qdrant.host\n    port = int(settings.qdrant.port)\n    timeout = int(settings.qdrant.timeout_s)\n\n    logger.info(\n        \"qdrant_client_create\",\n        extra={\"host\": host, \"port\": port, \"timeout_s\": timeout, \"prefer_grpc\": False},\n    )\n\n    return QdrantClient(\n        host=host,\n        port=port,\n        prefer_grpc=False,\n        timeout=timeout,\n        check_compatibility=False,\n    )\n"
    },
    {
      "path": "src/fsnb_matcher/utils/__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "src/fsnb_matcher/views/__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "src/main.py",
      "language": "python",
      "size_bytes": 1718,
      "sha256": "1caf8b7b82a464a36c286cd7bc2a2d3f31f31a0a126a2b9039669da07c96fc3b",
      "content": "# /src/main.py\nfrom __future__ import annotations\n\nfrom contextlib import asynccontextmanager\nfrom pathlib import Path\n\nimport uvicorn\nfrom fastapi import FastAPI\nfrom fastapi.responses import ORJSONResponse\nfrom fastapi.staticfiles import StaticFiles\nfrom starlette.middleware.sessions import SessionMiddleware\n\n# ВАЖНО: относительные импорты внутри пакета base_app\nfrom .core.config import settings\nfrom .core.models import db_helper\nfrom src.core.api import router as api_router\nfrom src.core.views import router as views_router  # HTML-вьюхи (/, /users/)\n\nPROJECT_ROOT = Path(__file__).resolve().parents[1]\nSTATIC_DIR = PROJECT_ROOT / \"static\"\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # startup\n    yield\n    # shutdown\n    await db_helper.dispose()\n\n\ndef create_app() -> FastAPI:\n    app = FastAPI(\n        default_response_class=ORJSONResponse,\n        lifespan=lifespan,\n    )\n    app.add_middleware(\n        SessionMiddleware,\n        secret_key=settings.auth.secret_key,\n        session_cookie=\"fsnb_session\",\n        same_site=\"lax\",\n    )  # <— для session/CSRF\n\n    # /static -> ./static (в корне проекта)\n    app.mount(\"/static\", StaticFiles(directory=str(STATIC_DIR)), name=\"static\")\n\n    # HTML-views и API\n    app.include_router(views_router)\n    app.include_router(api_router)\n    return app\n\n\n# Экспортируемый объект приложения\nmain_app = create_app()\n\n\nif __name__ == \"__main__\":\n    # Запуск: poetry run uvicorn base_app.main:main_app --reload\n    uvicorn.run(\n        \"src.main:main_app\",\n        host=settings.run.host,\n        port=settings.run.port,\n        reload=True,\n    )\n"
    },
    {
      "path": "src/manage.py",
      "language": "python",
      "size_bytes": 1326,
      "sha256": "855c4b5d8d25b2e30f8e5c66167c6cf5d8f75fd3874ef1d131efae199fc68fc1",
      "content": "# /src/manage.py\nfrom __future__ import annotations\n\nimport argparse\nimport asyncio\nfrom getpass import getpass\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.app_logging import get_logger\nfrom src.core.models import db_helper\nfrom src.scripts.superuser import create_superuser\n\nlog = get_logger(\"manage\")\n\n\nasync def _cmd_create_superuser() -> None:\n    print(\"Create superuser\")\n    username = input(\"Username: \").strip()\n    password = getpass(\"Password: \")\n    email = input(\"E-mail (optional): \").strip()\n\n    async with db_helper.session_factory() as session:  # type: AsyncSession\n        uid = await create_superuser(session, username=username, password=password, email=email or None)\n        await session.commit()\n        log.info({\"event\": \"create_superuser_ok\", \"user_id\": uid, \"username\": username})\n        print(f\"✔ Superuser created: id={uid}, username={username}\")\n\n\ndef main(argv: list[str] | None = None) -> None:\n    parser = argparse.ArgumentParser(prog=\"base_app.manage\", description=\"Management commands\")\n    parser.add_argument(\"--create_superuser\", action=\"store_true\", help=\"Create a superuser\")\n    args = parser.parse_args(argv)\n\n    if args.create_superuser:\n        asyncio.run(_cmd_create_superuser())\n    else:\n        parser.print_help()\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "path": "src/scripts/create_fsnb_pg.py",
      "language": "python",
      "size_bytes": 719,
      "sha256": "aedac708f2e6af52e568fcfc1663175e63072de418322b2a8cfb86cef7f6e0d7",
      "content": "# path: src/scripts/create_fsnb_pg.py\n\"\"\"\nИмпорт XML ФСНБ в PostgreSQL.\n\nИспользование:\n  docker compose exec app bash -lc \"python -m src.scripts.create_fsnb_pg\"\n\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\n\nfrom src.app_logging import get_logger\nfrom src.fsnb_matcher.services.ingest import ingest_to_postgres\n\n\nlogger = get_logger(__name__)\n\n\nasync def main() -> None:\n    \"\"\"Асинхронная точка входа — импортирует ФСНБ в Postgres.\"\"\"\n    logger.info(\"create_fsnb_pg_start\")\n    inserted = await ingest_to_postgres()\n    logger.info(\"create_fsnb_pg_done\", extra={\"inserted\": int(inserted)})\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n"
    },
    {
      "path": "src/scripts/init_vector_db.py",
      "language": "python",
      "size_bytes": 712,
      "sha256": "5a59db52ea55ab3b66f3442fded06913a0891b5d9c85024f5f1b587f5e31c09b",
      "content": "# path: src/scripts/init_vector_db.py\n\"\"\"\nИндексация Postgres → Qdrant (создание коллекции и заливка векторов).\n\nИспользование:\n  docker compose exec app bash -lc \"python -m src.scripts.init_vector_db\"\n\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\n\nfrom src.app_logging import get_logger\nfrom src.fsnb_matcher.services.index_qdrant import init_all_collections_entrypoint\n\n\nlogger = get_logger(__name__)\n\n\nasync def main() -> None:\n    logger.info(\"init_vector_db_start\")\n    count = await init_all_collections_entrypoint()\n    logger.info(\"init_vector_db_done\", extra={\"count\": int(count)})\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n"
    },
    {
      "path": "src/scripts/superuser.py",
      "language": "python",
      "size_bytes": 2434,
      "sha256": "f37b093c467370ecc7fbac768f275f05392123b175831a5289cbafb82803df57",
      "content": "# /src/scripts/superuser.py\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.app_logging import get_logger\nfrom src.core.models.user import User\nfrom src.core.models.profile import Profile\nfrom src.core.models.permission import Permission\nfrom src.core.security import hash_password\n\nlog = get_logger(\"scripts.superuser\")\n\n\nasync def create_superuser(\n    session: AsyncSession,\n    *,\n    username: str,\n    password: str,\n    email: Optional[str] = None,\n) -> int:\n    \"\"\"\n    Создаёт суперпользователя:\n    - User.username = username, User.email = email or f\"{username}@localhost\"\n    - пароль хэшируется\n    - e-mail считается подтверждённым (activation_key=None)\n    - создаётся Profile (verification=True, email заполняем как у user.email)\n    - создаётся Permission со всеми True\n    Возвращает user.id\n    \"\"\"\n    if not username:\n        raise ValueError(\"username is required\")\n\n    # e-mail обязателен в модели, поэтому подставим дефолт\n    email_final = (email or f\"{username}@localhost\").strip().lower()\n    password_hash = hash_password(password or \"\")\n\n    # Проверка уникальности username / email\n    existing_u = await session.execute(select(User).where((User.username == username) | (User.email == email_final)))\n    if existing_u.scalar_one_or_none():\n        raise ValueError(\"User with same username or email already exists\")\n\n    user = User(\n        username=username,\n        email=email_final,\n        hashed_password=password_hash,\n        is_active=True,\n        activation_key=None,  # нет ключа = подтверждён\n    )\n    session.add(user)\n    await session.flush()  # получим user.id\n\n    profile = Profile(\n        user_id=user.id,\n        verification=True,\n        email=email_final,\n    )\n    session.add(profile)\n    await session.flush()  # получим profile.id\n\n    perm = Permission(\n        profile_id=profile.id,\n        is_superadmin=True,\n        is_admin=True,\n        is_staff=True,\n        is_updater=True,\n        is_reader=True,\n        is_user=True,\n    )\n    session.add(perm)\n\n    log.info({\"event\": \"create_superuser\", \"user_id\": user.id, \"username\": username})\n    return user.id\n"
    },
    {
      "path": "src/templates/admin/index.html",
      "language": "html",
      "size_bytes": 390,
      "sha256": "020f516c5301ab7c7b023385c8e7fa0d9d11cbe4de294f20a0ce5912f45bc139",
      "content": "{% extends \"core/base.html\" %}\n{% block content %}\n<h1>Админка</h1>\n\n<div class=\"card\">\n  <h3>Зарегистрированные модели</h3>\n  <ul>\n    {% for m in models %}\n      <li>\n        <a href=\"{{ request.url_for('admin_model_list', slug=m.slug) }}\">\n          {{ m.model_name }} ({{ m.slug }})\n        </a>\n      </li>\n    {% endfor %}\n  </ul>\n</div>\n{% endblock %}\n"
    },
    {
      "path": "src/templates/admin/login.html",
      "language": "html",
      "size_bytes": 776,
      "sha256": "4966f70e2940e31ef2f07165b0415e1ec8bf42e3faf9954f8f100a351603320a",
      "content": "<!-- /templates/admin/login.html -->\n{% extends \"core/base.html\" %}\n{% block title %}Admin — Login{% endblock %}\n\n{% block content %}\n  <h2>Admin Login</h2>\n  {% if alert %}\n    <div class=\"alert {{ 'alert-success' if alert.kind == 'success' else 'alert-error' }}\">{{ alert.text }}</div>\n  {% endif %}\n\n  <form method=\"post\" action=\"{{ request.url_for('admin_login_post') }}\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf }}\">\n    <div class=\"form-row\">\n      <label>Username</label>\n      <input name=\"username\" type=\"text\" required>\n    </div>\n    <div class=\"form-row\">\n      <label>Password</label>\n      <input name=\"password\" type=\"password\" required>\n    </div>\n    <button class=\"btn btn-primary\" type=\"submit\">Sign in</button>\n  </form>\n{% endblock %}\n"
    },
    {
      "path": "src/templates/admin/model_edit.html",
      "language": "html",
      "size_bytes": 1503,
      "sha256": "ee18c52b2d6440f354c9dc22cc00bc0275b320cfb55bb007ed5ee8d28e4590e9",
      "content": "{% extends \"core/base.html\" %}\n{% block content %}\n<h1>Редактирование: {{ model_name }} #{{ obj.id }}</h1>\n\n<form method=\"post\" action=\"{{ request.url_for('admin_model_edit_post', slug=slug, obj_id=obj.id) }}\" class=\"form\" style=\"max-width:720px;\">\n  <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf }}\"/>\n\n  {% for name in fields %}\n    {% set label = labels.get(name, name) %}\n    {% set val = attr(obj, name) %}\n    <div class=\"form-row\">\n      <label>{{ label }}</label>\n\n      {% if name in readonly_fields %}\n        <div class=\"readonly\">{{ val }}</div>\n      {% else %}\n        {% if name.startswith(\"is_\") and (val is boolean or val in [True, False, 0, 1, '0', '1']) %}\n          {% set checked = (val == True) %}\n          <input type=\"checkbox\" name=\"{{ name }}\" {% if checked %}checked{% endif %}\n                 {% if name == 'is_superadmin' and not can_edit_super_flag %}disabled{% endif %}>\n          {% if name == 'is_superadmin' and not can_edit_super_flag %}\n            <small class=\"hint\">Изменять может только суперпользователь</small>\n          {% endif %}\n        {% else %}\n          <input type=\"text\" name=\"{{ name }}\" value=\"{{ val if val is not none else '' }}\">\n        {% endif %}\n      {% endif %}\n    </div>\n  {% endfor %}\n\n  <button type=\"submit\" class=\"btn btn-primary\">Сохранить</button>\n  <a href=\"{{ request.url_for('admin_model_list', slug=slug) }}\" class=\"btn\">Назад</a>\n</form>\n{% endblock %}\n"
    },
    {
      "path": "src/templates/admin/model_list.html",
      "language": "html",
      "size_bytes": 1128,
      "sha256": "74baeea178c2b00c70e5fb9b3676bfec173d19927cbdc22824d6d94cd8bccb3e",
      "content": "{% extends \"core/base.html\" %}\n{% block content %}\n<h1>Модель: {{ model_name }}</h1>\n\n<form method=\"get\" action=\"{{ request.url_for('admin_model_list', slug=slug) }}\" class=\"form-row\" style=\"max-width:480px; gap:8px;\">\n  <input type=\"text\" name=\"q\" value=\"{{ q }}\" placeholder=\"Поиск...\" />\n  <button class=\"btn btn-primary\" type=\"submit\">Найти</button>\n</form>\n\n<div class=\"table-wrap\" style=\"overflow:auto; margin-top:12px;\">\n  <table class=\"table\">\n    <thead>\n      <tr>\n        {% for f in list_display %}\n          <th>{{ f }}</th>\n        {% endfor %}\n        <th></th>\n      </tr>\n    </thead>\n    <tbody>\n      {% for row in rows %}\n        <tr>\n          {% for f in list_display %}\n            <td>{{ attr(row, f) }}</td>\n          {% endfor %}\n          <td>\n            <a class=\"btn btn-xs\" href=\"{{ request.url_for('admin_model_edit', slug=slug, obj_id=attr(row, 'id')) }}\">Edit</a>\n          </td>\n        </tr>\n      {% endfor %}\n      {% if not rows %}\n        <tr><td colspan=\"{{ list_display|length + 1 }}\">Пусто</td></tr>\n      {% endif %}\n    </tbody>\n  </table>\n</div>\n{% endblock %}\n"
    },
    {
      "path": "src/templates/admin/perm_edit.html",
      "language": "html",
      "size_bytes": 2011,
      "sha256": "26208056ea0fe0dd7133c013043fcf146fce927cd7235ebcc82d1f1b9f523f0b",
      "content": "<!-- /templates/admin/perm_edit.html -->\n{% extends \"core/base.html\" %}\n{% block title %}Admin — Edit Permissions{% endblock %}\n\n{% block content %}\n  <h2>Permissions (profile_id={{ perm.profile_id }})</h2>\n\n  {% if forbidden_reason %}\n    <div class=\"alert alert-error\">{{ forbidden_reason }}</div>\n  {% endif %}\n\n  <form method=\"post\" action=\"{{ request.url_for('admin_perm_edit_post', profile_id=perm.profile_id) }}\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf }}\">\n\n    {% set ro = 'disabled' if read_only else '' %}\n    {% set dis_super = '' if can_edit_super_flag and not read_only else 'disabled' %}\n\n    <div class=\"form-row\">\n      <label>is_superadmin</label>\n      <input name=\"is_superadmin\" type=\"checkbox\" {% if perm.is_superadmin %}checked{% endif %} {{ dis_super }}>\n      {% if not can_edit_super_flag %}\n        <small class=\"hint\">Только суперпользователь может менять этот флаг</small>\n      {% endif %}\n    </div>\n\n    <div class=\"form-row\"><label>is_admin</label>\n      <input name=\"is_admin\" type=\"checkbox\" {% if perm.is_admin %}checked{% endif %} {{ ro }}>\n    </div>\n    <div class=\"form-row\"><label>is_staff</label>\n      <input name=\"is_staff\" type=\"checkbox\" {% if perm.is_staff %}checked{% endif %} {{ ro }}>\n    </div>\n    <div class=\"form-row\"><label>is_updater</label>\n      <input name=\"is_updater\" type=\"checkbox\" {% if perm.is_updater %}checked{% endif %} {{ ro }}>\n    </div>\n    <div class=\"form-row\"><label>is_reader</label>\n      <input name=\"is_reader\" type=\"checkbox\" {% if perm.is_reader %}checked{% endif %} {{ ro }}>\n    </div>\n    <div class=\"form-row\"><label>is_user</label>\n      <input name=\"is_user\" type=\"checkbox\" {% if perm.is_user %}checked{% endif %} {{ ro }}>\n    </div>\n\n    {% if not read_only %}\n      <button class=\"btn btn-primary\" type=\"submit\">Save</button>\n    {% else %}\n      <button class=\"btn btn-primary\" type=\"submit\" disabled>Save</button>\n    {% endif %}\n  </form>\n{% endblock %}\n"
    },
    {
      "path": "src/templates/admin/profile_edit.html",
      "language": "html",
      "size_bytes": 1215,
      "sha256": "7a0c6dc162ca741ccaa426e773aaab3bc84bb639b6ab1a8d8a6d9368766915be",
      "content": "<!-- /templates/admin/profile_edit.html -->\n{% extends \"core/base.html\" %}\n{% block title %}Admin — Edit Profile{% endblock %}\n\n{% block content %}\n  <h2>Profile #{{ profile.id }} (user_id={{ profile.user_id }})</h2>\n  <form method=\"post\" action=\"{{ request.url_for('admin_profile_edit_post', profile_id=profile.id) }}\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf }}\">\n\n    <div class=\"form-row\"><label>Nickname</label><input name=\"nickname\" value=\"{{ profile.nickname or '' }}\"></div>\n    <div class=\"form-row\"><label>First name</label><input name=\"first_name\" value=\"{{ profile.first_name or '' }}\"></div>\n    <div class=\"form-row\"><label>Second name</label><input name=\"second_name\" value=\"{{ profile.second_name or '' }}\"></div>\n    <div class=\"form-row\"><label>Phone</label><input name=\"phone\" value=\"{{ profile.phone or '' }}\"></div>\n    <div class=\"form-row\"><label>E-mail</label><input name=\"email\" type=\"email\" value=\"{{ profile.email or '' }}\"></div>\n    <div class=\"form-row\"><label>Verified</label><input name=\"verification\" type=\"checkbox\" {% if profile.verification %}checked{% endif %}></div>\n\n    <button class=\"btn btn-primary\" type=\"submit\">Save</button>\n  </form>\n{% endblock %}\n"
    },
    {
      "path": "src/templates/admin/user_edit.html",
      "language": "html",
      "size_bytes": 3715,
      "sha256": "4f430c58f407aee0893c887d5c16280cade6dd15616ffe0b1d9f4bcb2267af8b",
      "content": "{% extends \"core/base.html\" %}\n{% block title %}Admin — Edit User{% endblock %}\n\n{% block content %}\n  <h2>Редактирование пользователя #{{ user.id }}</h2>\n\n  <form method=\"post\" action=\"{{ request.url_for('admin_user_edit_post', user_id=user.id) }}\" class=\"card\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf }}\">\n\n    <h3>Учётная запись</h3>\n    <div class=\"form-row\">\n      <label>Username</label>\n      <input type=\"text\" name=\"username\" value=\"{{ user.username or '' }}\">\n    </div>\n    <div class=\"form-row\">\n      <label>Активен</label>\n      <input type=\"checkbox\" name=\"is_active\" {% if user.is_active %}checked{% endif %}>\n    </div>\n\n    <h3>Профиль</h3>\n    <div class=\"form-row\">\n      <label>Nickname</label>\n      <input type=\"text\" name=\"nickname\" value=\"{{ profile.nickname or '' }}\">\n    </div>\n    <div class=\"form-row\">\n      <label>Имя</label>\n      <input type=\"text\" name=\"first_name\" value=\"{{ profile.first_name or '' }}\">\n    </div>\n    <div class=\"form-row\">\n      <label>Фамилия</label>\n      <input type=\"text\" name=\"second_name\" value=\"{{ profile.second_name or '' }}\">\n    </div>\n    <div class=\"form-row\">\n      <label>Телефон</label>\n      <input type=\"text\" name=\"phone\" value=\"{{ profile.phone or '' }}\">\n    </div>\n    <div class=\"form-row\">\n      <label>E-mail (в профиле)</label>\n      <input type=\"text\" name=\"email\" value=\"{{ profile.email or '' }}\">\n    </div>\n    <div class=\"form-row\">\n      <label>Telegram ID</label>\n      <input type=\"text\" name=\"tg_id\" value=\"{{ profile.tg_id or '' }}\">\n    </div>\n    <div class=\"form-row\">\n      <label>Telegram nickname</label>\n      <input type=\"text\" name=\"tg_nickname\" value=\"{{ profile.tg_nickname or '' }}\">\n    </div>\n    <div class=\"form-row\">\n      <label>Подтверждён</label>\n      <input type=\"checkbox\" name=\"verification\" {% if profile.verification %}checked{% endif %}>\n    </div>\n\n    <h3>Права</h3>\n    {% if perm_note %}\n      <div class=\"alert alert-error\">{{ perm_note }}</div>\n    {% endif %}\n    <div class=\"grid-2\">\n      <label>\n        <input type=\"checkbox\" name=\"is_superadmin\"\n               {% if perm.is_superadmin %}checked{% endif %}\n               {% if not can_edit_super_flag or not perm_editable %}disabled{% endif %}>\n        is_superadmin\n      </label>\n\n      <label>\n        <input type=\"checkbox\" name=\"is_admin_flag\"\n               {% if perm.is_admin %}checked{% endif %}\n               {% if not perm_editable %}disabled{% endif %}>\n        is_admin\n      </label>\n\n      <label>\n        <input type=\"checkbox\" name=\"is_staff\"\n               {% if perm.is_staff %}checked{% endif %}\n               {% if not perm_editable %}disabled{% endif %}>\n        is_staff\n      </label>\n\n      <label>\n        <input type=\"checkbox\" name=\"is_updater\"\n               {% if perm.is_updater %}checked{% endif %}\n               {% if not perm_editable %}disabled{% endif %}>\n        is_updater\n      </label>\n\n      <label>\n        <input type=\"checkbox\" name=\"is_reader\"\n               {% if perm.is_reader %}checked{% endif %}\n               {% if not perm_editable %}disabled{% endif %}>\n        is_reader\n      </label>\n\n      <label>\n        <input type=\"checkbox\" name=\"is_user_flag\"\n               {% if perm.is_user %}checked{% endif %}\n               {% if not perm_editable %}disabled{% endif %}>\n        is_user\n      </label>\n    </div>\n\n    <div style=\"margin-top:16px\">\n      <button type=\"submit\" class=\"btn btn-primary\">Сохранить</button>\n      <a class=\"btn\" href=\"{{ request.url_for('admin_users') }}\">Назад к списку</a>\n    </div>\n  </form>\n{% endblock %}\n"
    },
    {
      "path": "src/templates/admin/users.html",
      "language": "html",
      "size_bytes": 787,
      "sha256": "70a68867ab685ed12b1d9098db92031010cb1747b41502a9a97e23a5b09239f6",
      "content": "{% extends \"core/base.html\" %}\n{% block title %}Admin — Users{% endblock %}\n{% block content %}\n  <h2>Users</h2>\n  <table class=\"table\">\n    <thead>\n      <tr>\n        <th>ID</th><th>E-mail</th><th>Username</th><th>Active</th><th>Verified</th><th></th>\n      </tr>\n    </thead>\n    <tbody>\n      {% for it in items %}\n      {% set u = it.user %}\n      <tr>\n        <td>{{ u.id }}</td>\n        <td>{{ u.email }}</td>\n        <td>{{ u.username or \"—\" }}</td>\n        <td>{{ \"✓\" if u.is_active else \"—\" }}</td>\n        <td>{{ \"✓\" if it.verified else \"—\" }}</td>\n        <td>\n          <a class=\"btn btn-primary btn-xs\" href=\"{{ request.url_for('admin_user_edit_get', user_id=u.id) }}\">Edit</a>\n        </td>\n      </tr>\n      {% endfor %}\n    </tbody>\n  </table>\n{% endblock %}\n"
    },
    {
      "path": "src/templates/core/_header.html",
      "language": "html",
      "size_bytes": 1697,
      "sha256": "e7bac9953045e0fcd965969488310647ec68ee9ee39713922a18d3e948dcc3d8",
      "content": "<!-- templates/core/_header.html -->\n<header class=\"header\">\n  <div class=\"container header-inner\">\n    <a href=\"{{ request.url_for('home') }}\" class=\"brand\">fsnb-fastapi</a>\n\n    <nav class=\"nav\">\n      {% set is_auth = request.session.get('access_token') and request.session.get('user_email') %}\n      {% set admin_uid = request.session.get('admin_user_id') %}\n      <ul class=\"nav-list\">\n        {# 1) Если вошли в админку — показываем элементы админа #}\n        {% if admin_uid %}\n          <li class=\"nav-item\">\n            <a href=\"{{ request.url_for('admin_index') }}\">Админка</a>\n          </li>\n          <li class=\"nav-item\">\n            <form method=\"post\" action=\"{{ request.url_for('admin_logout') }}\">\n              <button type=\"submit\" class=\"nav-logout\">Выйти (admin)</button>\n            </form>\n          </li>\n\n        {# 2) Иначе — обычная пользовательская навигация #}\n        {% elif is_auth %}\n          <li class=\"nav-item\">\n            <a href=\"{{ request.url_for('profile_html') }}\">Профиль</a>\n          </li>\n          <li class=\"nav-item\">\n            <form method=\"post\" action=\"{{ request.url_for('logout_html') }}\">\n              <button type=\"submit\" class=\"nav-logout\">Выйти</button>\n            </form>\n          </li>\n        {% else %}\n          <li class=\"nav-item\">\n            <a href=\"{{ request.url_for('login_html') }}\">Вход</a>\n          </li>\n          <li class=\"nav-item\">\n            <a href=\"{{ request.url_for('register_html') }}\">Регистрация</a>\n          </li>\n        {% endif %}\n      </ul>\n    </nav>\n  </div>\n</header>\n"
    },
    {
      "path": "src/templates/core/base.html",
      "language": "html",
      "size_bytes": 780,
      "sha256": "6290bd6397d50e4839740e3986745701133f5fc0b4654018f90309b4d17d43e7",
      "content": "<!-- /templates/core/base.html -->\n<!doctype html>\n<html lang=\"ru\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>{% block title %}fsnb-fastapi{% endblock %}</title>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"{{ request.url_for('static', path='css/style.css') }}\" />\n    {% block head_extra %}\n      <script src=\"{{ request.url_for('static', path='js/app.js') }}\" defer></script>\n    {% endblock %}\n  </head>\n  <body>\n    {% include \"core/_header.html\" %}\n    <main class=\"container\">\n      {% if alert %}\n        <div class=\"alert {{ 'alert-success' if alert.kind == 'success' else 'alert-error' }}\">{{ alert.text }}</div>\n      {% endif %}\n      {% block content %}{% endblock %}\n    </main>\n  </body>\n</html>\n"
    },
    {
      "path": "src/templates/core/index.html",
      "language": "html",
      "size_bytes": 1274,
      "sha256": "fb02205385b58cfe12c542db68d561b06cf0c6c4bda8bcf6e2dc0ce6cdc67d69",
      "content": "{% extends \"core/base.html\" %}\n\n{% block title %}Главная — fsnb-fastapi{% endblock %}\n\n{% block head_extra %}\n  {{ super() }}\n  <script src=\"{{ request.url_for('static', path='js/fsnb_matcher.js') }}\" defer></script>\n{% endblock %}\n\n{% block content %}\n  <h1>Главная</h1>\n\n  {% if verify_link %}\n    <p style=\"margin:.5rem 0 1rem\">\n      <small>Письмо не пришло? Можно подтвердить прямо сейчас:\n        <a href=\"{{ verify_link }}\">подтвердить e-mail</a>.\n      </small>\n    </p>\n  {% endif %}\n\n  <p>Перейти к <a href=\"{{ request.url_for('users_list_html') }}\">списку пользователей</a>.</p>\n\n  {% set is_auth = request.session.get('access_token') and request.session.get('user_email') %}\n  {% if is_auth %}\n    {% include \"fsnb_matcher/widget.html\" %}\n  {% else %}\n    <div class=\"card\">\n      <p>\n        Для использования функции сопоставления спецификации с ФСНБ-2022 (ВОР) необходимо\n        <a href=\"{{ request.url_for('login_html') }}\">войти</a> или\n        <a href=\"{{ request.url_for('register_html') }}\">зарегистрироваться</a>.\n      </p>\n    </div>\n  {% endif %}\n{% endblock %}\n"
    },
    {
      "path": "src/templates/core/login.html",
      "language": "html",
      "size_bytes": 909,
      "sha256": "88f788055848c725ea0047b7eeb459ccd88f49ea7d345e47230e51107e655929",
      "content": "{% extends \"core/base.html\" %}\n{% block title %}Вход — fsnb-fastapi{% endblock %}\n\n{% block content %}\n  <h2>Вход</h2>\n\n  {% if alert %}\n    <div class=\"alert {{ alert.kind }}\">{{ alert.text }}</div>\n  {% endif %}\n\n  <form method=\"post\" action=\"{{ request.url_for('login_post_html') }}\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf }}\" />\n\n    <div class=\"form-row\">\n      <label>E-mail</label>\n      <input type=\"email\" name=\"email\" required placeholder=\"email@domain.tld\" />\n    </div>\n\n    <div class=\"form-row\">\n      <label>Пароль</label>\n      <input type=\"password\" name=\"password\" required placeholder=\"********\" />\n    </div>\n\n    <div class=\"form-row\">\n      <label>Капча: {{ a }} + {{ b }} = ?</label>\n      <input type=\"number\" name=\"captcha\" required />\n    </div>\n\n    <button class=\"btn btn-primary\" type=\"submit\">Войти</button>\n  </form>\n{% endblock %}\n"
    },
    {
      "path": "src/templates/core/profile.html",
      "language": "html",
      "size_bytes": 3384,
      "sha256": "9957e6dcf0cdf83b06121f9c6623ce269b428b9759f15d2b410c8702d43ceb53",
      "content": "{% extends \"core/base.html\" %}\n\n{% block head_extra %}\n  {{ super() }}\n  <script src=\"{{ url_for('static', path='js/avatar-preview.js') }}\" defer></script>\n{% endblock %}\n{% block content %}\n<h1 class=\"title-row\">\n  <span>Профиль</span>\n\n  <div class=\"title-right\">\n    <img\n      id=\"avatar-mini\"\n      class=\"avatar-mini\"\n      src=\"{% if profile.avatar %}{{ url_for('static', path=profile.avatar) }}{% else %}{{ url_for('static', path='img/photo_cap.jpg') }}{% endif %}\"\n      alt=\"avatar\"\n      width=\"40\"\n      height=\"40\"\n    />\n    {% if profile.avatar %}\n      <form method=\"post\" action=\"{{ request.url_for('profile_avatar_delete') }}\" class=\"avatar-actions\">\n        <button type=\"submit\" class=\"btn btn-danger btn-xs\">Удалить аватар</button>\n      </form>\n    {% endif %}\n  </div>\n</h1>\n\n{% if alert %}\n  <div class=\"alert alert-{{ alert.kind }}\">{{ alert.text }}</div>\n{% endif %}\n\n<div class=\"card\">\n  <p><strong>User:</strong> {{ user.email }} | id={{ user.id }}</p>\n  <p><strong>Верификация e-mail:</strong>\n    {% if user.activation_key %}<span class=\"warn\">не подтверждён</span>\n    {% else %}<span class=\"ok\">подтверждён</span>\n    {% endif %}\n  </p>\n</div>\n\n<form method=\"post\" action=\"{{ request.url_for('profile_post_html') }}\" enctype=\"multipart/form-data\">\n  <div class=\"form-row\">\n    <label>Nickname</label>\n    <input type=\"text\" name=\"nickname\" value=\"{{ profile.nickname or '' }}\">\n  </div>\n\n  <div class=\"form-row\">\n    <label>Avatar</label>\n    <div class=\"avatar-uploader\">\n      <div class=\"avatar-preview\">\n        <img\n          id=\"avatar-preview-img\"\n          src=\"{% if profile.avatar %}{{ url_for('static', path=profile.avatar) }}{% else %}{{ url_for('static', path='img/photo_cap.jpg') }}{% endif %}\"\n          alt=\"avatar preview\"\n        />\n      </div>\n      <div class=\"avatar-controls\">\n        <input id=\"avatar-input\" type=\"file\" name=\"avatar\" accept=\"image/*\" hidden>\n        <label for=\"avatar-input\" class=\"btn btn-primary\">Выбрать файл</label>\n        <small class=\"hint\">JPG/PNG/GIF/WebP, минимум 40×40, до 3&nbsp;МБ.</small>\n        <span id=\"avatar-filename\" class=\"filename\"></span>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"form-row\">\n    <label>Имя</label>\n    <input type=\"text\" name=\"first_name\" value=\"{{ profile.first_name or '' }}\">\n  </div>\n  <div class=\"form-row\">\n    <label>Фамилия</label>\n    <input type=\"text\" name=\"second_name\" value=\"{{ profile.second_name or '' }}\">\n  </div>\n  <div class=\"form-row\">\n    <label>Телефон</label>\n    <input type=\"text\" name=\"phone\" value=\"{{ profile.phone or '' }}\">\n  </div>\n  <div class=\"form-row\">\n    <label>E-mail (в профиле)</label>\n    <input type=\"email\" name=\"email_field\" value=\"{{ profile.email or '' }}\">\n  </div>\n  <div class=\"form-row\">\n    <label>Telegram ID</label>\n    <input type=\"text\" name=\"tg_id\" value=\"{{ profile.tg_id or '' }}\">\n  </div>\n  <div class=\"form-row\">\n    <label>Telegram nickname</label>\n    <input type=\"text\" name=\"tg_nickname\" value=\"{{ profile.tg_nickname or '' }}\">\n  </div>\n  <div class=\"form-row\">\n    <label>Session (строка)</label>\n    <input type=\"text\" name=\"session_str\" value=\"{{ profile.session or '' }}\">\n  </div>\n\n  <button type=\"submit\" class=\"btn btn-primary\">Сохранить</button>\n</form>\n{% endblock %}\n"
    },
    {
      "path": "src/templates/core/register.html",
      "language": "html",
      "size_bytes": 1131,
      "sha256": "b758aa21a9c458b18d7337fc0c893d063658571c501c7a8374742bcea81f6938",
      "content": "<!-- /templates/core/register.html -->\n{% extends \"core/base.html\" %}\n{% block title %}Регистрация — fsnb-fastapi{% endblock %}\n\n{% block content %}\n  <h2>Регистрация</h2>\n  <form method=\"post\" action=\"{{ request.url_for('register_post_html') }}\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf }}\" />\n    <div class=\"form-row\">\n      <label>E-mail</label>\n      <input name=\"email\" type=\"email\" required placeholder=\"email@domain.tld\" />\n    </div>\n    <div class=\"form-row\">\n      <label>Пароль</label>\n      <input name=\"password\" type=\"password\" minlength=\"8\" maxlength=\"256\" required placeholder=\"********\" />\n    </div>\n    <div class=\"form-row\">\n      <label>Повтор пароля</label>\n      <input name=\"password2\" type=\"password\" minlength=\"8\" maxlength=\"256\" required placeholder=\"********\" />\n    </div>\n    <div class=\"form-row\">\n      <label>Капча: {{ a }} + {{ b }} = ?</label>\n      <input name=\"captcha\" type=\"number\" required />\n    </div>\n    <button class=\"btn btn-primary\" type=\"submit\">Зарегистрироваться</button>\n  </form>\n{% endblock %}\n"
    },
    {
      "path": "src/templates/fsnb_matcher/widget.html",
      "language": "html",
      "size_bytes": 1229,
      "sha256": "52ed0a900621a7cf29c29e5b6b321896432e106e80705c148fea7f1e059fa39d",
      "content": "{# path: templates/fsnb_matcher/widget.html #}\n\n<div class=\"card\" id=\"fsnb-matcher\">\n  <form id=\"fsnb-match-form\">\n    <div class=\"row\">\n      <!-- сохраняем стиль кнопки выбора файла: input скрыт, кнопка — label -->\n      <label class=\"btn\" for=\"fsnb-file\">Выбрать JSON</label>\n      <input id=\"fsnb-file\" name=\"file\" type=\"file\" accept=\".json,application/json\" hidden />\n\n      <span id=\"fsnb-file-status\" class=\"muted\">Файл не выбран</span>\n    </div>\n\n    <div class=\"row\" style=\"margin-top:12px;\">\n      <button class=\"btn btn-primary\" type=\"submit\">Сопоставить и скачать Excel</button>\n    </div>\n\n    <div id=\"fsnb-error\" class=\"alert alert-error\" style=\"display:none; margin-top:12px;\"></div>\n  </form>\n</div>\n\n<!-- Модальное окно обработки -->\n<div id=\"fsnb-modal\" class=\"modal\" style=\"display:none;\" aria-hidden=\"true\">\n  <div class=\"modal__backdrop\"></div>\n  <div class=\"modal__content\">\n    <div class=\"kitty-spinner\" aria-hidden=\"true\">\n      <span class=\"kitty-orbit\">\n        <span class=\"kitty\">🐱</span>\n      </span>\n    </div>\n    <div class=\"modal__text\">Обрабатываю…</div>\n  </div>\n</div>\n"
    },
    {
      "path": "src/templates/train/review_table.html",
      "language": "html",
      "size_bytes": 9723,
      "sha256": "10881b8f25c7fe85d9e2f227cc460f7360b39cbc828da1ccb5a9b9f61a3e5dc9",
      "content": "<!-- path: src/templates/train/review_table.html -->\n{% extends \"core/base.html\" %}\n{% block title %}Review — Table{% endblock %}\n\n{% block content %}\n<h2>Ревью (без сохранения, пока не нажмёте “Сформировать”)</h2>\n\n<form id=\"commitForm\" method=\"post\" action=\"/api/v1/review/commit\">\n  <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf }}\">\n</form>\n\n<div style=\"margin: 12px 0;\">\n  <button class=\"btn btn-primary\" id=\"btnCommit\">Сформировать (Excel) + сохранить метки</button>\n</div>\n\n<table class=\"table\" id=\"reviewTable\" style=\"width:100%; border-collapse: collapse;\">\n  <thead>\n    <tr>\n      <th>#</th>\n      <th>Caption</th>\n      <th>FSNB (выбор)</th>\n      <th>FSNB code</th>\n      <th>Units</th>\n      <th>FSNB Units</th>\n      <th>Qty</th>\n      <th>Label</th>\n      <th>Note</th>\n    </tr>\n  </thead>\n  <tbody>\n  {% for r in rows %}\n    <tr data-row-idx=\"{{ r.row_idx }}\">\n      <td>{{ r.row_idx + 1 }}</td>\n      <td style=\"max-width:520px;\">{{ r.caption }}</td>\n\n      <td style=\"min-width:420px;\">\n        <!-- top-K кандидаты: сначала они -->\n        <select class=\"fsnb-select\" style=\"max-height:100px;\">\n          <option value=\"\">— нет (none_match) —</option>\n          {% for c in r.candidates %}\n            <option\n              value=\"{{ c.id }}\"\n              data-code=\"{{ c.code or '' }}\"\n              data-unit=\"{{ c.unit or '' }}\"\n              {% if c.id == r.selected_item_id %}selected{% endif %}\n            >\n              {{ c.code or '' }} — {{ c.name or '' }} ({{ c.unit or '' }}) [{{ \"%.3f\"|format(c.score) }}]\n            </option>\n          {% endfor %}\n        </select>\n\n        <!-- AJAX-поиск по всей базе (второй dropdown) -->\n        <div style=\"margin-top:6px;\">\n          <input class=\"fsnb-search\" placeholder=\"Поиск по items (код/текст)...\" style=\"width:100%;\">\n          <div class=\"fsnb-search-results\" style=\"border:1px solid #333; max-height:100px; overflow:auto; display:none;\"></div>\n        </div>\n      </td>\n\n      <td class=\"cell-code\"></td>\n      <td>{{ r.units or '' }}</td>\n      <td class=\"cell-fsnb-unit\"></td>\n      <td>{{ r.qty or '' }}</td>\n\n      <td>\n        <select class=\"label-select\">\n          {% set labels = [\"gold\",\"negative\",\"skip\",\"ambiguous\",\"none_match\"] %}\n          {% for lb in labels %}\n            <option value=\"{{ lb }}\" {% if lb == r.label %}selected{% endif %}>{{ lb }}</option>\n          {% endfor %}\n        </select>\n      </td>\n\n      <td>\n        <input class=\"note-input\" style=\"width:220px;\" value=\"{{ r.note or '' }}\">\n      </td>\n\n      <!-- скрытые данные для JS state -->\n      <td style=\"display:none;\">\n        <span class=\"auto-id\">{{ r.auto_selected_item_id or \"\" }}</span>\n      </td>\n    </tr>\n  {% endfor %}\n  </tbody>\n</table>\n\n<script>\n(function() {\n  const sourceName = {{ source_name|tojson }};\n  const rows = Array.from(document.querySelectorAll('#reviewTable tbody tr')).map(tr => {\n    const rowIdx = parseInt(tr.getAttribute('data-row-idx'), 10);\n    const caption = tr.children[1].innerText;\n    const units = tr.children[4].innerText.trim() || null;\n    const qty = tr.children[6].innerText.trim() || null;\n    const fsnbSelect = tr.querySelector('.fsnb-select');\n    const labelSelect = tr.querySelector('.label-select');\n    const noteInput = tr.querySelector('.note-input');\n    const autoId = tr.querySelector('.auto-id').innerText.trim();\n\n    // начальные поля\n    const selectedId = fsnbSelect.value ? parseInt(fsnbSelect.value, 10) : null;\n\n    // negatives (штрафы) формируем на клиенте, но сохраняем только при commit\n    return {\n      row_idx: rowIdx,\n      caption: caption,\n      units: units,\n      qty: qty,\n      label: labelSelect.value,\n      selected_item_id: selectedId,\n      auto_selected_item_id: autoId ? parseInt(autoId, 10) : null,\n      negatives: [],\n      note: noteInput.value || null,\n    };\n  });\n\n  function findRow(rowIdx) {\n    return rows.find(r => r.row_idx === rowIdx);\n  }\n\n  function updateMeta(tr, optionEl) {\n    const codeCell = tr.querySelector('.cell-code');\n    const unitCell = tr.querySelector('.cell-fsnb-unit');\n    if (!optionEl) {\n      codeCell.innerText = '';\n      unitCell.innerText = '';\n      return;\n    }\n    codeCell.innerText = optionEl.getAttribute('data-code') || '';\n    unitCell.innerText = optionEl.getAttribute('data-unit') || '';\n  }\n\n  // Инициализация мета по текущему selected\n  document.querySelectorAll('#reviewTable tbody tr').forEach(tr => {\n    const sel = tr.querySelector('.fsnb-select');\n    const opt = sel.options[sel.selectedIndex];\n    updateMeta(tr, opt && opt.value ? opt : null);\n  });\n\n  // При смене top-K dropdown:\n  document.querySelectorAll('.fsnb-select').forEach(sel => {\n    sel.addEventListener('change', (e) => {\n      const tr = e.target.closest('tr');\n      const rowIdx = parseInt(tr.getAttribute('data-row-idx'), 10);\n      const r = findRow(rowIdx);\n\n      const prevSelected = r.selected_item_id;\n      const nextSelected = e.target.value ? parseInt(e.target.value, 10) : null;\n\n      // если был auto и мы уходим с него — штрафуем auto\n      if (r.auto_selected_item_id && nextSelected && nextSelected !== r.auto_selected_item_id) {\n        if (!r.negatives.includes(r.auto_selected_item_id)) {\n          r.negatives.push(r.auto_selected_item_id);\n        }\n        r.label = 'gold';\n        tr.querySelector('.label-select').value = 'gold';\n      }\n\n      // если очищаем выбор — none_match\n      if (!nextSelected) {\n        r.label = 'none_match';\n        tr.querySelector('.label-select').value = 'none_match';\n      }\n\n      r.selected_item_id = nextSelected;\n      updateMeta(tr, e.target.value ? e.target.options[e.target.selectedIndex] : null);\n    });\n  });\n\n  // label dropdown\n  document.querySelectorAll('.label-select').forEach(sel => {\n    sel.addEventListener('change', (e) => {\n      const tr = e.target.closest('tr');\n      const rowIdx = parseInt(tr.getAttribute('data-row-idx'), 10);\n      const r = findRow(rowIdx);\n      r.label = e.target.value;\n    });\n  });\n\n  // note\n  document.querySelectorAll('.note-input').forEach(inp => {\n    inp.addEventListener('input', (e) => {\n      const tr = e.target.closest('tr');\n      const rowIdx = parseInt(tr.getAttribute('data-row-idx'), 10);\n      const r = findRow(rowIdx);\n      r.note = e.target.value || null;\n    });\n  });\n\n  // AJAX поиск по items\n  document.querySelectorAll('#reviewTable tbody tr').forEach(tr => {\n    const searchInput = tr.querySelector('.fsnb-search');\n    const resultsBox = tr.querySelector('.fsnb-search-results');\n    const topkSelect = tr.querySelector('.fsnb-select');\n\n    let lastQ = '';\n    let timer = null;\n\n    function hideResults() {\n      resultsBox.style.display = 'none';\n      resultsBox.innerHTML = '';\n    }\n\n    searchInput.addEventListener('input', () => {\n      const q = (searchInput.value || '').trim();\n      if (q.length < 3) {\n        hideResults();\n        return;\n      }\n      lastQ = q;\n\n      if (timer) clearTimeout(timer);\n      timer = setTimeout(async () => {\n        try {\n          const resp = await fetch(`/api/v1/review/items/search?q=${encodeURIComponent(q)}&limit=20`, { credentials: 'include' });\n          const data = await resp.json();\n          if (q !== lastQ) return;\n\n          resultsBox.innerHTML = '';\n          (data.items || []).forEach(it => {\n            const div = document.createElement('div');\n            div.style.padding = '6px';\n            div.style.cursor = 'pointer';\n            div.innerText = `${it.code} — ${it.name} (${it.unit || ''})`;\n\n            div.addEventListener('click', () => {\n              // выбираем item: добавляем временную option в topkSelect и выбираем\n              const opt = document.createElement('option');\n              opt.value = String(it.id);\n              opt.setAttribute('data-code', it.code || '');\n              opt.setAttribute('data-unit', it.unit || '');\n              opt.text = `${it.code} — ${it.name} (${it.unit || ''}) [manual]`;\n              topkSelect.appendChild(opt);\n              topkSelect.value = String(it.id);\n              topkSelect.dispatchEvent(new Event('change'));\n\n              hideResults();\n            });\n\n            resultsBox.appendChild(div);\n          });\n\n          resultsBox.style.display = 'block';\n        } catch (e) {\n          hideResults();\n        }\n      }, 250);\n    });\n\n    document.addEventListener('click', (e) => {\n      if (!resultsBox.contains(e.target) && e.target !== searchInput) {\n        hideResults();\n      }\n    });\n  });\n\n  // Commit -> скачивание Excel\n  document.getElementById('btnCommit').addEventListener('click', async () => {\n    const payload = {\n      source_name: sourceName,\n      rows: rows,\n    };\n\n    const resp = await fetch('/api/v1/review/commit', {\n      method: 'POST',\n      credentials: 'include',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(payload),\n    });\n\n    if (!resp.ok) {\n      alert('Не удалось сформировать отчёт. Проверь логи.');\n      return;\n    }\n\n    const blob = await resp.blob();\n    const url = window.URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = 'VOR.xlsx';\n    document.body.appendChild(a);\n    a.click();\n    a.remove();\n    window.URL.revokeObjectURL(url);\n  });\n})();\n</script>\n{% endblock %}\n"
    },
    {
      "path": "src/templates/train/review_upload.html",
      "language": "html",
      "size_bytes": 881,
      "sha256": "b91e454213692cf1b3bde4f56e51ef02ed8f573878700dff983074ae2e20144e",
      "content": "<!-- path: src/templates/train/review_upload.html -->\n{% extends \"core/base.html\" %}\n{% block title %}Review — Upload{% endblock %}\n\n{% block content %}\n  <h2>Ревью спецификации</h2>\n\n  {% if alert %}\n    <div class=\"alert alert-{{ alert.kind }}\">{{ alert.text }}</div>\n  {% endif %}\n\n  <form method=\"post\" action=\"/review\" enctype=\"multipart/form-data\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf }}\">\n\n    <div class=\"form-row\">\n      <label>JSON спецификация</label>\n      <input type=\"file\" name=\"spec_file\" accept=\"application/json,.json\" required>\n    </div>\n\n    <div class=\"form-row\">\n      <label>Top-K кандидатов</label>\n      <input type=\"number\" name=\"top_k\" value=\"5\" min=\"1\" max=\"20\">\n    </div>\n\n    <button class=\"btn btn-primary\" type=\"submit\">Открыть таблицу</button>\n  </form>\n{% endblock %}\n"
    },
    {
      "path": "src/templates/users/list.html",
      "language": "html",
      "size_bytes": 605,
      "sha256": "ca0428c58300fee5854c16bed37ec1cb97cc276e81cd95e79c3fd3668d693c0b",
      "content": "<!-- /templates/users/list.html -->\n{% extends \"core/base.html\" %}\n{% block title %}Пользователи — fsnb-fastapi{% endblock %}\n\n{% block content %}\n  <h2>Пользователи</h2>\n  <table class=\"table\">\n    <thead>\n      <tr><th>ID</th><th>Email</th><th>Username</th><th>Active</th></tr>\n    </thead>\n    <tbody>\n      {% for u in users %}\n        <tr>\n          <td>{{ u.id }}</td>\n          <td>{{ u.email }}</td>\n          <td>{{ u.username or '' }}</td>\n          <td>{{ '✓' if u.is_active else '—' }}</td>\n        </tr>\n      {% endfor %}\n    </tbody>\n  </table>\n{% endblock %}\n"
    },
    {
      "path": "src/train/__init__.py",
      "language": "python",
      "size_bytes": 59,
      "sha256": "4b29187c8904c79c40a57829262f936c4c996f375bf334875a5ff8cb24edb23c",
      "content": "# src/train/__init__.py\nfrom __future__ import annotations\n"
    },
    {
      "path": "src/train/api/__init__.py",
      "language": "python",
      "size_bytes": 355,
      "sha256": "48b9db9e5fdfc89a2895408ec9991dca3d9ddd0aa6143f8547f4a20ebd96ee6b",
      "content": "# path: src/train/api/api_v1/__init__.py\nfrom __future__ import annotations\n\nfrom fastapi import APIRouter\n\nfrom src.core.config import settings\nfrom src.train.api.api_v1.review import router as review_router\n\n\nrouter = APIRouter(prefix=settings.api.v1.prefix)\n\n# /api/v1/review/...\nrouter.include_router(review_router, prefix=\"/review\", tags=[\"review\"])\n"
    },
    {
      "path": "src/train/api/api_v1/__init__.py",
      "language": "python",
      "size_bytes": 124,
      "sha256": "c01c1e0e246457d532efe1f69e882918e6431105ac6d5e3057c09fc4d7e01259",
      "content": "# src/train/api/api_v1/__init__.py\nfrom __future__ import annotations\nfrom fastapi import APIRouter\n\n\nrouter = APIRouter()\n\n"
    },
    {
      "path": "src/train/api/api_v1/review.py",
      "language": "python",
      "size_bytes": 9714,
      "sha256": "2ecc4aa9373e5c251ca55fa3fc83a2d565a4d417a471206764216f36cb458a6c",
      "content": "# path: src/train/api/api_v1/review.py\nfrom __future__ import annotations\n\nimport json\nfrom typing import Annotated, Any\n\nfrom fastapi import APIRouter, Depends, HTTPException, Request, UploadFile, File\nfrom fastapi.responses import JSONResponse, StreamingResponse\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom pydantic import BaseModel\n\nfrom src.app_logging import get_logger\nfrom src.core.models.db_helper import db_helper\nfrom src.crud.item_repository import IItemRepository, ItemRepository\nfrom src.train.services.review_service import ReviewService\nfrom src.train.services.feedback_persist_service import FeedbackPersistService\nfrom src.train.services.report_service import ReportService\nfrom src.train.utils.access import (\n    require_logged_in_session,\n    get_actor_identity,\n    is_actor_editor,\n)\nfrom src.train.models.feedback_session import FeedbackSession\nfrom src.train.models.feedback_row import FeedbackRow\nfrom src.train.models.feedback_candidate import FeedbackCandidate\n\nrouter = APIRouter()\nlog = get_logger(\"train.api.review\")\n\n\nclass ReviewCreateResponse(BaseModel):\n    session_id: int\n    redirect_url: str\n\n\ndef _safe_int(v: Any) -> int | None:\n    try:\n        return int(v)\n    except (TypeError, ValueError):\n        return None\n\n@router.get(\"/items/search\")\nasync def items_search(\n    request: Request,\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    q: str,\n    limit: int = 20,\n) -> JSONResponse:\n    \"\"\"\n    AJAX-поиск по items (для dropdown в UI).\n    Возвращает элементы, отсортированные по коду (и частично по релевантности).\n    \"\"\"\n    require_logged_in_session(request)\n\n    if not q or len(q.strip()) < 2:\n        return JSONResponse({\"items\": []})\n\n    repo: IItemRepository = ItemRepository()\n    items = await repo.search_items(session, query=q.strip(), limit=int(limit))\n\n    payload = []\n    for it in items:\n        payload.append(\n            {\n                \"id\": int(it.id),\n                \"code\": it.code,\n                \"name\": it.name,\n                \"unit\": it.unit,\n                \"type\": it.type,\n            }\n        )\n\n    return JSONResponse({\"items\": payload})\n\n\n@router.post(\"/candidates\")\nasync def candidates_for_rows(\n    request: Request,\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    body: dict[str, Any],\n) -> JSONResponse:\n    \"\"\"\n    Вернуть top-K кандидатов по caption (batch).\n    Используется при первичном рендере и при \"пересчёте\" для строки.\n    \"\"\"\n    require_logged_in_session(request)\n\n    captions = body.get(\"captions\")\n    top_k = int(body.get(\"top_k\") or 5)\n\n    if not isinstance(captions, list) or not captions:\n        raise HTTPException(status_code=400, detail=\"captions must be a non-empty list\")\n\n    item_repo: IItemRepository = ItemRepository()\n    svc = ReviewService(item_repo=item_repo)\n\n    result = await svc.get_topk_for_captions(session=session, captions=[str(c) for c in captions], top_k=top_k)\n\n    return JSONResponse({\"topk\": result})\n\n\n@router.post(\"/commit\")\nasync def commit_review_and_export_xlsx(\n    request: Request,\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    body: dict[str, Any],\n) -> StreamingResponse:\n    \"\"\"\n    \"Сформировать\":\n    1) одной транзакцией сохраняем feedback_* (trusted/draft по роли)\n    2) отдаём Excel (ВОР) на скачивание\n    \"\"\"\n    require_logged_in_session(request)\n\n    actor = get_actor_identity(request)\n    trusted = await is_actor_editor(session=session, actor_user_id=actor[\"user_id\"])\n\n    source_name = str(body.get(\"source_name\") or \"\").strip() or \"web_review\"\n    rows = body.get(\"rows\")\n\n    if not isinstance(rows, list) or not rows:\n        raise HTTPException(status_code=400, detail=\"rows must be a non-empty list\")\n\n    item_repo: IItemRepository = ItemRepository()\n    review_svc = ReviewService(item_repo=item_repo)\n\n    # нормализуем вход и валидируем\n    normalized_rows = review_svc.normalize_commit_rows(rows)\n\n    persist_svc = FeedbackPersistService(item_repo=item_repo)\n    report_svc = ReportService(item_repo=item_repo)\n\n    async with session.begin():\n        # 1) сохраняем фидбек (внутри создаст session/rows/candidates/labels)\n        feedback_session_id = await persist_svc.persist_commit(\n            session=session,\n            source_name=source_name,\n            actor_email=actor[\"email\"],\n            actor_user_id=actor[\"user_id\"],\n            is_trusted=bool(trusted),\n            rows=normalized_rows,\n        )\n\n    # 2) строим Excel из финальных выбранных item_id (и none_match)\n    xlsx_bytes = await report_svc.build_result_xlsx(\n        session=session,\n        rows=normalized_rows,\n    )\n\n    filename = f\"VOR_{feedback_session_id}.xlsx\"\n    log.info(\n        {\n            \"event\": \"review_committed\",\n            \"feedback_session_id\": int(feedback_session_id),\n            \"trusted\": bool(trusted),\n            \"rows\": len(normalized_rows),\n            \"filename\": filename,\n        }\n    )\n\n    return StreamingResponse(\n        iter([xlsx_bytes]),\n        media_type=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n        headers={\"Content-Disposition\": f'attachment; filename=\"{filename}\"'},\n    )\n\n\n@router.post(\"/review/create\", response_model=ReviewCreateResponse)\nasync def review_create(\n    request: Request,\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    file: UploadFile = File(...),\n    top_k: int = 5,\n) -> ReviewCreateResponse:\n    \"\"\"\n    1) принимаем JSON-файл (как раньше match делал через FormData)\n    2) считаем top-K кандидатов\n    3) создаём draft-сессию в БД: feedback_sessions + feedback_rows + feedback_candidates\n    4) возвращаем redirect_url на страницу ревью\n    \"\"\"\n    require_logged_in_session(request)\n\n    actor = get_actor_identity(request)\n    actor_email = str(actor.get(\"email\") or \"\")\n    actor_user_id = actor.get(\"user_id\")\n\n    raw = await file.read()\n    try:\n        data = json.loads(raw.decode(\"utf-8\"))\n    except Exception:\n        raise HTTPException(status_code=400, detail=\"Invalid JSON file\")\n\n    # поддержим оба формата: {\"items\":[...]} и просто [...]\n    items = data.get(\"items\") if isinstance(data, dict) else data\n    if not isinstance(items, list) or not items:\n        raise HTTPException(status_code=400, detail=\"JSON must contain non-empty 'items' list\")\n\n    source_name = None\n    if isinstance(data, dict):\n        source_name = str(data.get(\"source_name\") or data.get(\"source\") or \"\").strip() or None\n    if not source_name:\n        source_name = file.filename or \"web_review\"\n\n    captions: list[str] = [str(i.get(\"Caption\", \"\") or \"\") for i in items]\n    units_in: list[str | None] = [i.get(\"Units\") for i in items]\n    qty_in: list[str | None] = [i.get(\"Quantity\") for i in items]\n\n    item_repo: IItemRepository = ItemRepository()\n    review_svc = ReviewService(item_repo=item_repo)\n\n    # topk: ожидаем list[ list[dict|obj] ] по каждой caption\n    topk = await review_svc.get_topk_for_captions(\n        session=session,\n        captions=captions,\n        top_k=int(top_k),\n    )\n\n    # --- Persist draft session ---\n    async with session.begin():\n        fb_session = FeedbackSession(\n            source_name=source_name,\n            created_by=actor_email,\n            status=\"open\",\n        )\n        session.add(fb_session)\n        await session.flush()  # получаем fb_session.id\n\n        row_objs: list[FeedbackRow] = []\n        for cap, u, q in zip(captions, units_in, qty_in):\n            row_objs.append(\n                FeedbackRow(\n                    session_id=fb_session.id,\n                    caption=cap,\n                    units_in=u if u is not None else None,\n                    qty_in=q if q is not None else None,\n                    created_by=actor_email,\n                    is_trusted=False,  # draft по умолчанию\n                )\n            )\n        session.add_all(row_objs)\n        await session.flush()  # получаем row.id\n\n        cand_objs: list[FeedbackCandidate] = []\n        for row, found in zip(row_objs, topk):\n            if not found:\n                continue\n\n            for idx, cand in enumerate(found, start=1):\n                # cand может быть dict или объект qdrant\n                if isinstance(cand, dict):\n                    item_id = _safe_int(cand.get(\"item_id\") or cand.get(\"id\"))\n                    score = cand.get(\"score\")\n                else:\n                    item_id = _safe_int(getattr(cand, \"id\", None))\n                    score = getattr(cand, \"score\", None)\n\n                if item_id is None:\n                    continue\n\n                cand_objs.append(\n                    FeedbackCandidate(\n                        row_id=row.id,\n                        item_id=item_id,\n                        model_name=\"giga\",\n                        model_version=None,\n                        score=float(score) if score is not None else None,\n                        rank=int(idx),\n                        shown=True,\n                    )\n                )\n\n        if cand_objs:\n            session.add_all(cand_objs)\n\n    sid = int(fb_session.id)\n    return ReviewCreateResponse(\n        session_id=sid,\n        redirect_url=f\"/train/review/{sid}\",\n    )\n\n"
    },
    {
      "path": "src/train/models/__init__.py",
      "language": "python",
      "size_bytes": 669,
      "sha256": "09797294474bac8430641eba4ea4cceefda4764cdaebb8fad7ea5abe6273cbe8",
      "content": "# path: src/train/models/__init__.py\nfrom __future__ import annotations\n\nfrom src.train.models.enums import FeedbackLabel\nfrom src.train.models.feedback_session import FeedbackSession\nfrom src.train.models.feedback_row import FeedbackRow\nfrom src.train.models.feedback_candidate import FeedbackCandidate\nfrom src.train.models.feedback_label import FeedbackLabel as FeedbackLabelModel\nfrom src.train.models.training_run import TrainingRun\nfrom src.train.models.training_run_row import TrainingRunRow\n\n__all__ = [\n    \"FeedbackLabel\",\n    \"FeedbackSession\",\n    \"FeedbackRow\",\n    \"FeedbackCandidate\",\n    \"FeedbackLabelModel\",\n    \"TrainingRun\",\n    \"TrainingRunRow\",\n]\n"
    },
    {
      "path": "src/train/models/enums.py",
      "language": "python",
      "size_bytes": 1039,
      "sha256": "51faceeb98a8e707a68f965026bf4325f192cf3a1229ef9bd4369dd6c7206e88",
      "content": "# path: src/train/models/enums.py\nfrom __future__ import annotations\n\nfrom enum import Enum\n\n\nclass FeedbackLabel(str, Enum):\n    \"\"\"\n    Метка пользователя по строке спецификации.\n\n    Значения:\n    - gold:        пользователь выбрал корректный items.id (истина/эталон)\n    - negative:    пользователь указывает, что предложенный(е) кандидаты неверны (штраф/негативы)\n    - skip:        пользователь пропустил (не участвует в обучении)\n    - ambiguous:   неоднозначно (не участвует в обучении; можно анализировать отдельно)\n    - none_match:  ни один из кандидатов не подходит (важно, но чаще не учим как gold)\n    \"\"\"\n\n    GOLD = \"gold\"\n    NEGATIVE = \"negative\"\n    SKIP = \"skip\"\n    AMBIGUOUS = \"ambiguous\"\n    NONE_MATCH = \"none_match\"\n"
    },
    {
      "path": "src/train/models/feedback_candidate.py",
      "language": "python",
      "size_bytes": 2897,
      "sha256": "ba6567a7f8a352e71c52b462bf05d7f8923bf68bef2a19c10aa965b7f4cedd4c",
      "content": "# path: src/train/models/feedback_candidate.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom sqlalchemy import BigInteger, Boolean, DateTime, Float, ForeignKey, Index, Integer, Text, UniqueConstraint\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom sqlalchemy.sql import func\n\nfrom src.core.models.base import Base\n\n\nclass FeedbackCandidate(Base):\n    \"\"\"\n    Таблица feedback_candidates — “что именно показывали пользователю”.\n\n    Зачем нужна (критично):\n    - обучение и штрафы требуют контекста top-K:\n        * какие candidates были доступны при выборе;\n        * какие scores/ranks показала модель;\n        * какие negatives указал пользователь.\n    - без кандидатов в обучении пропадает важная информация:\n        * hard negatives (высокий скор, но неверно)\n        * анализ качества по rank/score\n\n    Поля:\n    - row_id: к какой входной строке относится candidate\n    - item_id: ссылка на items.id\n    - model_name/model_version: кто именно предсказал (важно при A/B и смене прод-версии)\n    - score/rank: показатели ранжирования\n    - shown: можно хранить “показывали ли” (если вдруг фильтруем часть кандидатов)\n    \"\"\"\n\n    __tablename__ = \"feedback_candidates\"\n\n    id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)\n\n    row_id: Mapped[int] = mapped_column(\n        BigInteger,\n        ForeignKey(\"feedback_rows.id\", ondelete=\"CASCADE\"),\n        nullable=False,\n        index=True,\n    )\n\n    item_id: Mapped[int] = mapped_column(\n        Integer,\n        ForeignKey(\"items.id\", ondelete=\"RESTRICT\"),\n        nullable=False,\n        index=True,\n    )\n\n    model_name: Mapped[str] = mapped_column(Text, nullable=False)\n    model_version: Mapped[Optional[str]] = mapped_column(Text, nullable=True)\n\n    score: Mapped[Optional[float]] = mapped_column(Float, nullable=True)\n    rank: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)\n\n    shown: Mapped[bool] = mapped_column(Boolean, nullable=False, server_default=\"true\")\n\n    created_at: Mapped[datetime] = mapped_column(\n        DateTime(timezone=True),\n        nullable=False,\n        server_default=func.now(),\n    )\n\n    # Связи\n    row = relationship(\"FeedbackRow\", back_populates=\"candidates\")\n\n    __table_args__ = (\n        UniqueConstraint(\"row_id\", \"item_id\", \"model_name\", name=\"uq_feedback_candidates_row_item_model\"),\n        Index(\"ix_feedback_candidates_row_rank\", \"row_id\", \"rank\"),\n    )\n"
    },
    {
      "path": "src/train/models/feedback_label.py",
      "language": "python",
      "size_bytes": 3465,
      "sha256": "8a09f789a8bd6f61b3d9d057b8b0aecad46b39dbf34a932ceeab4083e52ec80e",
      "content": "# path: src/train/models/feedback_label.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom sqlalchemy import BigInteger, Boolean, DateTime, ForeignKey, Index, Text, Integer\nfrom sqlalchemy.dialects.postgresql import ARRAY\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom sqlalchemy.sql import func\n\nfrom src.core.models.base import Base\nfrom src.train.models.enums import FeedbackLabel as FeedbackLabelEnum\n\n\nclass FeedbackLabel(Base):\n    \"\"\"\n    Таблица feedback_labels — “решение пользователя” по строке.\n\n    Зачем нужна:\n    - хранит фактическую разметку (gold/negative/skip/ambiguous/none_match)\n    - хранит selected_item_id для gold (истина)\n    - хранит negatives (список items.id, которые пользователь считает неверными)\n    - хранит is_trusted:\n        * is_reader -> False (draft)\n        * editor    -> True  (идёт в датасет)\n\n    Важно:\n    - Мы допускаем историю правок (несколько записей на одну row_id).\n      Экспорт датасета обычно берёт “последнюю trusted” метку (эту логику сделаем в SQL VIEW/экспорте).\n    \"\"\"\n\n    __tablename__ = \"feedback_labels\"\n\n    id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)\n\n    row_id: Mapped[int] = mapped_column(\n        BigInteger,\n        ForeignKey(\"feedback_rows.id\", ondelete=\"CASCADE\"),\n        nullable=False,\n        index=True,\n    )\n\n    # Метка\n    label: Mapped[str] = mapped_column(\n        Text,  # оставляем Text, чтобы миграции были проще; enum-тип можно добавить позже\n        nullable=False,\n    )\n\n    # Выбранный items.id (обязателен для gold; проверим в приложении/валидации)\n    selected_item_id: Mapped[Optional[int]] = mapped_column(\n        Integer,\n        ForeignKey(\"items.id\", ondelete=\"SET NULL\"),\n        nullable=True,\n        index=True,\n    )\n\n    # Негативы: список items.id, которые неверны для данной строки\n    negatives: Mapped[list[int]] = mapped_column(ARRAY(Integer), nullable=False, server_default=\"{}\")\n\n    note: Mapped[Optional[str]] = mapped_column(Text, nullable=True)\n\n    created_by: Mapped[Optional[str]] = mapped_column(Text, nullable=True)\n\n    created_at: Mapped[datetime] = mapped_column(\n        DateTime(timezone=True),\n        nullable=False,\n        server_default=func.now(),\n        index=True,\n    )\n\n    is_trusted: Mapped[bool] = mapped_column(Boolean, nullable=False, server_default=\"false\", index=True)\n\n    # Связи\n    row = relationship(\"FeedbackRow\", back_populates=\"labels\")\n\n    __table_args__ = (\n        Index(\"ix_feedback_labels_row_created_at\", \"row_id\", \"created_at\"),\n        Index(\"ix_feedback_labels_label\", \"label\"),\n    )\n\n    @staticmethod\n    def normalize_label(value: str) -> str:\n        \"\"\"\n        Нормализатор метки на случай, если форма пришлёт \"GOLD\"/\"Gold\" и т.п.\n        \"\"\"\n        v = (value or \"\").strip().lower()\n        allowed = {e.value for e in FeedbackLabelEnum}\n        return v if v in allowed else FeedbackLabelEnum.SKIP.value\n"
    },
    {
      "path": "src/train/models/feedback_row.py",
      "language": "python",
      "size_bytes": 3217,
      "sha256": "98fa9daf28123e37b35978ef7f1146ed070e5f9ac95e5023173eb89d638d366e",
      "content": "# path: src/train/models/feedback_row.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Optional, Any\n\nfrom sqlalchemy import BigInteger, Boolean, DateTime, ForeignKey, Index, Text\nfrom sqlalchemy.dialects.postgresql import JSONB\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom sqlalchemy.sql import func\n\nfrom src.core.models.base import Base\n\n\nclass FeedbackRow(Base):\n    \"\"\"\n    Таблица feedback_rows — одна входная строка (позиция спецификации), которую мы сопоставляем с items.\n\n    Зачем нужна:\n    - хранит оригинальный текст (caption) и опциональные units/qty;\n    - хранит norm_json (промежуточная нормализация/парсинг, если добавим);\n    - хранит is_trusted — доверенность данных для обучения:\n        * is_reader -> is_trusted = False (draft, “для себя”)\n        * editor    -> is_trusted = True (пойдёт в датасет)\n\n    Важно:\n    - Для обучения нам нужна связь “строка -> candidates -> label”.\n    \"\"\"\n\n    __tablename__ = \"feedback_rows\"\n\n    id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)\n\n    session_id: Mapped[Optional[int]] = mapped_column(\n        BigInteger,\n        ForeignKey(\"feedback_sessions.id\", ondelete=\"CASCADE\"),\n        nullable=True,\n        index=True,\n    )\n\n    caption: Mapped[str] = mapped_column(Text, nullable=False)\n\n    units_in: Mapped[Optional[str]] = mapped_column(Text, nullable=True)\n    qty_in: Mapped[Optional[str]] = mapped_column(Text, nullable=True)\n\n    # Нормализованный/распарсенный результат (опционально):\n    # например: выделенные диаметры, сечения, ГОСТ, бренд, напряжение, длины и т.п.\n    norm_json: Mapped[Optional[dict[str, Any]]] = mapped_column(JSONB, nullable=True)\n\n    created_by: Mapped[Optional[str]] = mapped_column(Text, nullable=True)\n\n    created_at: Mapped[datetime] = mapped_column(\n        DateTime(timezone=True),\n        nullable=False,\n        server_default=func.now(),\n        index=True,\n    )\n\n    # Доверенность: влияет на экспорт датасета\n    is_trusted: Mapped[bool] = mapped_column(Boolean, nullable=False, server_default=\"false\", index=True)\n\n    # Связи\n    session = relationship(\"FeedbackSession\", back_populates=\"rows\")\n\n    candidates = relationship(\n        \"FeedbackCandidate\",\n        back_populates=\"row\",\n        cascade=\"all, delete-orphan\",\n        passive_deletes=True,\n    )\n\n    labels = relationship(\n        \"FeedbackLabel\",\n        back_populates=\"row\",\n        cascade=\"all, delete-orphan\",\n        passive_deletes=True,\n    )\n\n    training_links = relationship(\n        \"TrainingRunRow\",\n        back_populates=\"row\",\n        cascade=\"all, delete-orphan\",\n        passive_deletes=True,\n    )\n\n    __table_args__ = (\n        Index(\"ix_feedback_rows_session_created_at\", \"session_id\", \"created_at\"),\n    )\n"
    },
    {
      "path": "src/train/models/feedback_session.py",
      "language": "python",
      "size_bytes": 1853,
      "sha256": "84adf2b002a230cceac7081dc753393dc0d6c2c3750e57a47e2ddfb3a867c3de",
      "content": "# path: src/train/models/feedback_session.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom sqlalchemy import BigInteger, DateTime, Text\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom sqlalchemy.sql import func\n\nfrom src.core.models.base import Base\n\n\nclass FeedbackSession(Base):\n    \"\"\"\n    Таблица feedback_sessions — “сессия разметки”.\n\n    Зачем нужна:\n    - группирует пачку строк спецификации под одним источником/контекстом;\n    - удобно фильтровать выгрузки датасета: по source_name, периоду, статусу open/closed;\n    - помогает трассировать “кто и когда разметил” и какие данные ушли в обучение.\n\n    Пример:\n    source_name = \"РД_объект_А_декабрь_2025\"\n    created_by  = \"user:admin@company.ru\"\n    status      = \"open\" / \"closed\"\n    \"\"\"\n\n    __tablename__ = \"feedback_sessions\"\n\n    id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)\n\n    source_name: Mapped[Optional[str]] = mapped_column(Text, nullable=True)\n    created_by: Mapped[Optional[str]] = mapped_column(Text, nullable=True)\n\n    created_at: Mapped[datetime] = mapped_column(\n        DateTime(timezone=True),\n        nullable=False,\n        server_default=func.now(),\n    )\n\n    # open|closed (пока text — проще, чем enum; можно ужесточить позже)\n    status: Mapped[str] = mapped_column(Text, nullable=False, server_default=\"open\")\n\n    # Связи\n    rows = relationship(\n        \"FeedbackRow\",\n        back_populates=\"session\",\n        cascade=\"all, delete-orphan\",\n        passive_deletes=True,\n    )\n"
    },
    {
      "path": "src/train/models/training_run.py",
      "language": "python",
      "size_bytes": 2865,
      "sha256": "bf16388284c09fbd177f38b83eeaad4db2b22a280cef5e5a8a65ed3cb438099a",
      "content": "# path: src/train/models/training_run.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Optional, Any\n\nfrom sqlalchemy import BigInteger, DateTime, Index, Text\nfrom sqlalchemy.dialects.postgresql import JSONB\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom sqlalchemy.sql import func\n\nfrom src.core.models.base import Base\n\n\nclass TrainingRun(Base):\n    \"\"\"\n    Таблица training_runs — реестр запусков обучения.\n\n    Зачем нужна:\n    - заменяет “trained boolean”: вместо флага мы фиксируем конкретный запуск обучения;\n    - позволяет воспроизводить обучение:\n        * mode (biencoder/cross/query_adapter)\n        * base_model\n        * data_spec (фильтры/параметры экспорта)\n        * artifacts_path\n        * metrics\n        * статус/логи\n\n    Типичный flow:\n    - пользователь разметил -> накопились trusted метки\n    - запускаем train -> создаём training_run (status=running)\n    - экспортируем данные -> обучаем -> пишем metrics -> status=ok/failed\n    - связываем какие строки были использованы (training_run_rows)\n    \"\"\"\n\n    __tablename__ = \"training_runs\"\n\n    id: Mapped[int] = mapped_column(BigInteger, primary_key=True, autoincrement=True)\n\n    started_at: Mapped[datetime] = mapped_column(\n        DateTime(timezone=True),\n        nullable=False,\n        server_default=func.now(),\n        index=True,\n    )\n\n    finished_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)\n\n    mode: Mapped[str] = mapped_column(Text, nullable=False)       # 'cross'|'query_adapter'|'biencoder'\n    base_model: Mapped[str] = mapped_column(Text, nullable=False) # идентификатор базовой модели\n\n    data_spec: Mapped[dict[str, Any]] = mapped_column(JSONB, nullable=False)  # фильтры, max_rows и т.д.\n\n    artifacts_path: Mapped[Optional[str]] = mapped_column(Text, nullable=True)\n    metrics: Mapped[Optional[dict[str, Any]]] = mapped_column(JSONB, nullable=True)\n\n    status: Mapped[str] = mapped_column(Text, nullable=False, server_default=\"running\")  # running|ok|failed\n    log_path: Mapped[Optional[str]] = mapped_column(Text, nullable=True)\n\n    created_by: Mapped[Optional[str]] = mapped_column(Text, nullable=True)\n\n    # Связи\n    rows = relationship(\n        \"TrainingRunRow\",\n        back_populates=\"run\",\n        cascade=\"all, delete-orphan\",\n        passive_deletes=True,\n    )\n\n    __table_args__ = (\n        Index(\"ix_training_runs_status\", \"status\"),\n        Index(\"ix_training_runs_mode_started_at\", \"mode\", \"started_at\"),\n    )\n"
    },
    {
      "path": "src/train/models/training_run_row.py",
      "language": "python",
      "size_bytes": 1821,
      "sha256": "5e1876cc93347c4c5aa6e7af203c0d39fdfd2dd244db3ebe23a2291439e4568e",
      "content": "# path: src/train/models/training_run_row.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\n\nfrom sqlalchemy import BigInteger, DateTime, ForeignKey, Index\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom sqlalchemy.sql import func\n\nfrom src.core.models.base import Base\n\n\nclass TrainingRunRow(Base):\n    \"\"\"\n    Таблица training_run_rows — связка “какие feedback_rows ушли в какой training_run”.\n\n    Зачем нужна:\n    - обеспечивает неизменяемую историю: какие именно строки были в конкретном обучении;\n    - позволяет “не мешаться” с новыми данными:\n        * при экспорте можно исключать уже использованные строки для конкретного mode/запуска\n        * можно считать покрытие и эффективность обучения по партиям\n    \"\"\"\n\n    __tablename__ = \"training_run_rows\"\n\n    run_id: Mapped[int] = mapped_column(\n        BigInteger,\n        ForeignKey(\"training_runs.id\", ondelete=\"CASCADE\"),\n        primary_key=True,\n    )\n\n    row_id: Mapped[int] = mapped_column(\n        BigInteger,\n        ForeignKey(\"feedback_rows.id\", ondelete=\"CASCADE\"),\n        primary_key=True,\n    )\n\n    added_at: Mapped[datetime] = mapped_column(\n        DateTime(timezone=True),\n        nullable=False,\n        server_default=func.now(),\n    )\n\n    # Связи\n    run = relationship(\"TrainingRun\", back_populates=\"rows\")\n    row = relationship(\"FeedbackRow\", back_populates=\"training_links\")\n\n    __table_args__ = (\n        Index(\"ix_training_run_rows_row_id\", \"row_id\"),\n        Index(\"ix_training_run_rows_run_id\", \"run_id\"),\n    )\n"
    },
    {
      "path": "src/train/schemas/__init__.py",
      "language": "python",
      "size_bytes": 855,
      "sha256": "7b3a422c90580e38ecb09908bdfcb5455db35554148b95ac3833e9fc9abb6a3e",
      "content": "# path: src/train/schemas/__init__.py\nfrom __future__ import annotations\n\nfrom src.train.schemas.common import ORMBaseSchema, AlertSchema\nfrom src.train.schemas.feedback_session import FeedbackSessionCreate, FeedbackSessionOut\nfrom src.train.schemas.feedback_row import FeedbackRowIn, FeedbackRowsCreate, FeedbackRowOut\nfrom src.train.schemas.feedback_candidate import FeedbackCandidateOut\nfrom src.train.schemas.feedback_label import FeedbackLabelCreate, FeedbackLabelOut\nfrom src.train.schemas.training_run import TrainingRunCreate, TrainingRunOut\n\n__all__ = [\n    \"ORMBaseSchema\",\n    \"AlertSchema\",\n    \"FeedbackSessionCreate\",\n    \"FeedbackSessionOut\",\n    \"FeedbackRowIn\",\n    \"FeedbackRowsCreate\",\n    \"FeedbackRowOut\",\n    \"FeedbackCandidateOut\",\n    \"FeedbackLabelCreate\",\n    \"FeedbackLabelOut\",\n    \"TrainingRunCreate\",\n    \"TrainingRunOut\",\n]\n"
    },
    {
      "path": "src/train/schemas/common.py",
      "language": "python",
      "size_bytes": 591,
      "sha256": "0de2e3e674bafc3fff9a67327160dd99f0da82e0981123ceda67aaa072755ee3",
      "content": "# path: src/train/schemas/common.py\nfrom __future__ import annotations\n\nfrom typing import Any, Optional\n\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass ORMBaseSchema(BaseModel):\n    \"\"\"\n    Базовая схема для ответов из ORM (pydantic v2).\n    \"\"\"\n    model_config = ConfigDict(from_attributes=True)\n\n\nclass AlertSchema(BaseModel):\n    \"\"\"\n    Унифицированное сообщение (если нужно для UI).\n    \"\"\"\n    kind: str = Field(..., examples=[\"success\", \"error\", \"info\"])\n    text: str\n    meta: Optional[dict[str, Any]] = None\n"
    },
    {
      "path": "src/train/schemas/feedback_candidate.py",
      "language": "python",
      "size_bytes": 567,
      "sha256": "551fa23b63bf9a75b6bf20e0336da4d1908d6e9323806f71666478c2b7c3355b",
      "content": "# path: src/train/schemas/feedback_candidate.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom src.train.schemas.common import ORMBaseSchema\n\n\nclass FeedbackCandidateOut(ORMBaseSchema):\n    \"\"\"\n    Кандидат, показанный пользователю (один элемент top-K).\n    \"\"\"\n    id: int\n    row_id: int\n    item_id: int\n    model_name: str\n    model_version: Optional[str] = None\n    score: Optional[float] = None\n    rank: Optional[int] = None\n    shown: bool\n    created_at: datetime\n"
    },
    {
      "path": "src/train/schemas/feedback_label.py",
      "language": "python",
      "size_bytes": 1290,
      "sha256": "14f4fbd258891db360323b45da7c431ced8ed9da1fc1a470e5e0de038e2abd22",
      "content": "# path: src/train/schemas/feedback_label.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import List, Optional\n\nfrom pydantic import Field\n\nfrom src.train.models.enums import FeedbackLabel\nfrom src.train.schemas.common import ORMBaseSchema\n\n\nclass FeedbackLabelCreate(ORMBaseSchema):\n    \"\"\"\n    Сохранение метки пользователем.\n\n    Правила (проверим в API/сервисах):\n    - label=gold -> selected_item_id обязателен\n    - label=negative -> negatives желательно не пустой (или хотя бы есть “ошибка top1”)\n    \"\"\"\n    row_id: int\n    label: FeedbackLabel = Field(..., examples=[FeedbackLabel.GOLD])\n    selected_item_id: Optional[int] = Field(default=None, examples=[202])\n    negatives: List[int] = Field(default_factory=list, examples=[[101, 303]])\n    note: Optional[str] = Field(default=None, examples=[\"ключ: 3×2.5 и труба\"])\n\n\nclass FeedbackLabelOut(ORMBaseSchema):\n    \"\"\"\n    Ответ по метке.\n    \"\"\"\n    id: int\n    row_id: int\n    label: str\n    selected_item_id: Optional[int] = None\n    negatives: List[int]\n    note: Optional[str] = None\n    created_by: Optional[str] = None\n    created_at: datetime\n    is_trusted: bool\n"
    },
    {
      "path": "src/train/schemas/feedback_row.py",
      "language": "python",
      "size_bytes": 1425,
      "sha256": "36035aca699bd84fdd7ac00997df340750567fff13da835f305e36ea8bac9783",
      "content": "# path: src/train/schemas/feedback_row.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Any, Optional, List\n\nfrom pydantic import Field\n\nfrom src.train.schemas.common import ORMBaseSchema\n\n\nclass FeedbackRowIn(ORMBaseSchema):\n    \"\"\"\n    Одна строка спецификации на вход в /review/rows.\n    \"\"\"\n    caption: str = Field(..., min_length=1, examples=[\"Кабель ВВГнг(А)-LS 3×2.5\"])\n    units_in: Optional[str] = Field(default=None, examples=[\"м\"])\n    qty_in: Optional[str] = Field(default=None, examples=[\"120\"])\n    norm_json: Optional[dict[str, Any]] = Field(\n        default=None,\n        description=\"Опциональный результат нормализации/парсинга (позже подключим).\",\n        examples=[{\"parsed\": {\"section\": \"3x2.5\", \"gost\": \"ГОСТ ...\"}}],\n    )\n\n\nclass FeedbackRowsCreate(ORMBaseSchema):\n    \"\"\"\n    Батч создание строк в рамках feedback_session.\n    \"\"\"\n    session_id: int\n    rows: List[FeedbackRowIn]\n\n\nclass FeedbackRowOut(ORMBaseSchema):\n    \"\"\"\n    Ответ по строке.\n    \"\"\"\n    id: int\n    session_id: Optional[int] = None\n    caption: str\n    units_in: Optional[str] = None\n    qty_in: Optional[str] = None\n    norm_json: Optional[dict[str, Any]] = None\n    created_by: Optional[str] = None\n    created_at: datetime\n    is_trusted: bool\n"
    },
    {
      "path": "src/train/schemas/feedback_session.py",
      "language": "python",
      "size_bytes": 692,
      "sha256": "92243c2bc5eae473ac48a0738de1eb8f0391efa9425c07c1cf064a9386419ca3",
      "content": "# path: src/train/schemas/feedback_session.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import Field\n\nfrom src.train.schemas.common import ORMBaseSchema\n\n\nclass FeedbackSessionCreate(ORMBaseSchema):\n    \"\"\"\n    Создание/открытие сессии разметки.\n    \"\"\"\n    source_name: Optional[str] = Field(default=None, examples=[\"РД_объект_А_декабрь_2025\"])\n\n\nclass FeedbackSessionOut(ORMBaseSchema):\n    \"\"\"\n    Ответ сессии разметки.\n    \"\"\"\n    id: int\n    source_name: Optional[str] = None\n    created_by: Optional[str] = None\n    created_at: datetime\n    status: str\n"
    },
    {
      "path": "src/train/schemas/training_run.py",
      "language": "python",
      "size_bytes": 1320,
      "sha256": "c94cc6c51966013ccf9bf991bf569af4ee0592e2f214584073e7ac82750abf4c",
      "content": "# path: src/train/schemas/training_run.py\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Any, Optional\n\nfrom pydantic import Field\n\nfrom src.train.schemas.common import ORMBaseSchema\n\n\nclass TrainingRunCreate(ORMBaseSchema):\n    \"\"\"\n    Создание запуска обучения (обычно делает воркер/таск, но API тоже может).\n    \"\"\"\n    mode: str = Field(..., examples=[\"biencoder\"])\n    base_model: str = Field(..., examples=[\"Giga-Embeddings-instruct\"])\n    data_spec: dict[str, Any] = Field(\n        default_factory=dict,\n        description=\"Фильтры и параметры выгрузки/обучения (дат, источники, max_rows и т.п.)\",\n        examples=[{\"from\": \"2025-12-01\", \"to\": \"2025-12-22\", \"only_trusted\": True, \"max_rows\": 5000}],\n    )\n    created_by: Optional[str] = None\n\n\nclass TrainingRunOut(ORMBaseSchema):\n    \"\"\"\n    Ответ по запуску обучения.\n    \"\"\"\n    id: int\n    started_at: datetime\n    finished_at: Optional[datetime] = None\n    mode: str\n    base_model: str\n    data_spec: dict[str, Any]\n    artifacts_path: Optional[str] = None\n    metrics: Optional[dict[str, Any]] = None\n    status: str\n    log_path: Optional[str] = None\n    created_by: Optional[str] = None\n"
    },
    {
      "path": "src/train/services/__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "src/train/services/feedback_persist_service.py",
      "language": "python",
      "size_bytes": 4023,
      "sha256": "f98fcd6e455654c3370ff3a5efc795e390b85d53326c50af1bfc2effafaa7765",
      "content": "# path: src/train/services/feedback_persist_service.py\nfrom __future__ import annotations\n\nfrom typing import Any, Dict, List, Optional\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.app_logging import get_logger\nfrom src.crud.item_repository import IItemRepository\nfrom src.crud.feedback_session_repository import IFeedbackSessionRepository, FeedbackSessionRepository\nfrom src.crud.feedback_row_repository import IFeedbackRowRepository, FeedbackRowRepository\nfrom src.crud.feedback_candidate_repository import IFeedbackCandidateRepository, FeedbackCandidateRepository\nfrom src.crud.feedback_label_repository import IFeedbackLabelRepository, FeedbackLabelRepository\nfrom src.train.services.review_service import ReviewService\n\n\nlog = get_logger(\"train.feedback_persist\")\n\n\nclass FeedbackPersistService:\n    \"\"\"\n    Сохранение итогов ревью в feedback_*.\n\n    Стратегия:\n    - создаём feedback_session\n    - создаём feedback_rows\n    - считаем top-K заново (чтобы гарантированно сохранить “что показывали”)\n    - сохраняем feedback_candidates\n    - сохраняем feedback_labels (trusted/draft по роли)\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        item_repo: IItemRepository,\n        session_repo: IFeedbackSessionRepository | None = None,\n        row_repo: IFeedbackRowRepository | None = None,\n        candidate_repo: IFeedbackCandidateRepository | None = None,\n        label_repo: IFeedbackLabelRepository | None = None,\n    ) -> None:\n        self._item_repo = item_repo\n        self._session_repo = session_repo or FeedbackSessionRepository()\n        self._row_repo = row_repo or FeedbackRowRepository()\n        self._candidate_repo = candidate_repo or FeedbackCandidateRepository()\n        self._label_repo = label_repo or FeedbackLabelRepository()\n\n    async def persist_commit(\n        self,\n        *,\n        session: AsyncSession,\n        source_name: str,\n        actor_email: str,\n        actor_user_id: int,\n        is_trusted: bool,\n        rows: list[dict[str, Any]],\n        top_k: int = 5,\n    ) -> int:\n        # 1) создаём feedback_session\n        fb_session = await self._session_repo.create(\n            session=session,\n            source_name=source_name,\n            created_by=str(actor_email),\n        )\n\n        # 2) строки\n        fb_rows = await self._row_repo.bulk_create(\n            session=session,\n            session_id=int(fb_session.id),\n            rows=rows,\n        )\n\n        # 3) пересчёт top-K и сохранение кандидатов\n        review_svc = ReviewService(item_repo=self._item_repo)\n        captions = [str(r.get(\"caption\", \"\") or \"\") for r in rows]\n        topk = await review_svc.get_topk_for_captions(session=session, captions=captions, top_k=int(top_k))\n\n        # row_id привязываем по индексу (row_idx сохраняем, чтобы потом сверяться)\n        row_id_by_idx: dict[int, int] = {}\n        for r_model in fb_rows:\n            row_id_by_idx[int(r_model.row_idx)] = int(r_model.id)\n\n        await self._candidate_repo.bulk_create_from_topk(\n            session=session,\n            topk=topk,\n            row_id_by_idx=row_id_by_idx,\n            model_name=\"giga\",\n        )\n\n        # 4) labels\n        await self._label_repo.bulk_create_from_commit(\n            session=session,\n            rows=rows,\n            row_id_by_idx=row_id_by_idx,\n            created_by=str(actor_email),\n            is_trusted=bool(is_trusted),\n        )\n\n        # 5) закрываем сессию\n        await self._session_repo.close(session=session, session_id=int(fb_session.id))\n\n        log.info(\n            {\n                \"event\": \"feedback_saved\",\n                \"feedback_session_id\": int(fb_session.id),\n                \"rows\": len(rows),\n                \"trusted\": bool(is_trusted),\n            }\n        )\n        return int(fb_session.id)\n"
    },
    {
      "path": "src/train/services/report_service.py",
      "language": "python",
      "size_bytes": 1903,
      "sha256": "f6718dbe498d616080bf39705542e92f3fd163fc555b45a191470b0a88af59e1",
      "content": "# path: src/train/services/report_service.py\nfrom __future__ import annotations\n\nimport io\nfrom typing import Any, Dict, List\n\nfrom openpyxl import Workbook\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.crud.item_repository import IItemRepository\n\n\nclass ReportService:\n    \"\"\"\n    Формирование Excel-отчёта (ВОР) из финального выбора пользователя.\n    На текущем срезе — минимально: Caption + выбранная позиция ФСНБ (code/name/unit) + Units/Qty.\n    \"\"\"\n\n    def __init__(self, item_repo: IItemRepository) -> None:\n        self._item_repo = item_repo\n\n    async def build_result_xlsx(self, *, session: AsyncSession, rows: list[dict[str, Any]]) -> bytes:\n        selected_ids: list[int] = []\n        for r in rows:\n            sid = r.get(\"selected_item_id\")\n            if isinstance(sid, int):\n                selected_ids.append(int(sid))\n\n        meta = await self._item_repo.fetch_items_meta_by_ids(session, list(dict.fromkeys(selected_ids)))\n\n        wb = Workbook()\n        ws = wb.active\n        ws.title = \"VOR\"\n\n        headers = [\n            \"Caption\",\n            \"FSNB Name\",\n            \"FSNB code\",\n            \"Units\",\n            \"FSNB Units\",\n            \"Quantity\",\n            \"Label\",\n        ]\n        ws.append(headers)\n\n        for r in rows:\n            caption = r.get(\"caption\", \"\")\n            units = r.get(\"units\")\n            qty = r.get(\"qty\")\n            label = r.get(\"label\", \"\")\n\n            sid = r.get(\"selected_item_id\")\n            if isinstance(sid, int) and sid in meta:\n                name, fsnb_unit, code = meta[sid]\n            else:\n                name, fsnb_unit, code = None, None, None\n\n            ws.append([caption, name, code, units, fsnb_unit, qty, label])\n\n        buf = io.BytesIO()\n        wb.save(buf)\n        return buf.getvalue()\n"
    },
    {
      "path": "src/train/services/review_service.py",
      "language": "python",
      "size_bytes": 6868,
      "sha256": "81facae1e8ce32e1ef3cc432c643a86d11f27e501ec6d90558a5f5be3def6cdb",
      "content": "# path: src/train/services/review_service.py\nfrom __future__ import annotations\n\nimport asyncio\nfrom typing import Any, Dict, List, Optional\n\nfrom src.app_logging import get_logger\nfrom src.crud.item_repository import IItemRepository\nfrom src.fsnb_matcher.services.matcher_service import _qdrant_search, _embed_captions, _get_collection_name, _safe_int\n\n\nlog = get_logger(\"train.review_service\")\n\n\nclass ReviewService:\n    \"\"\"\n    Сервис “подготовки данных для ревью”.\n\n    Важно:\n    - Не пишет в БД.\n    - Даёт top-K кандидатов и структуру строк для Jinja/JS.\n    \"\"\"\n\n    def __init__(self, item_repo: IItemRepository) -> None:\n        self._item_repo = item_repo\n\n    async def get_topk_for_captions(\n        self,\n        *,\n        session,\n        captions: List[str],\n        top_k: int,\n    ) -> list[list[dict[str, Any]]]:\n        \"\"\"\n        Возвращает top-K кандидатов на каждый caption:\n        [[{id, score, rank, code, name, unit, type}, ...], ...]\n        \"\"\"\n        captions_clean = [str(c or \"\") for c in captions]\n        vectors = await _embed_captions(captions_clean)\n\n        collection = _get_collection_name()\n        searches = await _qdrant_search(collection_name=collection, vectors=vectors, top_k=int(top_k))\n\n        # собираем все item_id (по всем строкам), чтобы одним батчем добрать meta\n        all_ids: list[int] = []\n        per_row_ids: list[list[Optional[int]]] = []\n\n        for found in searches:\n            row_ids: list[Optional[int]] = []\n            for rank, point in enumerate(found, start=1):\n                pid = _safe_int(getattr(point, \"id\", None))\n                row_ids.append(pid)\n                if pid is not None:\n                    all_ids.append(int(pid))\n            per_row_ids.append(row_ids)\n\n        meta_map = await self._item_repo.fetch_items_meta_by_ids(session, list(dict.fromkeys(all_ids)))\n\n        result: list[list[dict[str, Any]]] = []\n        for row_idx, found in enumerate(searches):\n            row_payload: list[dict[str, Any]] = []\n            for rank, point in enumerate(found, start=1):\n                pid = _safe_int(getattr(point, \"id\", None))\n                score = float(getattr(point, \"score\", 0.0))\n\n                code = None\n                name = None\n                unit = None\n                itype = None\n\n                if pid is not None and pid in meta_map:\n                    name, unit, code = meta_map[pid]\n                    # type нам тут не отдают meta_map — если нужно, добавим позднее.\n                    # Сейчас достаточно code/name/unit.\n                    itype = None\n\n                row_payload.append(\n                    {\n                        \"id\": pid,\n                        \"score\": score,\n                        \"rank\": int(rank),\n                        \"code\": code,\n                        \"name\": name,\n                        \"unit\": unit,\n                        \"type\": itype,\n                    }\n                )\n            result.append(row_payload)\n\n        return result\n\n    async def build_initial_view_rows(\n        self,\n        *,\n        session,\n        rows: list[dict[str, Any]],\n        top_k: int,\n    ) -> list[dict[str, Any]]:\n        \"\"\"\n        Подготовка строк для Jinja.\n        Каждая строка получает:\n          - candidates: top-K\n          - auto_selected_item_id: top1 id (если есть)\n          - label: по умолчанию gold, а если кандидатов нет — none_match\n        \"\"\"\n        captions = [str(r.get(\"caption\", \"\") or \"\") for r in rows]\n        topk = await self.get_topk_for_captions(session=session, captions=captions, top_k=int(top_k))\n\n        view_rows: list[dict[str, Any]] = []\n        for idx, r in enumerate(rows):\n            candidates = topk[idx] if idx < len(topk) else []\n            auto_id = candidates[0][\"id\"] if candidates and candidates[0].get(\"id\") is not None else None\n            auto_label = \"gold\" if auto_id is not None else \"none_match\"\n\n            view_rows.append(\n                {\n                    \"row_idx\": idx,\n                    \"caption\": r.get(\"caption\", \"\"),\n                    \"units\": r.get(\"units\"),\n                    \"qty\": r.get(\"qty\"),\n                    \"candidates\": candidates,\n                    \"auto_selected_item_id\": auto_id,\n                    \"selected_item_id\": auto_id,  # текущий выбор (в JS может меняться)\n                    \"label\": auto_label,\n                    \"note\": \"\",\n                }\n            )\n\n        return view_rows\n\n    def normalize_commit_rows(self, rows: list[dict[str, Any]]) -> list[dict[str, Any]]:\n        \"\"\"\n        Валидация/нормализация payload из UI при commit.\n        \"\"\"\n        out: list[dict[str, Any]] = []\n        for idx, r in enumerate(rows):\n            if not isinstance(r, dict):\n                continue\n\n            caption = str(r.get(\"caption\", \"\") or \"\")\n            units = r.get(\"units\")\n            qty = r.get(\"qty\")\n            label = str(r.get(\"label\", \"\") or \"\").strip() or \"gold\"\n\n            selected_item_id = r.get(\"selected_item_id\", None)\n            auto_selected_item_id = r.get(\"auto_selected_item_id\", None)\n\n            note = str(r.get(\"note\", \"\") or \"\").strip() or None\n            negatives = r.get(\"negatives\", [])\n\n            # минимальная нормализация типов\n            def _to_int_or_none(v):\n                try:\n                    return int(v) if v is not None and str(v).strip() != \"\" else None\n                except Exception:\n                    return None\n\n            selected_item_id = _to_int_or_none(selected_item_id)\n            auto_selected_item_id = _to_int_or_none(auto_selected_item_id)\n\n            neg_ids: list[int] = []\n            if isinstance(negatives, list):\n                for n in negatives:\n                    ni = _to_int_or_none(n)\n                    if ni is not None:\n                        neg_ids.append(int(ni))\n\n            out.append(\n                {\n                    \"row_idx\": int(r.get(\"row_idx\", idx)),\n                    \"caption\": caption,\n                    \"units\": str(units) if units is not None and str(units).strip() != \"\" else None,\n                    \"qty\": str(qty) if qty is not None and str(qty).strip() != \"\" else None,\n                    \"label\": label,\n                    \"selected_item_id\": selected_item_id,\n                    \"auto_selected_item_id\": auto_selected_item_id,\n                    \"negatives\": neg_ids,\n                    \"note\": note,\n                }\n            )\n        return out\n"
    },
    {
      "path": "src/train/utils/__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "src/train/utils/access.py",
      "language": "python",
      "size_bytes": 1621,
      "sha256": "1755b17a8889114666fce43c55187c90fd8211e0816c9dd3622c2b8a9ce4d5a4",
      "content": "# path: src/train/utils/access.py\nfrom __future__ import annotations\n\nfrom typing import Any, Dict\n\nfrom fastapi import HTTPException, Request, status\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.crud.permission_repository import PermissionRepository\n\n\ndef require_logged_in_session(request: Request) -> None:\n    \"\"\"\n    Для web/Jinja мы используем cookie-session.\n    Считаем, что логин кладёт:\n      - user_id\n      - user_email\n      - access_token (JWT, но для HTML нам достаточно user_id/email)\n    \"\"\"\n    user_id = request.session.get(\"user_id\")\n    user_email = request.session.get(\"user_email\")\n    if not user_id or not user_email:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated\")\n\n\ndef get_actor_identity(request: Request) -> Dict[str, Any]:\n    \"\"\"\n    Единый формат “кто совершил действие”.\n    \"\"\"\n    require_logged_in_session(request)\n    return {\n        \"user_id\": int(request.session[\"user_id\"]),\n        \"email\": str(request.session[\"user_email\"]),\n    }\n\n\nasync def is_actor_editor(session: AsyncSession, actor_user_id: int) -> bool:\n    \"\"\"\n    editor = is_superadmin | is_admin | is_staff | is_updater\n    \"\"\"\n    repo = PermissionRepository()\n    perm = await repo.get_for_user_id(session=session, user_id=int(actor_user_id))\n    if not perm:\n        return False\n    return bool(getattr(perm, \"is_superadmin\", False) or getattr(perm, \"is_admin\", False)\n                or getattr(perm, \"is_staff\", False) or getattr(perm, \"is_updater\", False))\n"
    },
    {
      "path": "src/train/views/__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "src/train/views/review.py",
      "language": "python",
      "size_bytes": 4259,
      "sha256": "4a488b4044c3cf989a532d2f40840d0d52ac353aefd2b7689ab65473b58db9ac",
      "content": "# path: src/train/views/review.py\nfrom __future__ import annotations\n\nimport json\nimport secrets\nfrom pathlib import Path\nfrom typing import Annotated, Any\n\nfrom fastapi import APIRouter, Depends, File, Form, Request, UploadFile, status\nfrom fastapi.responses import RedirectResponse\nfrom fastapi.templating import Jinja2Templates\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom src.app_logging import get_logger\nfrom src.core.models.db_helper import db_helper\nfrom src.crud.item_repository import IItemRepository, ItemRepository\nfrom src.train.services.review_service import ReviewService\nfrom src.train.utils.access import require_logged_in_session\n\n\nrouter = APIRouter()\nlog = get_logger(\"train.views.review\")\n\nPROJECT_DIR = Path(__file__).resolve().parents[2]  # /app/src\nTEMPLATES_DIR = PROJECT_DIR / \"templates\"\ntemplates = Jinja2Templates(directory=str(TEMPLATES_DIR))\n\n\ndef _ensure_csrf(request: Request) -> str:\n    token = request.session.get(\"review_csrf\")\n    if not token:\n        token = secrets.token_urlsafe(16)\n        request.session[\"review_csrf\"] = token\n    return token\n\n\n@router.get(\"/review\", name=\"review_upload_get\")\nasync def review_upload_get(request: Request):\n    \"\"\"\n    Стартовая страница: загрузка JSON спецификации.\n    Ничего в БД не пишем.\n    \"\"\"\n    require_logged_in_session(request)\n    csrf = _ensure_csrf(request)\n\n    return templates.TemplateResponse(\n        \"train/review_upload.html\",\n        {\"request\": request, \"csrf\": csrf},\n    )\n\n\n@router.post(\"/review\", name=\"review_upload_post\")\nasync def review_upload_post(\n    request: Request,\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    csrf_token: Annotated[str, Form(...)],\n    spec_file: Annotated[UploadFile, File(...)],\n    top_k: Annotated[int, Form()] = 5,\n):\n    \"\"\"\n    Принимаем JSON спецификацию, рендерим таблицу с top-K.\n    Ничего в БД не пишем (JS state живёт на клиенте).\n    \"\"\"\n    require_logged_in_session(request)\n\n    if csrf_token != request.session.get(\"review_csrf\"):\n        return RedirectResponse(url=\"/review\", status_code=status.HTTP_303_SEE_OTHER)\n\n    content = await spec_file.read()\n    try:\n        payload = json.loads(content.decode(\"utf-8\", errors=\"ignore\"))\n    except Exception:\n        return templates.TemplateResponse(\n            \"train/review_upload.html\",\n            {\n                \"request\": request,\n                \"csrf\": _ensure_csrf(request),\n                \"alert\": {\"kind\": \"error\", \"text\": \"Не удалось прочитать JSON.\"},\n            },\n            status_code=400,\n        )\n\n    items = payload.get(\"items\")\n    if not isinstance(items, list) or not items:\n        return templates.TemplateResponse(\n            \"train/review_upload.html\",\n            {\n                \"request\": request,\n                \"csrf\": _ensure_csrf(request),\n                \"alert\": {\"kind\": \"error\", \"text\": \"В JSON нет массива items.\"},\n            },\n            status_code=400,\n        )\n\n    # caption/units/qty берём “как есть” (без нормализации)\n    rows: list[dict[str, Any]] = []\n    for it in items:\n        if not isinstance(it, dict):\n            continue\n        rows.append(\n            {\n                \"caption\": str(it.get(\"Caption\", \"\") or \"\"),\n                \"units\": str(it.get(\"Units\", \"\") or \"\") or None,\n                \"qty\": str(it.get(\"Quantity\", \"\") or \"\") or None,\n            }\n        )\n\n    item_repo: IItemRepository = ItemRepository()\n    svc = ReviewService(item_repo=item_repo)\n\n    # top-K кандидаты и “auto” = top1\n    view_rows = await svc.build_initial_view_rows(\n        session=session,\n        rows=rows,\n        top_k=int(top_k),\n    )\n\n    csrf = _ensure_csrf(request)\n\n    log.info({\"event\": \"review_rendered\", \"rows\": len(view_rows), \"top_k\": int(top_k)})\n\n    return templates.TemplateResponse(\n        \"train/review_table.html\",\n        {\n            \"request\": request,\n            \"csrf\": csrf,\n            \"source_name\": spec_file.filename or \"web_upload\",\n            \"rows\": view_rows,\n            \"top_k\": int(top_k),\n        },\n    )\n"
    },
    {
      "path": "static/css/style.css",
      "language": "css",
      "size_bytes": 8309,
      "sha256": "927f6861f4de487c27e9ba7afcdc137bb663182b650c7e48da0d9be0bf23fc31",
      "content": "/* /static/css/style.css */\n\n/* 1) Variables */\n:root {\n  --gap: 16px;\n  --radius: 10px;\n  --ok: #19a974;\n  --ok-bg: #e6fbf2;\n  --err: #d33;\n  --err-bg: #fdecec;\n}\n\n/* 2) Base */\n*,\n*::before,\n*::after {\n  box-sizing: border-box;\n}\nbody {\n  margin: 0;\n  font-family: system-ui, -apple-system, \"Segoe UI\", Roboto, sans-serif;\n  color: #111;\n  background: #fafafa;\n}\na {\n  color: #0366d6;\n  text-decoration: none;\n}\na:hover {\n  text-decoration: underline;\n}\n\n/* 3) Layout */\n.container {\n  max-width: 1000px;\n  margin: 0 auto;\n  padding: var(--gap);\n}\n\n/* Header / Navbar */\n.header {\n  background: #fff;\n  border-bottom: 1px solid #eee;\n}\n.header-inner {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  gap: var(--gap);\n}\n.brand {\n  font-weight: 700;\n}\n.nav-list {\n  display: flex;\n  align-items: center;\n  gap: 12px;\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n.nav-item {\n  display: flex;\n  align-items: center;\n}\n.nav-logout {\n  background: none;\n  border: 0;\n  padding: 0;\n  cursor: pointer;\n  text-decoration: underline;\n  font: inherit;\n}\n\n/* Back-compat для старой разметки шапки */\n.navbar {\n  display: flex;\n  align-items: center;\n  gap: var(--gap);\n}\n.navbar .brand {\n  font-weight: 700;\n}\n.spacer {\n  flex: 1;\n}\n\n/* 4) Tables */\n.table {\n  width: 100%;\n  border-collapse: collapse;\n}\n.table th,\n.table td {\n  border: 1px solid #ddd;\n  padding: 8px;\n}\n.table th {\n  background: #f3f3f3;\n  text-align: left;\n}\n\n/* 5) Forms */\n.form-row {\n  display: flex;\n  align-items: center;\n  gap: 12px;\n  margin-bottom: 12px;\n}\n.form-row > label {\n  flex: 0 0 180px; /* фиксированная ширина подписи */\n}\n.form-row > input,\n.form-row > select,\n.form-row > textarea {\n  flex: 1 1 auto;\n  min-width: 0;\n}\ninput[type=\"text\"],\ninput[type=\"email\"],\ninput[type=\"password\"],\ninput[type=\"number\"],\nselect,\ntextarea {\n  padding: 10px;\n  border: 1px solid #ccc;\n  border-radius: var(--radius);\n  background: #fff;\n}\n\n/* 6) Buttons */\n.btn {\n  padding: 8px 14px;\n  border-radius: var(--radius);\n  border: 1px solid #ccc;\n  background: #fff;\n  cursor: pointer;\n}\n.btn:hover {\n  filter: brightness(0.98);\n}\n.btn-primary {\n  border-color: #0366d6;\n  background: #0366d6;\n  color: #fff;\n}\n\n/* 7) Alerts */\n.alert {\n  margin-bottom: var(--gap);\n  padding: 12px 14px;\n  border-radius: var(--radius);\n  border: 2px solid transparent;\n}\n.alert.success {\n  border-color: var(--ok);\n  background: var(--ok-bg);\n}\n.alert.error {\n  border-color: var(--err);\n  background: var(--err-bg);\n}\n/* Карточка под шапкой профиля */\n.card{\n  background:#fff;\n  border:1px solid #eee;\n  border-radius:var(--radius);\n  padding:16px;\n  margin-bottom:16px;\n}\n\n/* Общая обёртка формы профиля (ширина как у регистрации) */\n.profile-form{\n  max-width:640px;\n}\n\n/* Сетка строк формы уже задана .form-row (align, gap, mb) — используем её.\n   Чтобы поле \"прилипало\" к правому краю строки, инпут растягиваем на всю ширину. */\n.form-row > input,\n.form-row > select,\n.form-row > textarea{\n  width:100%;\n}\n\n/* Правое выравнивание текста внутри инпутов */\n.input-stick-right{\n  text-align:right;\n}\n\n/* Ячейка для аватара: превью + input:file по правому краю */\n.avatar-cell{\n  display:flex;\n  flex-direction:column;\n  align-items:flex-end; /* прижать к правому краю */\n  gap:8px;\n}\n\n/* Превью аватара компактнее и с округлением */\n.avatar-preview img{\n  max-height:120px;\n  border-radius:8px;\n  display:block;\n}\n\n/* Ряд с кнопкой — кнопка у правого края */\n.form-actions{\n  display:flex;\n  justify-content:flex-end;\n  margin-top:8px;\n}\n/* Заголовок профиля с мини-аватаром справа */\n.profile-head{\n  display:flex;\n  align-items:center;\n  justify-content:space-between;\n  gap:12px;\n  margin-bottom:12px;\n}\n\n.profile-head-avatar{\n  width:40px;\n  height:40px;\n  border-radius:50%;\n  object-fit:cover;\n  border:1px solid #e5e5e5;\n  background:#fff;\n}\n.btn-danger { border-color: #d33; background: #d33; color: #fff; }\n/* Профиль: заголовок и мини-аватар справа */\n.title-row {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  gap: var(--gap);\n  margin-bottom: var(--gap);\n}\n\n/* Правая колонка в заголовке (мини-аватар + кнопка удаления) */\n.title-right {\n  display: flex;\n  flex-direction: column;\n  align-items: flex-end;\n  gap: 6px;\n}\n\n.avatar-mini {\n  border-radius: 50%;\n  object-fit: cover;\n}\n\n/* Кнопка маленького размера (для удаления аватара под мини-аватаром) */\n.btn-xs {\n  padding: 4px 8px;\n  font-size: 12px;\n}\n\n/* Красная кнопка */\n.btn-danger {\n  border: 1px solid #d33;\n  background: #d33;\n  color: #fff;\n}\n\n/* Зона загрузки аватара в форме */\n.avatar-uploader {\n  display: flex;\n  align-items: center;\n  gap: 12px;\n  flex-wrap: wrap;\n}\n\n.avatar-preview img {\n  max-height: 120px;\n  width: auto;\n  border-radius: 8px;\n  object-fit: cover;\n  display: block;\n}\n\n.avatar-controls {\n  display: flex;\n  align-items: center;\n  flex-wrap: wrap;\n  gap: 8px;\n}\n\n.avatar-controls .hint {\n  opacity: 0.8;\n  font-size: 12px;\n}\n\n.filename {\n  font-size: 12px;\n  opacity: 0.9;\n}\n\n.table-wrap { overflow-x: auto; }\n.admin-models { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 12px; }\n.admin-model { display: block; padding: 12px; border-radius: var(--radius); background: #fff; border: 1px solid #eee; }\n.admin-model__name { font-weight: 700; margin-bottom: 6px; }\n\n\n\n/* path: static/css/style.css */\n\n/* ✅ ДОБАВИТЬ (если нет): универсальный helper */\n.hidden {\n  display: none !important;\n}\n\n/* ✅ ДОБАВИТЬ: подтверждение выбранного файла */\n.file-info {\n  margin-top: 8px;\n  font-size: 13px;\n  opacity: 0.85;\n}\n\n/* ✅ ДОБАВИТЬ: модальное окно */\n.modal {\n  position: fixed;\n  inset: 0;\n  background: rgba(0, 0, 0, 0.35);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  z-index: 9999;\n}\n\n.modal-content {\n  background: #fff;\n  padding: 18px 22px;\n  border-radius: 12px;\n  text-align: center;\n  width: 240px;\n}\n\n.modal-text {\n  margin: 8px 0 0;\n  font-size: 14px;\n}\n\n/* ✅ ДОБАВИТЬ: \"котёнок\" (маленький круг ~ 24px < 1см) */\n.cat-spinner {\n  width: 24px;\n  height: 24px;\n  margin: 0 auto 10px;\n  position: relative;\n  border-radius: 50%;\n  border: 2px solid rgba(0,0,0,0.12);\n  animation: cat-rotate 0.9s linear infinite;\n}\n\n.cat-spinner::before {\n  content: \"🐱\";\n  position: absolute;\n  left: 50%;\n  top: -6px;\n  transform: translateX(-50%);\n  font-size: 14px;\n}\n\n@keyframes cat-rotate {\n  to { transform: rotate(360deg); }\n}\n\n\n/* path: static/css/style.css */\n\n/* Модалка */\n.modal { position: fixed; inset: 0; z-index: 9999; }\n.modal__backdrop { position: absolute; inset: 0; background: rgba(0,0,0,.45); }\n.modal__content{\n  position:absolute; left:50%; top:50%;\n  transform: translate(-50%,-50%);\n  background:#111; color:#fff;\n  border-radius: 14px;\n  padding: 18px 20px;\n  min-width: 260px;\n  display:flex; flex-direction:column; align-items:center; gap:10px;\n}\n\n/* Котёнок гоняется по кругу (~ 1см) */\n.kitty-spinner{\n  width: 1cm;\n  height: 1cm;\n  position: relative;\n  border-radius: 50%;\n  border: 2px solid rgba(255,255,255,.25);\n}\n\n/* “Хвост” — точка на круге */\n.kitty-spinner::after{\n  content: \"•\";\n  position: absolute;\n  left: 50%;\n  top: 6%;\n  transform: translateX(-50%);\n  font-size: 14px;\n  color: rgba(255,255,255,.9);\n}\n\n/* Орбита кота */\n.kitty-orbit{\n  position: absolute;\n  inset: 0;\n  animation: kitty-orbit 0.9s linear infinite;\n}\n\n/* Сам кот */\n.kitty{\n  position: absolute;\n  left: 50%;\n  top: 0%;\n  transform: translate(-50%, -55%);\n  font-size: 16px;\n  line-height: 1;\n}\n\n@keyframes kitty-orbit{\n  to { transform: rotate(360deg); }\n}\n"
    },
    {
      "path": "static/js/app.js",
      "language": "javascript",
      "size_bytes": 122,
      "sha256": "8766499306abae5f9b5a07a4a2fc3a75e84b8b4699bb989c1fc7a6120843dd26",
      "content": "// /static/js/app.js\nwindow.addEventListener(\"DOMContentLoaded\", () => {\n  console.debug(\"[fsnb-fastapi] dom-ready\");\n});\n"
    },
    {
      "path": "static/js/avatar-preview.js",
      "language": "javascript",
      "size_bytes": 1754,
      "sha256": "15a87545332ca802c4b0542da0e59da7fa77707397feb4cb574b92b4c11a7a91",
      "content": "// /static/js/avatar-preview.js\n(function () {\n  const fi = document.getElementById('avatar-input');\n  const out = document.getElementById('avatar-filename');\n  const previewLarge = document.getElementById('avatar-preview-img');\n  const previewMini = document.getElementById('avatar-mini');\n\n  if (!fi) return;\n\n  const MAX_BYTES = 3 * 1024 * 1024;  // 3MB\n  const MIN_W = 40, MIN_H = 40;\n\n  function showAlert(msg) {\n    alert(msg);\n  }\n\n  fi.addEventListener('change', () => {\n    const file = fi.files && fi.files[0] ? fi.files[0] : null;\n    if (out) out.textContent = file ? file.name : '';\n    if (!file) return;\n\n    if (file.size > MAX_BYTES) {\n      showAlert('Файл слишком большой. Максимум 3 МБ.');\n      fi.value = '';\n      if (out) out.textContent = '';\n      return;\n    }\n\n    const url = URL.createObjectURL(file);\n    const img = new Image();\n    img.onload = () => {\n      if (img.width < MIN_W || img.height < MIN_H) {\n        showAlert('Минимальный размер изображения — 40×40 пикселей.');\n        URL.revokeObjectURL(url);\n        fi.value = '';\n        if (out) out.textContent = '';\n        return;\n      }\n      // Мгновенный предпросмотр (без сохранения на сервере)\n      if (previewLarge) previewLarge.src = url;\n      if (previewMini) previewMini.src = url;\n      // URL будет отревокнут после перезагрузки страницы\n    };\n    img.onerror = () => {\n      showAlert('Не удалось прочитать файл как изображение.');\n      fi.value = '';\n      if (out) out.textContent = '';\n      URL.revokeObjectURL(url);\n    };\n    img.src = url;\n  });\n})();\n"
    },
    {
      "path": "static/js/fsnb_matcher.js",
      "language": "javascript",
      "size_bytes": 2733,
      "sha256": "0766b5923a707576309b11b549cc43193658a31d4d7f5b410ebab3d91ff508aa",
      "content": "// path: static/js/fsnb_matcher.js\n\n(function () {\n  function $(id) { return document.getElementById(id); }\n\n  function showModal() {\n    const m = $(\"fsnb-modal\");\n    if (!m) return;\n    m.style.display = \"block\";\n    m.setAttribute(\"aria-hidden\", \"false\");\n  }\n\n  function hideModal() {\n    const m = $(\"fsnb-modal\");\n    if (!m) return;\n    m.style.display = \"none\";\n    m.setAttribute(\"aria-hidden\", \"true\");\n  }\n\n  function showError(text) {\n    const el = $(\"fsnb-error\");\n    if (!el) return;\n    el.textContent = text;\n    el.style.display = \"block\";\n  }\n\n  function clearError() {\n    const el = $(\"fsnb-error\");\n    if (!el) return;\n    el.textContent = \"\";\n    el.style.display = \"none\";\n  }\n\n  function filenameFromDisposition(disposition) {\n    if (!disposition) return null;\n    // attachment; filename=\"smeta.xlsx\"\n    const m = /filename\\*?=(?:UTF-8''|\")?([^\\\";]+)/i.exec(disposition);\n    if (!m) return null;\n    try { return decodeURIComponent(m[1].replace(/\"/g, \"\")); } catch { return m[1].replace(/\"/g, \"\"); }\n  }\n\n  document.addEventListener(\"DOMContentLoaded\", () => {\n    const form = $(\"fsnb-match-form\");\n    const fileInput = $(\"fsnb-file\");\n    const status = $(\"fsnb-file-status\");\n\n    if (!form || !fileInput) return;\n\n    fileInput.addEventListener(\"change\", () => {\n      clearError();\n      const f = fileInput.files && fileInput.files[0];\n      if (status) status.textContent = f ? `Выбран: ${f.name}` : \"Файл не выбран\";\n    });\n\n    form.addEventListener(\"submit\", async (e) => {\n      e.preventDefault();\n      clearError();\n\n      const f = fileInput.files && fileInput.files[0];\n      if (!f) {\n        showError(\"Выбери JSON-файл перед сопоставлением.\");\n        return;\n      }\n\n      const fd = new FormData();\n      fd.append(\"file\", f);\n\n      showModal();\n\n      try {\n        const resp = await fetch(\"/api/v1/train/review/create\", {\n          method: \"POST\",\n          body: fd,\n          credentials: \"include\",\n        });\n\n        if (!resp.ok) {\n          let detail = `Ошибка сопоставления: HTTP ${resp.status}`;\n          try {\n            const data = await resp.json();\n            if (data && data.detail) detail = String(data.detail);\n          } catch (_) {}\n          throw new Error(detail);\n        }\n\n        const data = await resp.json();\n        if (!data || !data.redirect_url) {\n          throw new Error(\"Сервер не вернул redirect_url\");\n        }\n        window.location.href = data.redirect_url;\n\n      } catch (err) {\n        showError(err?.message ? String(err.message) : \"Неизвестная ошибка\");\n      } finally {\n        hideModal();\n      }\n    });\n  });\n})();\n"
    }
  ]
}