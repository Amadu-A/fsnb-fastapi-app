{
  "meta": {
    "generated_at_utc": "2025-12-09T11:56:32Z",
    "root": "/home/main/PycharmProjects/fsnb-fastapi-app",
    "tool": "dump_project.py",
    "max_file_bytes": 500000,
    "total_files": 47
  },
  "context": {
    "project_description": "Краткое описание проекта, архитектура, стек, цели.",
    "static_instructions": [
      "Это команды для обсуждения, rewie, улучшения, оптимизации, модернизации и исправления кода для распознавания pdf-файлов с помощью парсинга и обучения YOLO модели и подготовке на основе этих данных отчетов в excel.",
      "Проанализируй весь код проекта, разберись, что и с чем связано.",
      "Каждый файл, который ты подготовишь, должен быть заполнен.",
      "каждый кусок кода , который ты покажешь должен быть строго указан к какому файлу он принадлежит.",
      "Имена переменных и функций — PEP8.",
      "Писать код с упором на низкое потребление памяти и работу с большими данными.",
      "Единый кастомный JSON-логгер через LoggerAdapter (время, уровень, имя функции, сообщение).",
      "Документировать функции и ключевые участки кода.",
      "Все изменения кода подписывай определенным файлом, в котором мы делаем изменения.",
      "Не приводи допущений, где я сам должен что-то понять и довести дело до конца.",
      "Объясни каждую строку кода.",
      "Предлагай улучшения таким образом, чтобы не порушить существующую логику, которая уже работает."
    ],
    "current_objectives": []
  },
  "structure_text": "./\n  .env.examlpe\n  .gitignore\n  Readme.md\n  __init__.py\n  alembic.ini\n  docker-compose.yml\n  dump_project.py\n  poetry.lock\n  pyproject.toml\n  static/\n    static/js/\n      app.js\n    static/css/\n      style.css\n  base_app/\n    __init__.py\n    main.py\n    base_app/utils/\n      __init__.py\n      case_converter.py\n    base_app/crud/\n      __init__.py\n      permission_repository.py\n      profile_repository.py\n      users.py\n    base_app/core/\n      __init__.py\n      config.py\n      dependencies.py\n      email_tokens.py\n      logging.py\n      security.py\n      base_app/core/schemas/\n        __init__.py\n        permission.py\n        profile.py\n        user.py\n    base_app/mailing/\n      __init__.py\n      email.py\n    base_app/api/\n      __init__.py\n      base_app/api/api_v1/\n        __init__.py\n        auth.py\n        users.py\n    base_app/services/\n      __init__.py\n      auth_service.py\n    base_app/views/\n      __init__.py\n      auth.py\n      web.py\n  templates/\n    templates/core/\n      _header.html\n      base.html\n      index.html\n      login.html\n      register.html\n    templates/users/\n      list.html\n  alembic/\n    README\n    env.py\n    script.py.mako\n    alembic/versions/\n      2025_11_10_1130-c1e86fa06fba_create_users_table.py\n      2025_11_10_1138-cff667a73384_update_users_table.py\n      2025_12_09_1325-33aa3a368fa8_users_profile_permission.py",
  "files": [
    {
      "path": "Readme.md",
      "language": "markdown",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "alembic/env.py",
      "language": "python",
      "size_bytes": 2542,
      "sha256": "cbe849c701402746044a584af5bb09e9260b9fc9943f66e5801aa6221d51da30",
      "content": "import asyncio\nfrom logging.config import fileConfig\n\nfrom sqlalchemy import pool\nfrom sqlalchemy.engine import Connection\nfrom sqlalchemy.ext.asyncio import async_engine_from_config\n\nfrom alembic import context\n\nfrom base_app.core.config import settings\nfrom base_app.core.models import Base\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\ntarget_metadata = Base.metadata\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\nconfig.set_main_option(\"sqlalchemy.url\", str(settings.db.url))\n\n\ndef run_migrations_offline() -> None:\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef do_run_migrations(connection: Connection) -> None:\n    context.configure(connection=connection, target_metadata=target_metadata)\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\nasync def run_async_migrations() -> None:\n    \"\"\"In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n\n    connectable = async_engine_from_config(\n        config.get_section(config.config_ini_section, {}),\n        prefix=\"sqlalchemy.\",\n        poolclass=pool.NullPool,\n    )\n\n    async with connectable.connect() as connection:\n        await connection.run_sync(do_run_migrations)\n\n    await connectable.dispose()\n\n\ndef run_migrations_online() -> None:\n    \"\"\"Run migrations in 'online' mode.\"\"\"\n\n    asyncio.run(run_async_migrations())\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"
    },
    {
      "path": "alembic/versions/2025_11_10_1130-c1e86fa06fba_create_users_table.py",
      "language": "python",
      "size_bytes": 1049,
      "sha256": "84ed820467e60ebbe596be951192a6672d3daa045d255bd286b8e8e877a59647",
      "content": "\"\"\"create users table\n\nRevision ID: c1e86fa06fba\nRevises:\nCreate Date: 2025-11-10 11:30:00.602050\n\n\"\"\"\n\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = \"c1e86fa06fba\"\ndown_revision: Union[str, Sequence[str], None] = None\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    \"\"\"Upgrade schema.\"\"\"\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table(\n        \"users\",\n        sa.Column(\"username\", sa.String(), nullable=False),\n        sa.Column(\"id\", sa.Integer(), nullable=False),\n        sa.PrimaryKeyConstraint(\"id\", name=op.f(\"pk_users\")),\n        sa.UniqueConstraint(\"username\", name=op.f(\"uq_users_username\")),\n    )\n    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    \"\"\"Downgrade schema.\"\"\"\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table(\"users\")\n    # ### end Alembic commands ###\n"
    },
    {
      "path": "alembic/versions/2025_11_10_1138-cff667a73384_update_users_table.py",
      "language": "python",
      "size_bytes": 1142,
      "sha256": "d5a1292949ab9d2ff6421a8830c604b7dadfc4c6378f8bd2c8d986a98136c960",
      "content": "\"\"\"update users table\n\nRevision ID: cff667a73384\nRevises: c1e86fa06fba\nCreate Date: 2025-11-10 11:38:35.346057\n\n\"\"\"\n\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = \"cff667a73384\"\ndown_revision: Union[str, Sequence[str], None] = \"c1e86fa06fba\"\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    \"\"\"Upgrade schema.\"\"\"\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.add_column(\"users\", sa.Column(\"foo\", sa.Integer(), nullable=False))\n    op.add_column(\"users\", sa.Column(\"bar\", sa.Integer(), nullable=False))\n    op.create_unique_constraint(\n        op.f(\"uq_users_foo_bar\"), \"users\", [\"foo\", \"bar\"]\n    )\n    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    \"\"\"Downgrade schema.\"\"\"\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_constraint(op.f(\"uq_users_foo_bar\"), \"users\", type_=\"unique\")\n    op.drop_column(\"users\", \"bar\")\n    op.drop_column(\"users\", \"foo\")\n    # ### end Alembic commands ###\n"
    },
    {
      "path": "alembic/versions/2025_12_09_1325-33aa3a368fa8_users_profile_permission.py",
      "language": "python",
      "size_bytes": 4557,
      "sha256": "f7585ab4dcec5638d530174d271fad937840e5982924de106772abf2a802749c",
      "content": "\"\"\"users+profile+permission\n\nRevision ID: 33aa3a368fa8\nRevises: cff667a73384\nCreate Date: 2025-12-09 13:25:37.186005\n\n\"\"\"\n\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = \"33aa3a368fa8\"\ndown_revision: Union[str, Sequence[str], None] = \"cff667a73384\"\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    from sqlalchemy import text\n    import sqlalchemy as sa\n    from alembic import op\n\n    # 1) users: добавляем новые колонки СНАЧАЛА nullable=True,\n    #    чтобы не упасть на существующих NULL-ах\n    op.add_column(\"users\", sa.Column(\"email\", sa.String(length=255), nullable=True))\n    op.add_column(\"users\", sa.Column(\"hashed_password\", sa.String(length=255), nullable=True))\n    op.add_column(\"users\", sa.Column(\"is_active\", sa.Boolean(), server_default=sa.true(), nullable=False))\n    op.add_column(\"users\", sa.Column(\"activation_key\", sa.String(length=64), nullable=True))\n    op.add_column(\"users\", sa.Column(\"activation_sent_at\", sa.DateTime(timezone=True), nullable=True))\n\n    # 2) Бэкофилл email для всех строк, где он пуст:\n    #    - если username есть и не пуст — username@local.invalid\n    #    - иначе user_<id>@local.invalid\n    conn = op.get_bind()\n    conn.execute(\n        text(\n            \"\"\"\n            UPDATE users\n            SET email = COALESCE(\n                email,\n                CASE\n                    WHEN username IS NOT NULL AND username <> '' THEN username || '@local.invalid'\n                    ELSE 'user_' || id::text || '@local.invalid'\n                END\n            )\n            \"\"\"\n        )\n    )\n\n    # 3) Делаем email NOT NULL\n    op.alter_column(\"users\", \"email\", existing_type=sa.String(length=255), nullable=False)\n\n    # 4) Уникальный индекс/констрейнт на email\n    op.create_unique_constraint(\"uq_users_email\", \"users\", [\"email\"])\n\n    # 5) Таблицы profiles / permissions — как сгенерировал Alembic ранее\n    op.create_table(\n        \"profiles\",\n        sa.Column(\"id\", sa.Integer(), autoincrement=True, nullable=False),\n        sa.Column(\"nickname\", sa.String(length=64), nullable=True),\n        sa.Column(\"avatar\", sa.String(length=255), nullable=True),\n        sa.Column(\"first_name\", sa.String(length=48), nullable=True),\n        sa.Column(\"second_name\", sa.String(length=48), nullable=True),\n        sa.Column(\"phone\", sa.String(length=32), nullable=True),\n        sa.Column(\"email\", sa.String(length=255), nullable=True),\n        sa.Column(\"tg_id\", sa.BigInteger(), nullable=True),\n        sa.Column(\"tg_nickname\", sa.String(length=64), nullable=True),\n        sa.Column(\"verification\", sa.Boolean(), nullable=False, server_default=sa.false()),\n        sa.Column(\"session\", sa.String(length=255), nullable=True),\n        sa.Column(\"user_id\", sa.Integer(), nullable=False),\n        sa.ForeignKeyConstraint([\"user_id\"], [\"users.id\"]),\n        sa.PrimaryKeyConstraint(\"id\"),\n        sa.UniqueConstraint(\"user_id\", name=\"uq_profiles_user_id\"),\n    )\n\n    op.create_table(\n        \"permissions\",\n        sa.Column(\"id\", sa.Integer(), autoincrement=True, nullable=False),\n        sa.Column(\"profile_id\", sa.Integer(), nullable=False),\n        sa.Column(\"is_superadmin\", sa.Boolean(), nullable=False, server_default=sa.false()),\n        sa.Column(\"is_admin\", sa.Boolean(), nullable=False, server_default=sa.false()),\n        sa.Column(\"is_staff\", sa.Boolean(), nullable=False, server_default=sa.false()),\n        sa.Column(\"is_updater\", sa.Boolean(), nullable=False, server_default=sa.false()),\n        sa.Column(\"is_reader\", sa.Boolean(), nullable=False, server_default=sa.false()),\n        sa.Column(\"is_user\", sa.Boolean(), nullable=False, server_default=sa.false()),\n        sa.ForeignKeyConstraint([\"profile_id\"], [\"profiles.id\"]),\n        sa.PrimaryKeyConstraint(\"id\"),\n    )\n\n\ndef downgrade() -> None:\n    from alembic import op\n\n    op.drop_table(\"permissions\")\n    op.drop_table(\"profiles\")\n\n    op.drop_constraint(\"uq_users_email\", \"users\", type_=\"unique\")\n    op.drop_column(\"users\", \"activation_sent_at\")\n    op.drop_column(\"users\", \"activation_key\")\n    op.drop_column(\"users\", \"is_active\")\n    op.drop_column(\"users\", \"hashed_password\")\n    op.drop_column(\"users\", \"email\")\n"
    },
    {
      "path": "alembic.ini",
      "language": "ini",
      "size_bytes": 4797,
      "sha256": "08ebc0246133f9b8b256bda33e10fbe0a09eb68dbe435ad2887b0c9c8b9864ba",
      "content": "# A generic, single database configuration.\n\n[alembic]\n# path to migration scripts.\n# this is typically a path given in POSIX (e.g. forward slashes)\n# format, relative to the token %(here)s which refers to the location of this\n# ini file\nscript_location = %(here)s/alembic\n\n# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s\n# Uncomment the line below if you want the files to be prepended with date and time\n# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file\n# for all available tokens\nfile_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s\n\n# sys.path path, will be prepended to sys.path if present.\n# defaults to the current working directory.  for multiple paths, the path separator\n# is defined by \"path_separator\" below.\nprepend_sys_path = .\n\n# timezone to use when rendering the date within the migration file\n# as well as the filename.\n# If specified, requires the tzdata library which can be installed by adding\n# `alembic[tz]` to the pip requirements.\n# string value is passed to ZoneInfo()\n# leave blank for localtime\n# timezone =\n\n# max length of characters to apply to the \"slug\" field\n# truncate_slug_length = 40\n\n# set to 'true' to run the environment during\n# the 'revision' command, regardless of autogenerate\n# revision_environment = false\n\n# set to 'true' to allow .pyc and .pyo files without\n# a source .py file to be detected as revisions in the\n# versions/ directory\n# sourceless = false\n\n# version location specification; This defaults\n# to <script_location>/versions.  When using multiple version\n# directories, initial revisions must be specified with --version-path.\n# The path separator used here should be the separator specified by \"path_separator\"\n# below.\n# version_locations = %(here)s/bar:%(here)s/bat:%(here)s/alembic/versions\n\n# path_separator; This indicates what character is used to split lists of file\n# paths, including version_locations and prepend_sys_path within configparser\n# files such as alembic.ini.\n# The default rendered in new alembic.ini files is \"os\", which uses os.pathsep\n# to provide os-dependent path splitting.\n#\n# Note that in order to support legacy alembic.ini files, this default does NOT\n# take place if path_separator is not present in alembic.ini.  If this\n# option is omitted entirely, fallback logic is as follows:\n#\n# 1. Parsing of the version_locations option falls back to using the legacy\n#    \"version_path_separator\" key, which if absent then falls back to the legacy\n#    behavior of splitting on spaces and/or commas.\n# 2. Parsing of the prepend_sys_path option falls back to the legacy\n#    behavior of splitting on spaces, commas, or colons.\n#\n# Valid values for path_separator are:\n#\n# path_separator = :\n# path_separator = ;\n# path_separator = space\n# path_separator = newline\n#\n# Use os.pathsep. Default configuration used for new projects.\npath_separator = os\n\n\n# set to 'true' to search source files recursively\n# in each \"version_locations\" directory\n# new in Alembic version 1.10\n# recursive_version_locations = false\n\n# the output encoding used when revision files\n# are written from script.py.mako\n# output_encoding = utf-8\n\n# database URL.  This is consumed by the user-maintained env.py script only.\n# other means of configuring database URLs may be customized within the env.py\n# file.\nsqlalchemy.url = driver://user:pass@localhost/dbname\n\n\n[post_write_hooks]\n# post_write_hooks defines scripts or Python functions that are run\n# on newly generated revision scripts.  See the documentation for further\n# detail and examples\n\n# format using \"black\" - use the console_scripts runner, against the \"black\" entrypoint\nhooks = black\nblack.type = console_scripts\nblack.entrypoint = black\nblack.options = -l 79 REVISION_SCRIPT_FILENAME\n\n# lint with attempts to fix using \"ruff\" - use the module runner, against the \"ruff\" module\n# hooks = ruff\n# ruff.type = module\n# ruff.module = ruff\n# ruff.options = check --fix REVISION_SCRIPT_FILENAME\n\n# Alternatively, use the exec runner to execute a binary found on your PATH\n# hooks = ruff\n# ruff.type = exec\n# ruff.executable = ruff\n# ruff.options = check --fix REVISION_SCRIPT_FILENAME\n\n# Logging configuration.  This is also consumed by the user-maintained\n# env.py script only.\n[loggers]\nkeys = root,sqlalchemy,alembic\n\n[handlers]\nkeys = console\n\n[formatters]\nkeys = generic\n\n[logger_root]\nlevel = WARNING\nhandlers = console\nqualname =\n\n[logger_sqlalchemy]\nlevel = WARNING\nhandlers =\nqualname = sqlalchemy.engine\n\n[logger_alembic]\nlevel = INFO\nhandlers =\nqualname = alembic\n\n[handler_console]\nclass = StreamHandler\nargs = (sys.stderr,)\nlevel = NOTSET\nformatter = generic\n\n[formatter_generic]\nformat = %(levelname)-5.5s [%(name)s] %(message)s\ndatefmt = %H:%M:%S\n"
    },
    {
      "path": "base_app/__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "base_app/api/__init__.py",
      "language": "python",
      "size_bytes": 242,
      "sha256": "fb4a5496400d49487ae518586fa05e2db2b3d4b06c6312f3c8b1becaac683cc5",
      "content": "# base_app/api/__init__.py\nfrom fastapi import APIRouter\n\nfrom .api_v1 import router as router_api_v1\nfrom base_app.core.config import settings\n\nrouter = APIRouter(\n    prefix=settings.api.prefix\n)\nrouter.include_router(\n    router_api_v1,\n)\n"
    },
    {
      "path": "base_app/api/api_v1/__init__.py",
      "language": "python",
      "size_bytes": 491,
      "sha256": "6d257721e338a6dc2d1559b620350b508e355e2a7519eee2cb64014c21e3261f",
      "content": "# /base_app/api/api_v1/__init__.py\nfrom fastapi import APIRouter\n\nfrom base_app.core.config import settings\nfrom .users import router as users_router\nfrom .auth import router as auth_router\n\nrouter = APIRouter(prefix=settings.api.v1.prefix)\n\n# /api/<v1>/users/...\nrouter.include_router(\n    users_router,\n    prefix=settings.api.v1.users,\n)\n\n# /api/<v1>/auth/...\nrouter.include_router(\n    auth_router,\n    prefix=settings.api.v1.auth,   # <- префикс берём из конфига\n)\n"
    },
    {
      "path": "base_app/api/api_v1/auth.py",
      "language": "python",
      "size_bytes": 2733,
      "sha256": "4b206fd4d7538c57e506fd776702435ef0438ec4205744a220ecc27d82c0fa61",
      "content": "# /base_app/api/api_v1/auth.py\nfrom __future__ import annotations\n\nfrom typing import Annotated\n\nfrom fastapi import APIRouter, Depends, Form, Request, status\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom fastapi.responses import HTMLResponse\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom base_app.core.models import db_helper\nfrom base_app.core.models.user import User\nfrom base_app.core.models.profile import Profile\nfrom base_app.core.logging import get_logger\nfrom base_app.core.email_tokens import read_email_token\nfrom base_app.services.auth_service import AuthService\n\nrouter = APIRouter(tags=[\"auth\"])\nlog = get_logger(\"api.auth\")\n\n\n@router.post(\"/register\", status_code=status.HTTP_201_CREATED)\nasync def auth_register(\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    email: Annotated[str, Form(...)],\n    password: Annotated[str, Form(...)],\n    password2: Annotated[str, Form(...)],\n):\n    if password != password2:\n        return {\"ok\": False, \"detail\": \"Passwords do not match\"}\n\n    service = AuthService()\n    user_id, verify_token = await service.register_user(session, email=email, password=password)\n    await session.commit()\n    log.info({\"event\": \"register\", \"user_id\": user_id, \"email\": email})\n    return {\"ok\": True, \"user_id\": user_id, \"verify_token\": verify_token}\n\n\n@router.post(\"/token\")\nasync def auth_token(\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    form: Annotated[OAuth2PasswordRequestForm, Depends()],\n):\n    service = AuthService()\n    token = await service.authenticate(session, email=form.username, password=form.password)\n    return {\"access_token\": token, \"token_type\": \"bearer\"}\n\n\n@router.get(\"/verify\", response_class=HTMLResponse)\nasync def verify_email(\n    request: Request,\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    token: str,\n):\n    \"\"\"\n    Проверка e-mail по токену: включает Profile.verification = True.\n    \"\"\"\n    try:\n        data = read_email_token(token)\n        uid = int(data[\"uid\"])\n    except Exception:\n        return HTMLResponse(\"<h3>Неверная или истёкшая ссылка подтверждения</h3>\", status_code=400)\n\n    # отмечаем профиль как верифицированный\n    res = await session.execute(select(Profile).join(User).where(User.id == uid))\n    profile = res.scalar_one_or_none()\n    if not profile:\n        return HTMLResponse(\"<h3>Профиль не найден</h3>\", status_code=404)\n\n    profile.verification = True\n    await session.commit()\n    return HTMLResponse(\"<h3>Почта подтверждена. Спасибо!</h3>\")\n"
    },
    {
      "path": "base_app/api/api_v1/users.py",
      "language": "python",
      "size_bytes": 986,
      "sha256": "efcead65e3b1b2fa9667fddf53e260021ba8a20c8e1749e516c7d1a32d630fb0",
      "content": "# base_app/api/api_v1/users.py\nfrom typing import Annotated\n\nfrom fastapi import APIRouter\nfrom fastapi.params import Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom base_app.core.models import db_helper\nfrom base_app.core.schemas.user import UserRead, UserCreate\nfrom base_app.crud.users import get_all_users\nfrom base_app.crud import users as users_crud\n\nrouter = APIRouter(tags=[\"Users\"])\n\n\n@router.get(\"\", response_model=list[UserRead])\nasync def get_users(\n    # session: AsyncSession = Depends(db_helper.session_getter),\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n):\n    users = await users_crud.get_all_users(session=session)\n    return users\n\n@router.post(\"\", response_model=UserRead)\nasync def create_user(\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    user_create: UserCreate,\n):\n    user = await users_crud.create_user(\n        session=session,\n        user_create= user_create\n    )\n    return user\n"
    },
    {
      "path": "base_app/core/__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "base_app/core/config.py",
      "language": "python",
      "size_bytes": 2121,
      "sha256": "5ed6c9e90ef5e4f4c02f0eb06cecb0f2d104d474ec7fa48e04d71fcb4eea1de0",
      "content": "# base_app/core/config.py\nfrom pydantic import BaseModel\nfrom pydantic import PostgresDsn\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass RunConfig(BaseModel):\n    host: str = \"0.0.0.0\"\n    port: int = 8015\n\n\nclass ApiV1Prefix(BaseModel):\n    prefix: str = \"/v1\"\n    users: str = \"/users\"\n    auth: str = \"/auth\"\n\n\nclass ApiPrefix(BaseModel):\n    prefix: str = \"/api\"\n    v1: ApiV1Prefix = ApiV1Prefix()\n\n\nclass DatabaseConfig(BaseModel):\n    url: PostgresDsn\n    echo: bool = False\n    echo_pool: bool = False\n    pool_size: int = 50\n    max_overflow: int = 10\n\n    naming_convention: dict[str, str] = {\n        \"ix\": \"ix_%(column_0_label)s\",\n        \"uq\": \"uq_%(table_name)s_%(column_0_N_name)s\",\n        \"ck\": \"ck_%(table_name)s_%(constraint_name)s\",\n        \"fk\": \"fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s\",\n        \"pk\": \"pk_%(table_name)s\",\n    }\n\nclass AuthConfig(BaseModel):\n    secret_key: str = \"CHANGE_ME\"                # общий секрет (JWT/CSRF/сессии)\n    algorithm: str = \"HS256\"\n    access_token_minutes: int = 60\n    email_verify_secret: str = \"CHANGE_ME_EMAIL\" # отдельный секрет для ссылок\n    verify_token_ttl_hours: int = 48\n\n\nclass EmailConfig(BaseModel):\n    smtp_host: str = \"localhost\"\n    smtp_port: int = 25\n    smtp_user: str = \"\"\n    smtp_password: str = \"\"\n    use_tls: bool = False\n    use_ssl: bool = False\n    from_email: str = \"noreply@example.com\"\n\n\nclass SiteConfig(BaseModel):\n    # если нужно строить абсолютные ссылки вне Request (опционально)\n    base_url: str = \"http://127.0.0.1:8000\"\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_file=(\".env.example\", \".env\"),\n        case_sensitive=False,\n        env_nested_delimiter=\"__\",\n        env_prefix=\"APP_CONFIG__\",\n    )\n    run: RunConfig = RunConfig()\n    api: ApiPrefix = ApiPrefix()\n    db: DatabaseConfig\n\n    auth: AuthConfig = AuthConfig()\n    email: EmailConfig = EmailConfig()\n    site: SiteConfig = SiteConfig()\n\nsettings = Settings()\nprint(settings.db.url)\n"
    },
    {
      "path": "base_app/core/dependencies.py",
      "language": "python",
      "size_bytes": 798,
      "sha256": "84c624e1c8f084654dc0aac553a9cef329aef870f894518f8074bae3a9795852",
      "content": "# /base_app/core/dependencies.py\nfrom __future__ import annotations\n\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError\n\nfrom .security import decode_token\nfrom .logging import get_logger\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/api/v1/auth/token\")\nlog = get_logger(\"deps\")\n\n\ndef get_current_subject(token: str = Depends(oauth2_scheme)) -> dict:\n    \"\"\"\n    Возвращает payload токена или 401.\n    \"\"\"\n    try:\n        payload = decode_token(token)\n        return payload\n    except JWTError as e:\n        log.info({\"event\": \"jwt_error\", \"error\": str(e)})\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid or expired token\",\n        )\n"
    },
    {
      "path": "base_app/core/email_tokens.py",
      "language": "python",
      "size_bytes": 617,
      "sha256": "1f92c6063aa2ed390d2dc8dad8c570a69a891a8ec6d2ca9cd69843e1ced448d5",
      "content": "# /base_app/core/email_tokens.py\nfrom __future__ import annotations\n\nfrom itsdangerous import URLSafeTimedSerializer, BadSignature, SignatureExpired\n\nfrom .config import settings\n\n\ndef _serializer() -> URLSafeTimedSerializer:\n    return URLSafeTimedSerializer(\n        secret_key=settings.auth.email_verify_secret,\n        salt=\"email-verify\",\n    )\n\n\ndef make_email_token(user_id: int) -> str:\n    return _serializer().dumps({\"uid\": user_id})\n\n\ndef read_email_token(token: str) -> dict:\n    max_age = settings.auth.verify_token_ttl_hours * 3600\n    data = _serializer().loads(token, max_age=max_age)\n    return data\n"
    },
    {
      "path": "base_app/core/logging.py",
      "language": "python",
      "size_bytes": 1375,
      "sha256": "9730b30af2bcccc64d2e7b97d381d3faabc94f4d16ebce7632d8a53fd84aa2bb",
      "content": "# /base_app/core/logging.py\nfrom __future__ import annotations\n\nimport json\nimport logging\nfrom logging import LoggerAdapter\nfrom time import time\n\n\nclass JsonFormatter(logging.Formatter):\n    \"\"\"Простой JSON-форматтер: время, уровень, логгер, сообщение/данные.\"\"\"\n\n    def format(self, record: logging.LogRecord) -> str:  # noqa: D401\n        payload = {\n            \"ts\": round(time(), 3),\n            \"level\": record.levelname,\n            \"logger\": record.name,\n        }\n        # Если передали dict в msg — включаем \"как есть\"\n        if isinstance(record.msg, dict):\n            payload.update(record.msg)\n        else:\n            payload[\"message\"] = record.getMessage()\n        return json.dumps(payload, ensure_ascii=False)\n\n\ndef get_logger(name: str, base_level: int = logging.INFO) -> LoggerAdapter:\n    \"\"\"Возвращает LoggerAdapter с JSON-форматированием.\"\"\"\n    logger = logging.getLogger(name)\n    if not logger.handlers:\n        handler = logging.StreamHandler()\n        handler.setFormatter(JsonFormatter())\n        logger.addHandler(handler)\n    logger.setLevel(base_level)\n    # LoggerAdapter позволяет передавать .info({...}) и добавлять extra при необходимости\n    return LoggerAdapter(logger, extra={})\n"
    },
    {
      "path": "base_app/core/schemas/__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "base_app/core/schemas/permission.py",
      "language": "python",
      "size_bytes": 358,
      "sha256": "c0cb725c787e3705c579ad460089ef044ffcf77eccbc5459cbc04a2d387409fd",
      "content": "# /base_app/core/schemas/permission.py\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass PermissionRead(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    id: int\n    profile_id: int\n    is_superadmin: bool\n    is_admin: bool\n    is_staff: bool\n    is_updater: bool\n    is_reader: bool\n    is_user: bool\n"
    },
    {
      "path": "base_app/core/schemas/profile.py",
      "language": "python",
      "size_bytes": 695,
      "sha256": "57016dc274e27266491dee4550e728e3b9ddbbb52320f5e44205879091e35c9f",
      "content": "# /base_app/core/schemas/profile.py\nfrom __future__ import annotations\n\nfrom typing import Optional, List\n\nfrom pydantic import BaseModel, ConfigDict, EmailStr\n\nfrom .permission import PermissionRead\n\n\nclass ProfileRead(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n    id: int\n    user_id: int\n    email: Optional[EmailStr] = None\n    nickname: Optional[str] = None\n    avatar: Optional[str] = None\n    first_name: Optional[str] = None\n    second_name: Optional[str] = None\n    phone: Optional[str] = None\n    tg_id: Optional[int] = None\n    tg_nickname: Optional[str] = None\n    verification: bool\n    session: Optional[str] = None\n    permissions: List[PermissionRead] = []\n"
    },
    {
      "path": "base_app/core/schemas/user.py",
      "language": "python",
      "size_bytes": 398,
      "sha256": "5c7a06b450f7f349ec899a67a62b24e4c6d2add04d88d1978227319c5d0e3556",
      "content": "# /base_app/core/schemas/user.py\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel, ConfigDict, EmailStr\n\n\nclass UserBase(BaseModel):\n    username: str | None = None\n    foo: int = 0\n    bar: int = 0\n\n\nclass UserCreate(BaseModel):\n    email: EmailStr\n    password: str\n\n\nclass UserRead(UserBase):\n    model_config = ConfigDict(from_attributes=True)\n    id: int\n    email: EmailStr\n"
    },
    {
      "path": "base_app/core/security.py",
      "language": "python",
      "size_bytes": 1165,
      "sha256": "bed09bf500aaaa8ae4c7d51967d8bc7c37855c95dfacbfe5a3356bdda6b94397",
      "content": "# /base_app/core/security.py\nfrom __future__ import annotations\n\nfrom datetime import UTC, datetime, timedelta\nfrom typing import Any, Optional\n\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\n\nfrom .config import settings\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n\ndef hash_password(password: str) -> str:\n    return pwd_context.hash(password)\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef create_access_token(\n    subject: str | int,\n    expires_delta: Optional[timedelta] = None,\n    extra: Optional[dict[str, Any]] = None,\n) -> str:\n    to_encode: dict[str, Any] = {\"sub\": str(subject)}\n    if extra:\n        to_encode.update(extra)\n    expire = datetime.now(UTC) + (expires_delta or timedelta(minutes=settings.auth.access_token_minutes))\n    to_encode.update({\"exp\": expire})\n    return jwt.encode(to_encode, settings.auth.secret_key, algorithm=settings.auth.algorithm)\n\n\ndef decode_token(token: str) -> dict[str, Any]:\n    return jwt.decode(token, settings.auth.secret_key, algorithms=[settings.auth.algorithm])\n"
    },
    {
      "path": "base_app/crud/__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "base_app/crud/permission_repository.py",
      "language": "python",
      "size_bytes": 663,
      "sha256": "4caf6072013c8d895833b22d02de1984e181795a5dc0082c3728dd569cf81d35",
      "content": "# /base_app/crud/permission_repository.py\nfrom __future__ import annotations\n\nfrom typing import Protocol, Sequence\n\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom base_app.core.models.permission import Permission\n\n\nclass IPermissionRepository(Protocol):\n    async def list_for_profile(self, session: AsyncSession, profile_id: int) -> Sequence[Permission]: ...\n\n\nclass PermissionRepository(IPermissionRepository):\n    async def list_for_profile(self, session: AsyncSession, profile_id: int):\n        res = await session.execute(select(Permission).where(Permission.profile_id == profile_id))\n        return list(res.scalars())\n"
    },
    {
      "path": "base_app/crud/profile_repository.py",
      "language": "python",
      "size_bytes": 1482,
      "sha256": "4e32b06a5c9e69b05710f2460de5a2e2f21fd746023af1b9fa417f2436053cf4",
      "content": "# /base_app/crud/profile_repository.py\nfrom __future__ import annotations\n\nfrom typing import Protocol, Optional, Sequence\n\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom base_app.core.models.profile import Profile\nfrom base_app.core.models.permission import Permission\n\n\nclass IProfileRepository(Protocol):\n    async def get_by_id(self, session: AsyncSession, profile_id: int) -> Optional[Profile]: ...\n    async def get_by_user_id(self, session: AsyncSession, user_id: int) -> Optional[Profile]: ...\n    async def create_with_defaults(self, session: AsyncSession, *, user_id: int, email: str) -> Profile: ...\n\n\nclass ProfileRepository(IProfileRepository):\n    async def get_by_id(self, session: AsyncSession, profile_id: int) -> Optional[Profile]:\n        res = await session.execute(select(Profile).where(Profile.id == profile_id))\n        return res.scalar_one_or_none()\n\n    async def get_by_user_id(self, session: AsyncSession, user_id: int) -> Optional[Profile]:\n        res = await session.execute(select(Profile).where(Profile.user_id == user_id))\n        return res.scalar_one_or_none()\n\n    async def create_with_defaults(self, session: AsyncSession, *, user_id: int, email: str) -> Profile:\n        profile = Profile(user_id=user_id, email=email, verification=False)\n        profile.permissions = [Permission(is_user=True)]  # базовый флаг\n        session.add(profile)\n        await session.flush()\n        return profile\n"
    },
    {
      "path": "base_app/crud/users.py",
      "language": "python",
      "size_bytes": 613,
      "sha256": "e5204b8849088d281dbe3ccdf20c6e32a74cb5b37d49b1138b4ebc9245d354a2",
      "content": "from typing import Sequence\n\nfrom sqlalchemy import select\nfrom  sqlalchemy.ext.asyncio import AsyncSession\n\nfrom base_app.core.models import User\nfrom base_app.core.schemas.user import UserCreate\n\n\nasync  def get_all_users(session: AsyncSession) -> Sequence[User]:\n    stmt = select(User).order_by(User.id.desc())\n    result = await session.scalars(stmt)\n    return result.all()\n\n\nasync def create_user(\n    session: AsyncSession,\n    user_create: UserCreate\n) -> User:\n    user = User(**user_create.model_dump())\n    session.add(user)\n    await session.commit()\n    # await sesion.refresh(user)\n    return user\n"
    },
    {
      "path": "base_app/mailing/__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "base_app/mailing/email.py",
      "language": "python",
      "size_bytes": 1694,
      "sha256": "c3a905562ef93e2af71b82799d005e06d033484f47184f8e199441b38cc2ab93",
      "content": "# /base_app/mailing/email.py\nfrom __future__ import annotations\n\nimport smtplib\nfrom email.mime.text import MIMEText\n\nfrom base_app.core.config import settings\nfrom base_app.core.logging import get_logger\n\nlog = get_logger(\"mail\")\n\n\ndef send_verification_email_sync(to_email: str, verify_link: str) -> bool:\n    \"\"\"\n    Простая синхронная отправка (SMTP). Для продакшена можно вынести в Celery.\n    \"\"\"\n    subject = \"Подтверждение регистрации\"\n    body = f\"Для подтверждения e-mail пройдите по ссылке:\\n\\n{verify_link}\\n\\nЕсли это были не вы — игнорируйте письмо.\"\n    msg = MIMEText(body, _charset=\"utf-8\")\n    msg[\"Subject\"] = subject\n    msg[\"From\"] = settings.email.from_email\n    msg[\"To\"] = to_email\n\n    try:\n        if settings.email.use_ssl:\n            with smtplib.SMTP_SSL(settings.email.smtp_host, settings.email.smtp_port) as s:\n                if settings.email.smtp_user:\n                    s.login(settings.email.smtp_user, settings.email.smtp_password)\n                s.send_message(msg)\n        else:\n            with smtplib.SMTP(settings.email.smtp_host, settings.email.smtp_port) as s:\n                if settings.email.use_tls:\n                    s.starttls()\n                if settings.email.smtp_user:\n                    s.login(settings.email.smtp_user, settings.email.smtp_password)\n                s.send_message(msg)\n        log.info({\"event\": \"email_sent\", \"to\": to_email})\n        return True\n    except Exception as e:\n        log.info({\"event\": \"email_fail\", \"to\": to_email, \"error\": str(e)})\n        return False\n"
    },
    {
      "path": "base_app/main.py",
      "language": "python",
      "size_bytes": 1653,
      "sha256": "8b6d0785a9d7285d8e7817386be941e9ae5846922da5acf8b160ad0dc73bd49d",
      "content": "# /base_app/main.py\nfrom __future__ import annotations\n\nfrom contextlib import asynccontextmanager\nfrom pathlib import Path\n\nimport uvicorn\nfrom fastapi import FastAPI\nfrom fastapi.responses import ORJSONResponse\nfrom fastapi.staticfiles import StaticFiles\nfrom starlette.middleware.sessions import SessionMiddleware\n\n# ВАЖНО: относительные импорты внутри пакета base_app\nfrom .core.config import settings\nfrom .core.models import db_helper\nfrom .api import router as api_router\nfrom .views import router as views_router  # HTML-вьюхи (/, /users/)\n\nPROJECT_ROOT = Path(__file__).resolve().parents[1]\nSTATIC_DIR = PROJECT_ROOT / \"static\"\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # startup\n    yield\n    # shutdown\n    await db_helper.dispose()\n\n\ndef create_app() -> FastAPI:\n    app = FastAPI(\n        default_response_class=ORJSONResponse,\n        lifespan=lifespan,\n    )\n    app.add_middleware(SessionMiddleware, secret_key=settings.auth.secret_key)  # <— для session/CSRF\n\n    # /static -> ./static (в корне проекта)\n    app.mount(\"/static\", StaticFiles(directory=str(STATIC_DIR)), name=\"static\")\n\n    # HTML-views и API\n    app.include_router(views_router)\n    app.include_router(api_router, prefix=settings.api.prefix)\n    return app\n\n\n# Экспортируемый объект приложения\nmain_app = create_app()\n\n\nif __name__ == \"__main__\":\n    # Запуск: poetry run uvicorn base_app.main:main_app --reload\n    uvicorn.run(\n        \"base_app.main:main_app\",\n        host=settings.run.host,\n        port=settings.run.port,\n        reload=True,\n    )\n"
    },
    {
      "path": "base_app/services/__init__.py",
      "language": "python",
      "size_bytes": 0,
      "sha256": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "content": ""
    },
    {
      "path": "base_app/services/auth_service.py",
      "language": "python",
      "size_bytes": 2658,
      "sha256": "88f7a4a0a357e291c0054e18f92c736f65f56068c6a10f79fd6ba703eca099b4",
      "content": "# /base_app/services/auth_service.py\nfrom __future__ import annotations\n\nfrom datetime import UTC, datetime\nfrom typing import Optional\n\nfrom fastapi import HTTPException, status\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom base_app.core.logging import get_logger\nfrom base_app.core.models.user import User\nfrom base_app.core.models.profile import Profile\nfrom base_app.core.models.permission import Permission\nfrom base_app.core.security import hash_password, verify_password, create_access_token\nfrom base_app.core.email_tokens import make_email_token\n\nlog = get_logger(\"auth_service\")\n\n\nclass AuthService:\n    \"\"\"\n    Полный цикл: регистрация → создание User/Profile/Permission → токен верификации → логин (JWT).\n    \"\"\"\n\n    async def register_user(self, session: AsyncSession, *, email: str, password: str) -> tuple[int, str]:\n        # Проверяем наличие пользователя\n        existing = await session.execute(select(User).where(User.email == email))\n        if existing.scalar_one_or_none():\n            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=\"User already exists\")\n\n        # Создаём User\n        u = User(\n            email=email,\n            hashed_password=hash_password(password),\n            is_active=True,\n            activation_key=None,\n            activation_sent_at=datetime.now(UTC),\n        )\n        session.add(u)\n        await session.flush()  # получим u.id\n\n        # Создаём Profile + базовые права\n        p = Profile(user_id=u.id, email=email, verification=False)\n        p.permissions = [Permission(is_user=True)]\n        session.add(p)\n        await session.flush()\n\n        # Готовим токен для письма\n        token = make_email_token(u.id)\n        return u.id, token\n\n    async def authenticate(self, session: AsyncSession, *, email: str, password: str) -> str:\n        res = await session.execute(select(User).where(User.email == email))\n        user = res.scalar_one_or_none()\n        if not user or not user.hashed_password:\n            # либо пользователя нет, либо у старой записи нет хэша — не даём войти\n            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Invalid credentials\")\n\n        if not verify_password(password, user.hashed_password):\n            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Invalid credentials\")\n\n        return create_access_token(subject=user.id, extra={\"email\": user.email})\n"
    },
    {
      "path": "base_app/utils/__init__.py",
      "language": "python",
      "size_bytes": 100,
      "sha256": "5fee3dca714d214a1a558cf01a8c1371ee5493e8bc95800640480226bac85892",
      "content": "__all__ = (\n    \"camel_case_to_snake_case\",\n)\n\nfrom .case_converter import camel_case_to_snake_case\n"
    },
    {
      "path": "base_app/utils/case_converter.py",
      "language": "python",
      "size_bytes": 919,
      "sha256": "b28fabbac0a7b4c08eb158db30f65944bbfe48ab12d8d9f261447f18404e338c",
      "content": "\"\"\"\nTaken from\nhttps://github.com/mahenzon/ri-sdk-python-wrapper/blob/master/ri_sdk_codegen/utils/case_converter.py\n\"\"\"\n\n\ndef camel_case_to_snake_case(input_str: str) -> str:\n    \"\"\"\n    >>> camel_case_to_snake_case(\"SomeSDK\")\n    'some_sdk'\n    >>> camel_case_to_snake_case(\"RServoDrive\")\n    'r_servo_drive'\n    >>> camel_case_to_snake_case(\"SDKDemo\")\n    'sdk_demo'\n    \"\"\"\n    chars = []\n    for c_idx, char in enumerate(input_str):\n        if c_idx and char.isupper():\n            nxt_idx = c_idx + 1\n            # idea of the flag is to separate abbreviations\n            # as new words, show them in lower case\n            flag = nxt_idx >= len(input_str) or input_str[nxt_idx].isupper()\n            prev_char = input_str[c_idx - 1]\n            if prev_char.isupper() and flag:\n                pass\n            else:\n                chars.append(\"_\")\n        chars.append(char.lower())\n    return \"\".join(chars)\n"
    },
    {
      "path": "base_app/views/__init__.py",
      "language": "python",
      "size_bytes": 292,
      "sha256": "583acbe79e24e873ff3932caba19f35a1b6c194e6d14f545ac416c1b7f782be5",
      "content": "# /base_app/views/__init__.py\nfrom fastapi import APIRouter\nfrom .web import router as web_router\nfrom .auth import router as auth_router\n\n# Единая точка подключения HTML-вьюх\nrouter = APIRouter()\nrouter.include_router(web_router)\nrouter.include_router(auth_router)\n"
    },
    {
      "path": "base_app/views/auth.py",
      "language": "python",
      "size_bytes": 4118,
      "sha256": "511b3320785ea83785fa5397e292c01f0a3e96104bc5ef7ff09dc62168ab801d",
      "content": "# /base_app/views/auth.py\nfrom __future__ import annotations\n\nimport secrets\nfrom pathlib import Path\nfrom typing import Annotated\n\nfrom fastapi import APIRouter, Request, Depends, Form, BackgroundTasks\nfrom fastapi.templating import Jinja2Templates\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom base_app.core.config import settings\nfrom base_app.core.models import db_helper\nfrom base_app.core.logging import get_logger\nfrom base_app.mailing.email import send_verification_email_sync\nfrom base_app.services.auth_service import AuthService\n\nrouter = APIRouter()\nlog = get_logger(\"views.auth\")\n\nTEMPLATES_DIR = Path(__file__).resolve().parents[2] / \"templates\"\ntemplates = Jinja2Templates(directory=str(TEMPLATES_DIR))\n\n\ndef _ensure_csrf(request: Request) -> str:\n    token = request.session.get(\"csrf\")\n    if not token:\n        token = secrets.token_urlsafe(16)\n        request.session[\"csrf\"] = token\n    return token\n\n\ndef _new_captcha(request: Request) -> tuple[int, int, int]:\n    a = secrets.randbelow(9) + 1\n    b = secrets.randbelow(9) + 1\n    s = a + b\n    request.session[\"captcha_sum\"] = s\n    return a, b, s\n\n\n@router.get(\"/auth/login\", name=\"login_html\")\nasync def login_html(request: Request):\n    csrf = _ensure_csrf(request)\n    a, b, _ = _new_captcha(request)\n    return templates.TemplateResponse(\"core/login.html\", {\"request\": request, \"csrf\": csrf, \"a\": a, \"b\": b})\n\n\n@router.get(\"/auth/register\", name=\"register_html\")\nasync def register_html(request: Request):\n    csrf = _ensure_csrf(request)\n    a, b, _ = _new_captcha(request)\n    return templates.TemplateResponse(\"core/register.html\", {\"request\": request, \"csrf\": csrf, \"a\": a, \"b\": b})\n\n\n@router.post(\"/auth/register\", name=\"register_post_html\")\nasync def register_post_html(\n    request: Request,\n    background: BackgroundTasks,\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n    email: Annotated[str, Form(...)],\n    password: Annotated[str, Form(...)],\n    password2: Annotated[str, Form(...)],\n    csrf_token: Annotated[str, Form(...)],\n    captcha: Annotated[int, Form(...)],\n):\n    # CSRF\n    if csrf_token != request.session.get(\"csrf\"):\n        return templates.TemplateResponse(\n            \"core/register.html\",\n            {\"request\": request, \"csrf\": _ensure_csrf(request), \"alert\": {\"kind\": \"error\", \"text\": \"CSRF error\"}},\n            status_code=400,\n        )\n    # CAPTCHA\n    try:\n        if int(captcha) != int(request.session.get(\"captcha_sum\", -1)):\n            raise ValueError\n    except Exception:\n        return templates.TemplateResponse(\n            \"core/register.html\",\n            {\"request\": request, \"csrf\": _ensure_csrf(request), \"alert\": {\"kind\": \"error\", \"text\": \"Капча неверна\"}},\n            status_code=400,\n        )\n    # Пароли\n    if password != password2:\n        return templates.TemplateResponse(\n            \"core/register.html\",\n            {\"request\": request, \"csrf\": _ensure_csrf(request), \"alert\": {\"kind\": \"error\", \"text\": \"Пароли не совпадают\"}},\n            status_code=400,\n        )\n\n    # Регистрация\n    service = AuthService()\n    user_id, verify_token = await service.register_user(session, email=email, password=password)\n    await session.commit()\n\n    # Формируем ссылку верификации\n    path = request.app.url_path_for(\"verify_email\")  # /api/v1/auth/verify (через include_router)\n    base = str(request.base_url).rstrip(\"/\")\n    verify_link = f\"{base}{settings.api.prefix}{settings.api.v1.prefix}{settings.api.v1.auth}{path.split(settings.api.v1.auth)[-1]}?token={verify_token}\"\n\n    # Отправляем письмо в фоне\n    background.add_task(send_verification_email_sync, email, verify_link)\n\n    success_alert = {\n        \"kind\": \"success\",\n        \"text\": \"Мы отправили письмо с подтверждением. Перейдите по ссылке из письма, чтобы завершить регистрацию.\",\n    }\n    return templates.TemplateResponse(\"core/index.html\", {\"request\": request, \"alert\": success_alert})\n"
    },
    {
      "path": "base_app/views/web.py",
      "language": "python",
      "size_bytes": 1652,
      "sha256": "dd9a2d6a4505ac3684a9a6c4f71406910db53ae852cabd69d260e1a5a757753d",
      "content": "# /base_app/views/web.py\nfrom __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import Annotated\n\nfrom fastapi import APIRouter, Request\nfrom fastapi.params import Depends\nfrom fastapi.templating import Jinja2Templates\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom base_app.core.logging import get_logger\nfrom base_app.core.models import db_helper\nfrom base_app.crud import users as users_crud\n\nrouter = APIRouter()  # без префикса — это корневые HTML-страницы\nlog = get_logger(\"web\")\n\n# Путь к папке templates/ в корне проекта\nTEMPLATES_DIR = Path(__file__).resolve().parents[2] / \"templates\"\ntemplates = Jinja2Templates(directory=str(TEMPLATES_DIR))\n\n\n\n\n@router.get(\"/\", name=\"home\")\nasync def home(request: Request):\n    \"\"\"\n    Главная страница. Возвращает templates/index.html.\n    \"\"\"\n    log.info({\"event\": \"open_page\", \"path\": \"/\", \"method\": \"GET\"})\n    return templates.TemplateResponse(\n        \"core/index.html\",\n        {\"request\": request},\n    )\n\n\n@router.get(\"/users/\", name=\"users_list_html\")\nasync def users_list_html(\n    request: Request,\n    session: Annotated[AsyncSession, Depends(db_helper.session_getter)],\n):\n    \"\"\"\n    Список пользователей из БД — templates/users/list.html.\n    \"\"\"\n    users = await users_crud.get_all_users(session=session)\n    log.info({\n        \"event\": \"open_page\",\n        \"path\": \"/users/\",\n        \"method\": \"GET\",\n        \"count\": len(users),\n    })\n    return templates.TemplateResponse(\n        \"users/list.html\",\n        {\"request\": request, \"users\": users},\n    )\n"
    },
    {
      "path": "docker-compose.yml",
      "language": "yaml",
      "size_bytes": 440,
      "sha256": "99e612d469e2e734d91716189057816bcba78045c803413d0439819879636212",
      "content": "services:\n\n  pg:\n    image: postgres\n    environment:\n      POSTGRES_DB: shop\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n    ports:\n      - \"5436:5432\"\n\n  adminer:\n    image: adminer\n    ports:\n      - \"8091:8080\"\n\n  pgadmin:\n    image: dpage/pgadmin4\n    environment:\n      PGADMIN_DEFAULT_EMAIL: admin@admin.org\n      PGADMIN_DEFAULT_PASSWORD: admin\n      PGADMIN_CONFIG_SERVER_MODE: 'False'\n    ports:\n      - \"5050:80\"\n"
    },
    {
      "path": "dump_project.py",
      "language": "python",
      "size_bytes": 13809,
      "sha256": "e9f69f517befeebb168e0bc8a5bcb22c04638d6fd606309063214cde0d50d1f5",
      "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\ndump_project.py — собирает код и структуру проекта в JSON для LLM.\n\nЗапуск:\n  python dump_project.py \\\n    --out project_dump.json \\\n    --max-bytes 800000 \\\n    --tree-depth 5\n\nПо умолчанию:\n  - сохраняет structure.txt (через `tree`, если доступен; иначе — питоновская обводка);\n  - игнорирует бинарные/медийные файлы и стандартные служебные директории;\n  - кладёт весь текстовый код в JSON с хэшами и размерами;\n  - добавляет поля context.static_instructions и context.current_objectives.\n\nСоветы:\n  - Для больших репозиториев увеличьте --max-bytes при необходимости.\n  - Если нужно включить доп. расширения — правьте TEXT_EXTENSIONS или передавайте --include-ext.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport argparse\nimport hashlib\nimport json\nimport os\nimport shutil\nimport subprocess\nimport sys\nfrom datetime import datetime\nfrom fnmatch import fnmatch\nfrom pathlib import Path\nfrom typing import Iterable, List, Dict, Any, Set\n\n# --- Настройки по умолчанию ---\n\nDEFAULT_IGNORE_GLOBS: List[str] = [\n    # из запроса\n    \"__pycache__\",\n    \"*.sample\",\n    \"*.txt\",  # можно убрать, если нужны README/тексты\n    \"*.log\",\n    \"*.pdf\",\n    \"*.jpg\", \"*.jpeg\", \"*.svg\", \"*.png\",\n    \"*.pt\",\n    \"venv\", \".venv\", \"env\", \".env\", \"media\",\n    \"objects\",  #  \"dataset\",\n    \"__init__.pyc\",\n\n    # типичные служебные/тяжёлые каталоги\n    \".git\", \".idea\", \".vscode\", \".mypy_cache\", \".pytest_cache\",\n    \".ruff_cache\", \".cache\", \".tox\",\n    \"node_modules\", \"dist\", \"build\", \".next\", \".nuxt\", \".turbo\",\n    \"*.egg-info\", \"models\",\n]\n\n# Каталоги, которые игнорируем только на верхнем уровне корня проекта\nROOT_ONLY_IGNORE_DIRS: Set[str] = {\"dataset\"}\n\n# Текстовые расширения, которые считаем безопасными для LLM\nTEXT_EXTENSIONS: Set[str] = {\n    # код\n    \".py\", \".pyi\", \".ipynb\",\n    \".js\", \".jsx\", \".ts\", \".tsx\",\n    \".html\", \".htm\", \".css\", \".scss\", \".sass\",\n    \".vue\", \".svelte\",\n    \".java\", \".kt\", \".kts\", \".swift\", \".go\", \".rs\",\n    \".c\", \".h\", \".cpp\", \".hpp\", \".cc\",\n    \".cs\", \".vb\",\n    \".php\", \".rb\", \".r\", \".m\", \".mm\", \".jl\", \".pl\", \".lua\",\n\n    # конфиги/данные\n    \".json\", \".jsonc\", \".yaml\", \".yml\", \".toml\", \".ini\", \".cfg\", \".conf\", \".env.example\",\n    \".sql\", \".graphql\",\n    \".sh\", \".bash\", \".zsh\", \".ps1\", \".bat\", \".cmd\", \"Dockerfile\", \".dockerfile\",\n    \".gitignore\", \".gitattributes\", \".editorconfig\",\n\n    # документация\n    \".md\", \".rst\", \".adoc\",\n}\n\n# Предельно допустимый размер текстового файла (байт) — чтобы не раздувать JSON\nDEFAULT_MAX_BYTES = 500_000\n\n\ndef parse_args() -> argparse.Namespace:\n    p = argparse.ArgumentParser(description=\"Собрать код и структуру проекта в JSON для LLM\")\n    p.add_argument(\"--root\", default=\".\", help=\"Корень проекта (по умолчанию текущая директория)\")\n    p.add_argument(\"--out\", default=\"project_dump.json\", help=\"Путь к JSON-выводу\")\n    p.add_argument(\"--max-bytes\", type=int, default=DEFAULT_MAX_BYTES, help=\"Макс. размер файла для включения\")\n    p.add_argument(\"--tree-depth\", type=int, default=5, help=\"Глубина для вывода структуры (tree)\")\n    p.add_argument(\"--no-structure\", action=\"store_true\", help=\"Не сохранять structure.txt\")\n    p.add_argument(\"--include-ext\", nargs=\"*\", default=None,\n                   help=\"Доп. расширения для включения (пример: .lock .txt)\")\n    p.add_argument(\"--extra-ignore\", nargs=\"*\", default=None,\n                   help=\"Доп. glob-шаблоны игнора (пример: secrets/* *.lock)\")\n    return p.parse_args()\n\n\ndef load_text(path: Path, max_bytes: int) -> str | None:\n    try:\n        if path.stat().st_size > max_bytes:\n            return None\n        # читаем как текст; невалидные байты заменяем\n        return path.read_text(encoding=\"utf-8\", errors=\"replace\")\n    except Exception:\n        return None\n\n\ndef sha256_text(s: str) -> str:\n    return hashlib.sha256(s.encode(\"utf-8\", errors=\"replace\")).hexdigest()\n\n\ndef is_ignored(path: Path, rel: str, ignore_globs: Iterable[str]) -> bool:\n    name = path.name\n    parts = Path(rel).parts\n    if parts and parts[0] in ROOT_ONLY_IGNORE_DIRS:\n        return True\n    for pattern in ignore_globs:\n        # Совпадение по имени файла/папки или по относительному пути\n        if fnmatch(name, pattern) or fnmatch(rel, pattern):\n            return True\n        # Для директорий допустим точное совпадение сегмента\n        # (например, 'venv' игнорирует любой каталог с таким именем)\n        # parts = Path(rel).parts\n        if pattern in parts:\n            return True\n    return False\n\n\ndef detect_language(ext: str, name: str) -> str:\n    # Очень грубая эвристика — достаточно для LLM-навигации\n    if name.lower() in {\"dockerfile\", \"compose.yaml\", \"compose.yml\"}:\n        return \"docker\"\n    MAP = {\n        \".py\": \"python\", \".js\": \"javascript\", \".ts\": \"typescript\", \".tsx\": \"typescriptreact\",\n        \".jsx\": \"javascriptreact\", \".html\": \"html\", \".css\": \"css\", \".scss\": \"scss\",\n        \".json\": \"json\", \".yaml\": \"yaml\", \".yml\": \"yaml\", \".toml\": \"toml\", \".ini\": \"ini\",\n        \".md\": \"markdown\", \".rst\": \"restructuredtext\", \".adoc\": \"asciidoc\",\n        \".sh\": \"bash\", \".bash\": \"bash\", \".zsh\": \"zsh\", \".ps1\": \"powershell\",\n        \".sql\": \"sql\", \".graphql\": \"graphql\", \".go\": \"go\", \".rs\": \"rust\",\n        \".c\": \"c\", \".h\": \"c\", \".cpp\": \"cpp\", \".hpp\": \"cpp\", \".cc\": \"cpp\",\n        \".java\": \"java\", \".kt\": \"kotlin\", \".kts\": \"kotlin\", \".swift\": \"swift\",\n        \".rb\": \"ruby\", \".php\": \"php\", \".cs\": \"csharp\", \".m\": \"objectivec\", \".mm\": \"objectivecpp\",\n        \".lua\": \"lua\", \".r\": \"r\", \".pl\": \"perl\", \".jl\": \"julia\",\n    }\n    return MAP.get(ext.lower(), ext.lower().lstrip(\".\") or \"text\")\n\n\ndef run_tree(root: Path, depth: int) -> str:\n    \"\"\"\n    Рендер структуры, уважающий DEFAULT_IGNORE_GLOBS и ROOT_ONLY_IGNORE_DIRS.\n    Специально НЕ используем внешнюю утилиту `tree`, чтобы корректно\n    игнорировать только корневые каталоги (например, dataset в корне, но не services/dataset).\n    \"\"\"\n    lines: List[str] = []\n    base = root.resolve()\n    max_depth = depth\n\n    for curr, dirs, files in os.walk(base):\n        rel = Path(curr).relative_to(base)\n        d = len(rel.parts)\n\n        # 1) На верхнем уровне — вырезаем только ROOT_ONLY_IGNORE_DIRS\n        if d == 0:\n            dirs[:] = [dn for dn in dirs if dn not in ROOT_ONLY_IGNORE_DIRS]\n\n        # 2) Вырезаем прочие игноры НА ВСЕХ уровнях (по нашим же правилам)\n        pruned_dirs: List[str] = []\n        for dn in dirs:\n            full = Path(curr) / dn\n            rel_dir = full.relative_to(base).as_posix()\n            if is_ignored(full, rel_dir, DEFAULT_IGNORE_GLOBS):\n                continue\n            pruned_dirs.append(dn)\n        dirs[:] = pruned_dirs\n\n        if d > max_depth:\n            dirs[:] = []\n            continue\n\n        indent = \"  \" * d\n        name = \".\" if rel == Path(\".\") else rel.as_posix()\n        lines.append(f\"{indent}{name}/\")\n\n        for f in sorted(files):\n            full = Path(curr) / f\n            rel_file = full.relative_to(base).as_posix()\n            if is_ignored(full, rel_file, DEFAULT_IGNORE_GLOBS):\n                continue\n            lines.append(f\"{indent}  {f}\")\n\n    return \"\\n\".join(lines)\n\n\ndef should_take_file(path: Path, include_ext: Set[str]) -> bool:\n    name = path.name\n    ext = path.suffix\n    if name.lower() == \"dockerfile\":\n        return True\n    return (ext in include_ext) or (ext in TEXT_EXTENSIONS)\n\n\ndef main() -> None:\n    args = parse_args()\n    root = Path(args.root).resolve()\n\n    ignore_globs = list(DEFAULT_IGNORE_GLOBS)\n    if args.extra_ignore:\n        ignore_globs.extend(args.extra_ignore)\n\n    include_ext: Set[str] = set()\n    if args.include_ext:\n        include_ext.update({e if e.startswith(\".\") else f\".{e}\" for e in args.include_ext})\n\n    files_out: List[Dict[str, Any]] = []\n\n    for path in sorted(root.rglob(\"*\")):\n        rel = path.relative_to(root).as_posix()\n\n        # игнор директорий целиком\n        if any(part.startswith(\".git\") for part in Path(rel).parts):\n            continue\n        if is_ignored(path, rel, ignore_globs):\n            if path.is_dir():\n                # пропускаем поддеревья через os.walk? rglob сам проглотит; этого достаточно\n                continue\n            else:\n                continue\n\n        if path.is_dir():\n            continue\n        if not path.is_file():\n            continue\n\n        if not should_take_file(path, include_ext):\n            continue\n\n        text = load_text(path, args.max_bytes)\n        if text is None:\n            continue\n\n        lang = detect_language(path.suffix, path.name)\n        entry = {\n            \"path\": rel,\n            \"language\": lang,\n            \"size_bytes\": len(text.encode(\"utf-8\", errors=\"replace\")),\n            \"sha256\": sha256_text(text),\n            \"content\": text,\n        }\n        files_out.append(entry)\n\n    # Структура проекта (текстом)\n    structure_text = None\n    if not args.no_structure:\n        structure_text = run_tree(root, args.tree_depth)\n        try:\n            Path(\"structure.txt\").write_text(structure_text or \"\", encoding=\"utf-8\")\n        except Exception:\n            pass\n\n    # Итоговый JSON для LLM\n    payload: Dict[str, Any] = {\n        \"meta\": {\n            \"generated_at_utc\": datetime.utcnow().isoformat(timespec=\"seconds\") + \"Z\",\n            \"root\": str(root),\n            \"tool\": \"dump_project.py\",\n            \"max_file_bytes\": args.max_bytes,\n            \"total_files\": len(files_out),\n        },\n        \"context\": {\n            # Заполните эти поля один раз и держите «статикой»\n            \"project_description\": \"Краткое описание проекта, архитектура, стек, цели.\",\n            \"static_instructions\": [\n                \"Это команды для обсуждения, rewie, улучшения, оптимизации, модернизации и исправления кода для распознавания pdf-файлов с помощью парсинга и обучения YOLO модели и подготовке на основе этих данных отчетов в excel.\",\n                \"Проанализируй весь код проекта, разберись, что и с чем связано.\",\n                \"Каждый файл, который ты подготовишь, должен быть заполнен.\",\n                \"каждый кусок кода , который ты покажешь должен быть строго указан к какому файлу он принадлежит.\",\n                \"Имена переменных и функций — PEP8.\",\n                \"Писать код с упором на низкое потребление памяти и работу с большими данными.\",\n                \"Единый кастомный JSON-логгер через LoggerAdapter (время, уровень, имя функции, сообщение).\",\n                \"Документировать функции и ключевые участки кода.\",\n                \"Все изменения кода подписывай определенным файлом, в котором мы делаем изменения.\",\n                \"Не приводи допущений, где я сам должен что-то понять и довести дело до конца.\",\n                \"Объясни каждую строку кода.\",\n                \"Предлагай улучшения таким образом, чтобы не порушить существующую логику, которая уже работает.\",\n\n            ],\n            # Это «динамика»: что нужно сделать прямо сейчас\n            \"current_objectives\": [\n                # Примеры:\n                # \"Исправить фильтрацию по периоду в /users/money\",\n                # \"Усилить OCR: заменить pytesseract на ONNXRuntime PP-OCRv3\"\n            ],\n        },\n        \"structure_text\": structure_text,\n        \"files\": files_out,\n    }\n\n    out_path = Path(args.out)\n    out_path.write_text(json.dumps(payload, ensure_ascii=False, indent=2), encoding=\"utf-8\")\n\n    print(f\"[OK] Saved JSON → {out_path} ({len(files_out)} files)\")\n    if structure_text and not args.no_structure:\n        print(f\"[OK] Saved structure → structure.txt\")\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "path": "pyproject.toml",
      "language": "toml",
      "size_bytes": 597,
      "sha256": "ba6e96432fac00aa2dcaed1e2a3b301a9d0b0e8302484fc3d5ec6840b4e076c0",
      "content": "[tool.poetry]\npackage-mode = false\n\n[tool.poetry.dependencies]\npython = \"^3.12\"\nfastapi = \"^0.121.0\"\nuvicorn = {extras = [\"standard\"], version = \"^0.38.0\"}\npydantic = {extras = [\"email\"], version = \"^2.12.4\"}\npydantic-settings = \"^2.11.0\"\nsqlalchemy = {extras = [\"asyncio\"], version = \"^2.0.44\"}\nasyncpg = \"^0.30.0\"\nalembic = \"^1.17.1\"\norjson = \"^3.11.4\"\njinja2 = \"^3.1.6\"\npasslib = {extras = [\"bcrypt\"], version = \"^1.7.4\"}\npython-jose = {extras = [\"cryptography\"], version = \"^3.5.0\"}\nitsdangerous = \"^2.2.0\"\npython-multipart = \"^0.0.20\"\n\n[tool.poetry.group.dev.dependencies]\nblack = \"^25.9.0\"\n\n"
    },
    {
      "path": "static/css/style.css",
      "language": "css",
      "size_bytes": 1416,
      "sha256": "cdd89f0b75810bdc4afcd3c3a815acc6c8d25e22cd8fd4ec1f4047dea78fe6cd",
      "content": "/* /static/css/style.css */\n:root { --gap: 16px; --radius: 10px; --ok: #19a974; --ok-bg: #e6fbf2; --err: #d33; --err-bg: #fdecec; }\n\nbody { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; color: #111; background: #fafafa; }\n.container { max-width: 1000px; margin: 0 auto; padding: var(--gap); }\n\n.header { background: #fff; border-bottom: 1px solid #eee; }\n.navbar { display: flex; align-items: center; gap: var(--gap); }\n.navbar .brand { font-weight: 700; }\n.spacer { flex: 1; }\na { color: #0366d6; text-decoration: none; }\na:hover { text-decoration: underline; }\n\n.table { width: 100%; border-collapse: collapse; }\n.table th, .table td { border: 1px solid #ddd; padding: 8px; }\n.table th { background: #f3f3f3; text-align: left; }\n\n.form-row { display: grid; gap: 6px; margin-bottom: 12px; max-width: 420px; }\ninput { padding: 10px; border: 1px solid #ccc; border-radius: var(--radius); background: #fff; }\n.btn { padding: 8px 14px; border-radius: var(--radius); border: 1px solid #ccc; background: #fff; }\n.btn-primary { border-color: #0366d6; background: #0366d6; color: #fff; }\n.btn:hover { filter: brightness(0.98); }\n\n.alert { margin-bottom: var(--gap); padding: 12px 14px; border-radius: var(--radius); border: 2px solid transparent; }\n.alert-success { border-color: var(--ok); background: var(--ok-bg); }\n.alert-error { border-color: var(--err); background: var(--err-bg); }\n"
    },
    {
      "path": "static/js/app.js",
      "language": "javascript",
      "size_bytes": 122,
      "sha256": "8766499306abae5f9b5a07a4a2fc3a75e84b8b4699bb989c1fc7a6120843dd26",
      "content": "// /static/js/app.js\nwindow.addEventListener(\"DOMContentLoaded\", () => {\n  console.debug(\"[fsnb-fastapi] dom-ready\");\n});\n"
    },
    {
      "path": "templates/core/_header.html",
      "language": "html",
      "size_bytes": 665,
      "sha256": "de3a0b3a86305121316c49e8e220bfe451ef7c300b30e5377a1db28de5e646b5",
      "content": "<!-- /templates/core/_header.html -->\n<header class=\"container header\">\n  <nav class=\"navbar\">\n    <a href=\"{{ request.url_for('home') }}\" class=\"brand\">fsnb-fastapi</a>\n    <a href=\"{{ request.url_for('users_list_html') }}\">Пользователи</a>\n    <!-- Заглушки для будущих разделов -->\n    <a href=\"#\">Отчёты</a>\n    <a href=\"#\">Настройки</a>\n\n    <div class=\"spacer\"></div>\n\n    <!-- Кнопки справа -->\n    <a class=\"btn\" href=\"{{ request.url_for('login_html') }}\">Вход</a>\n    <a class=\"btn btn-primary\" href=\"{{ request.url_for('register_html') }}\">Регистрация</a>\n  </nav>\n</header>\n"
    },
    {
      "path": "templates/core/base.html",
      "language": "html",
      "size_bytes": 726,
      "sha256": "b08a604541d671c5bb993bfbe2c70e8b6767a2edc0aa8f96c72d177287bd7571",
      "content": "<!-- /templates/core/base.html -->\n<!doctype html>\n<html lang=\"ru\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>{% block title %}fsnb-fastapi{% endblock %}</title>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"{{ request.url_for('static', path='css/style.css') }}\" />\n  </head>\n  <body>\n    {% include \"core/_header.html\" %}\n    <main class=\"container\">\n      {% if alert %}\n        <div class=\"alert {{ 'alert-success' if alert.kind == 'success' else 'alert-error' }}\">{{ alert.text }}</div>\n      {% endif %}\n      {% block content %}{% endblock %}\n    </main>\n    <script src=\"{{ request.url_for('static', path='js/app.js') }}\"></script>\n  </body>\n</html>\n"
    },
    {
      "path": "templates/core/index.html",
      "language": "html",
      "size_bytes": 333,
      "sha256": "10182bc29dcea9ad523723ad331983038dee4b4247727d766fb9b5f0d99a8933",
      "content": "<!-- /templates/core/index.html -->\n{% extends \"core/base.html\" %}\n\n{% block title %}Главная — fsnb-fastapi{% endblock %}\n\n{% block content %}\n  <h1>Добро пожаловать</h1>\n  <p>Перейти к <a href=\"{{ request.url_for('users_list_html') }}\">списку пользователей</a>.</p>\n{% endblock %}\n"
    },
    {
      "path": "templates/core/login.html",
      "language": "html",
      "size_bytes": 843,
      "sha256": "aeece1a55b13e6f90dd2725479ba3aa67f9686e57caf283d94a00de1b520f0e8",
      "content": "<!-- /templates/core/login.html -->\n{% extends \"core/base.html\" %}\n{% block title %}Вход — fsnb-fastapi{% endblock %}\n\n{% block content %}\n  <h2>Вход</h2>\n  <form method=\"post\" action=\"{{ request.url_for('auth_token') }}\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf }}\" />\n    <div class=\"form-row\">\n      <label>E-mail</label>\n      <input name=\"username\" type=\"email\" required placeholder=\"email@domain.tld\" />\n    </div>\n    <div class=\"form-row\">\n      <label>Пароль</label>\n      <input name=\"password\" type=\"password\" required placeholder=\"********\" />\n    </div>\n    <div class=\"form-row\">\n      <label>Капча: {{ a }} + {{ b }} = ?</label>\n      <input name=\"captcha\" type=\"number\" required />\n    </div>\n    <button class=\"btn btn-primary\" type=\"submit\">Войти</button>\n  </form>\n{% endblock %}\n"
    },
    {
      "path": "templates/core/register.html",
      "language": "html",
      "size_bytes": 1099,
      "sha256": "d4dd724a5d1e01080932560dab06a93fe230c31591026e36a1c016af97d497e0",
      "content": "<!-- /templates/core/register.html -->\n{% extends \"core/base.html\" %}\n{% block title %}Регистрация — fsnb-fastapi{% endblock %}\n\n{% block content %}\n  <h2>Регистрация</h2>\n  <form method=\"post\" action=\"{{ request.url_for('register_post_html') }}\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf }}\" />\n    <div class=\"form-row\">\n      <label>E-mail</label>\n      <input name=\"email\" type=\"email\" required placeholder=\"email@domain.tld\" />\n    </div>\n    <div class=\"form-row\">\n      <label>Пароль</label>\n      <input name=\"password\" type=\"password\" minlength=\"8\" required placeholder=\"********\" />\n    </div>\n    <div class=\"form-row\">\n      <label>Повтор пароля</label>\n      <input name=\"password2\" type=\"password\" minlength=\"8\" required placeholder=\"********\" />\n    </div>\n    <div class=\"form-row\">\n      <label>Капча: {{ a }} + {{ b }} = ?</label>\n      <input name=\"captcha\" type=\"number\" required />\n    </div>\n    <button class=\"btn btn-primary\" type=\"submit\">Зарегистрироваться</button>\n  </form>\n{% endblock %}\n"
    },
    {
      "path": "templates/users/list.html",
      "language": "html",
      "size_bytes": 766,
      "sha256": "7bd57801b2ca81fb4483cc39d0f8778b791b6b7ff427a63ebda2db3a10e8e827",
      "content": "<!-- /templates/users/list.html -->\n{% extends \"base.html\" %}\n\n{% block title %}Пользователи — fsnb-fastapi{% endblock %}\n\n{% block content %}\n  <h1>Пользователи</h1>\n\n  {% if users and users|length > 0 %}\n    <table class=\"table\">\n      <thead>\n        <tr>\n          <th>ID</th>\n          <th>Username</th>\n          <th>Foo</th>\n          <th>Bar</th>\n        </tr>\n      </thead>\n      <tbody>\n        {% for u in users %}\n          <tr>\n            <td>{{ u.id }}</td>\n            <td>{{ u.username }}</td>\n            <td>{{ u.foo }}</td>\n            <td>{{ u.bar }}</td>\n          </tr>\n        {% endfor %}\n      </tbody>\n    </table>\n  {% else %}\n    <p>Пока нет пользователей.</p>\n  {% endif %}\n{% endblock %}\n"
    }
  ]
}